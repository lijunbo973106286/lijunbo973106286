# 1.day01Spring5

约定 > 配置 > 编码

> 不要记住代码，只记住代码关键字：比如 Proxy.newProxyInstence()
>
> 不要记住我的理论，要自己推理理论。

今天上午的核心内容：反射、工厂模式、配置文件读取。

## 1、没有Spring的时候

### 1.1 耦合和解耦的概念

> 什么叫耦合？
>
> 简单来说，程序的依赖关系：
>
> 1. 类之间的依赖关系
> 2. 方法之间的依赖关系

```java
public class A{
    int i;
}
public class B{
    public void say(A a){
        sout(a.i)
    }
}
public class C{
    main(){
        b = new B();
        c = new C();
        b.say(c);//可以传入C么？不行的，非A类不可！强耦合！
    }
}
```

A类和B类之间有没有耦合？

有，B类的say方法，直接依赖了A类。

> 非你不可！ 判断耦合的方式。

### 1.2 解耦的方式

反射、泛型、向上转型、设计模式。

> 向上转型？Map map = new HashMap();

接口回调方式，来对之前的A和B类解耦：

```java
interface D{
    void say();
}
class A implements D{
    int i = 0;
    void say(){
        sout("");
    }
}
class C implements D{
    int i = 0;
    void say(){
        sout("");
    }
}
class B{
    //传一个接口作为参数，使用向上转型的方式，可以传参所有实现类
    void say(D d){
        d.say();
    }
}
main(){
    b = new B();
    a = new A();
    c = new C();
    b.say(a);
}
```

用这种方式，我们的参数，直接写的是D接口，那么B类和A类之间的耦合就降低了。类似，显示生活中的 张岩的厕所(强耦合)，男厕所(低耦合)。

> 反射实现：
>
> 反射和new 对象的区别是什么？
>
> 反射：`编译期间不检查，运行期间检查。`

```
DriverManager.regiesterDriver(new com.mysql.jdbc.Driver());//如果你没有引入这个jar包，会直接报错，编译期间无法通过。DriverManager.regiesterDriver(Class.forName("com.mysql.jdbc.Driver"));//同样没有提供jar包，编译期间会报错么？运行期间才检查，然后发现没有，就报错。mybatis底层，是直接接收的字符串参数， 你传入什么数据库的驱动，我就动态帮你实例化什么驱动。
```

类似Mybatis框架(内部是不提供mysql-connection-java.jar)，解耦了对应数据库的驱动。你传mysql驱动配置，就会在`运行期间`动态实例化mysql的驱动。

### 1.3 工厂模式解耦

#### 1.3.1 第一个工厂模式

定义一个接口Person，然后自定义2个Person的实现类：

工厂代码如下：

```java
package com.woniuxy.firstfactory.impl;
/**
 * @Author: 马宇航
 * @Todo: 第一个工厂模式设计模式(主要就是用来创建对象！)，用来造人的！
 * @DateTime: 22/03/23/0023 上午 11:25
 * @Component: 成都蜗牛学苑
 **/
public class MarkPersonFactoryOne {
    /**
     * 传入国籍，就能创建不同的对象,工厂和目标类 之间 也有耦合！一旦多了一个实现类，则工厂也必须修改！
     * ChangeLog : 1. 创建 (22/03/23/0023 上午 11:27 [马宇航]);
     * @param nationality  请传入China或者American
     * @return java.lang.Object
    */
    public Object doMarkPerson(String nationality){
        if ("China".equals(nationality)){
            return new Chinese();
        }else if ("American".equals(nationality)){
            return new AmericanImpl();
        }else {
            return null;
        }
    }
}
```

测试类：

```java
package com.woniuxy.firstfactory;
import com.woniuxy.firstfactory.impl.MarkPersonFactoryOne;
/**
 * @Author: 马宇航
 * @Todo: 测试类，看看能不能通过工厂模式帮我创建一个对象
 * @DateTime: 22/03/23/0023 上午 11:31
 * @Component: 成都蜗牛学苑
 **/
public class TestFirstDemo {
    public static void main(String[] args) {
        MarkPersonFactoryOne markPersonFactoryOne = new MarkPersonFactoryOne();
        //使用了工厂模式以后，我们耦合降低了 TestFirstDemo 和 对象的中国人 美国人的耦合 被解开了！
        Person person= (Person) markPersonFactoryOne.doMarkPerson("China");
        person.eat();
        //强耦合 TestFirstDemo和china 是强耦合！
    }
}
```

> 引入了工厂模式以后，我们测试类和目标Person类之间的耦合，解耦了。但是，工厂和目标Person对象之间的耦合还是存在的，如果你有了第三个实现类，此时一定要改工厂的代码！

#### 1.3.2 第二个工厂模式

> 解决工厂类和目标类之间的耦合！
>
> 提示：去掉if else！

第二类工厂：如果有新增的目标类，我们也不用去修改这个工厂了！

```java
package com.woniuxy.secondfactory;
import com.woniuxy.firstfactory.Person;
/**
 * @Author: 马宇航
 * @Todo: 第二个工厂模式，解耦 工厂和目标类的耦合！
 * @DateTime: 22/03/23/0023 上午 11:42
 * @Component: 成都蜗牛学苑
 **/
public class MarkPersonFactoryTwo {
    /**
     * TODO 确保 即使添加了新的类，我也不需要去修改这个工厂！
     * ChangeLog : 1. 创建 (22/03/23/0023 下午 2:13 [马宇航]);
     * @param className 传入类名
     * @return com.woniuxy.firstfactory.Person
    */
    public Person doMakePerson(String className){
        try {
            return  (Person)Class.forName("com.woniuxy.firstfactory.impl." + className).newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

测试类：需要手动去改代码，才能实现类对象的切换！

```java
package com.woniuxy.secondfactory;
import com.woniuxy.firstfactory.Person;
/**
 * @Author: 马宇航
 * @Todo: 测试第二个工厂,如果新增了目标类，我们的工厂确实不用手动去修改，但是我们的测试类，使用的时候，还是要修改
 * @DateTime: 22/03/23/0023 下午 2:16
 * @Component: 成都蜗牛学苑
 **/
public class TestSecondDemo {
    public static void main(String[] args) {
        MarkPersonFactoryTwo markPersonFactoryTwo = new MarkPersonFactoryTwo();
        Person person = markPersonFactoryTwo.doMakePerson("Chinese");
        person.eat();
    }
}
```

#### 1.3.3 第三个工厂模式

> 完全不用修改任何java代码，即可实现目标类的切换！

配置文件如下：

```
#key=全限定类名person=com.woniuxy.firstfactory.impl.Russia
```

工厂代码：通过配置文件来获取

```java
package com.woniuxy.thirdfactory;
import com.woniuxy.firstfactory.Person;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
/**
 * @Author: 马宇航
 * @Todo: 新增第三个工厂模式，直接去配置文件中获取了
 * @DateTime: 22/03/23/0023 下午 2:25
 * @Component: 成都蜗牛学苑
 **/
public class MarkPersonFactoryThree {
    /**
     * 第三类工厂，直接通过配置，来实例化对象
     * @return
     */
    public Person doMakePerson(){
        //1.读取配置文件 Properties加载properties配置文件的
        Properties properties = new Properties();
        //2.读取配置文件
        InputStream resourceAsStream = MarkPersonFactoryThree.class.getClassLoader().getResourceAsStream("person.properties");
        try {
            properties.load(resourceAsStream);
        //3.获取里面的value
            String fullyQualifiedClassName = properties.getProperty("person");
        //4.通过反射创建对应的对象
            Class<?> aClass = Class.forName(fullyQualifiedClassName);
            return (Person) aClass.newInstance();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

测试类：

```java
package com.woniuxy.thirdfactory;
import com.woniuxy.firstfactory.Person;
/**
 * @Author: 马宇航
 * @Todo: 第三类测试类
 * @DateTime: 22/03/23/0023 下午 2:33
 * @Component: 成都蜗牛学苑
 **/
public class TestThirdDemo {
    public static void main(String[] args) {
        MarkPersonFactoryThree markPersonFactoryThree = new MarkPersonFactoryThree();
        Person person = markPersonFactoryThree.doMakePerson();
        person.eat();
    }
}
```

#### 1.3.4 第四个工厂模式

> Spring底层实现方案！
>
> 第四类工厂，解决的是一个对象的创建和管理的行为。你需要某个对象，不用自己去new了，而是通过我工厂帮你实例化好的对象，直接使用即可！

BeanFactory 工厂类，它是Spring的顶级父接口！

方法，getBean(“类名首字母小写”)，就可以直接获取到对应的对象了。

至于为什么要叫做bean！

> 没有为什么！

业务流程：

通过这个工厂，自动去配置文件中，读取所有的配置，并实例化配置文件中写的所有对象！然后把它封装到Map中！

开发者，只需要去这个map中get拿出来即可！

不需要开发者自行去new对象，产生强耦合。

Bean工厂：

```java
package com.woniuxy.fourthfactory;
import java.io.IOException;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
/**
 * @Author: 马宇航
 * @Todo: 第四类工厂模式，模仿Spring底层的实现！
 * @DateTime: 22/03/23/0023 下午 3:24
 * @Component: 成都蜗牛学苑
 **/
public class BeanFactory {
    //静态代码块，让这个工厂在new出来的时候，就直接去读取配置文件然后实例化全部对象！
    //封装！等会讲！
    //定义一个map的属性，用来封装实例化好的对象！static是在加载的时候 就会定义好，是跟着Class类对象走的！
    static Map allObject;
    static {
        //1.创建properties对象来获取配置文件
        Properties properties = new Properties();
        allObject = new HashMap<>();
        //2.加载配置文件
        try {
            properties.load(BeanFactory.class.getClassLoader().getResourceAsStream("spring.properties"));
            //3.获取配置文件中所有的key和value
            Enumeration<?> enumeration = properties.propertyNames();
            while (enumeration.hasMoreElements()) {
                //获取key元素，并转换成字符串
                String key = enumeration.nextElement()+"";
                System.out.println(key+"；keys");
                //通过key获取的全限定类名
                String property = properties.getProperty(key);
                //通过反射创建对象实例
                Object o = Class.forName(property).newInstance();
                allObject.put(key,o);
            }
        } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }
    /**
     * TODO 封装！隐藏具体的实现，开放一个公有的方法。空调隐藏具体的实现细节，开放一个遥控器给人使用！
     * ChangeLog : 1. 创建 (22/03/23/0023 下午 3:42 [马宇航]);
     * @param beanName 传入类名首字母小写的字符串即可
     * @return java.lang.Object
    */
    public Object getBean(String beanName){
        return allObject.get(beanName);
    }
}
```

测试类：

```
package com.woniuxy;
import com.woniuxy.firstfactory.Person;
import com.woniuxy.fourthfactory.BeanFactory;
public class Main {
    public static void main(String[] args) {
        //同学们来实现：每次getBean拿到不同对象 新增一句话
        //在加一句话
        BeanFactory beanFactory = new BeanFactory();
        Person person = (Person) beanFactory.getBean("russia");
        person.eat();
        System.out.println(person);
        Person person1 = (Person) beanFactory.getBean("russia");
        person.eat();
        System.out.println(person1);
        Person person2 = (Person) beanFactory.getBean("russia");
        person.eat();
        System.out.println(person2);
    }
}
```

### 1.4 总结

> 这么多工厂模式，是什么东西？拿来干嘛？
>
> 主要目标：解耦！
>
> 最后一个BeanFactory工厂的作用？
>
> 帮我们创建对象！通过配置文件，自动实例化对象，而不需要我们去new了！实现了解耦！

### 1.5 作业

> 根据第四类工厂模式，写getBean的时候才实例化对象，多例模式(原型模式)！

## 2、有Spring的时候

快速搭建spring项目，来观察，和第四类工厂模式的关系！

流程：不用你去写工厂模式了！spring框架自己有！

### 2.1 引入jar包！

Spring最简单版本，只需要核心包5个！即可使用！

spring-beans.jar

spring-context.jar

spring-expression.jar

spring-core.jar

spring-jcl.jar 里面包含了 commons-logging-1.2.jar

![image-20220323165938087](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203231659156.png)

### 2.2 写配置文件

![image-20220323170018781](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203231700904.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd">
<!--  properties
    russia=com.woniuxy.firstfactory.impl.Russia
    chinese=com.woniuxy.firstfactory.impl.Chinese
    americanImpl=com.woniuxy.firstfactory.impl.AmericanImpl
    japer=com.woniuxy.firstfactory.impl.Japer
  -->
<bean id="chinese" class="com.woniuxy.person.impl.Chinese"/>
<bean id="american" class="com.woniuxy.person.impl.AmericanImpl"/>
</beans>
```

### 2.3 测试类

```java
package com.woniuxy.person;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.core.io.ClassPathResource;
/**
 * @Author: 马宇航
 * @Todo: 测试 对象实例化！
 * @DateTime: 22/03/23/0023 下午 5:06
 * @Component: 成都蜗牛学苑
 **/
public class TestSpringFirst {
    public static void main(String[] args) {
        //没有自定义工厂了，用Spring的自带的工厂
        BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
        //使用BeanFactory接口来获取配置文件，是在getBean的时候进行了实例化对象的操作
        //第二次getBean的时候，没有实例化对象，默认是单例模式！
        Person person = (Person) beanFactory.getBean("chinese");
        System.out.println(person);
        Person person1 = (Person) beanFactory.getBean("chinese");
        System.out.println(person1);
//        Person person2 = (Person) beanFactory.getBean("chinese");
//        System.out.println(person2);
//        Person person3 = (Person) beanFactory.getBean("chinese");
//        System.out.println(person3);
//        Person person4 = (Person) beanFactory.getBean("chinese");
//        System.out.println(person4);
    }
}
```

# 2.day02IOC

## 1、复习

![image-20220324101952541](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203241019663.png)

## 2、Spring框架

什么是库(library)？

> 库是将代码集合成的一个产品，可以供程序猿调用。
>
> 例子：自己组装电脑，库就是我们电脑内部的一个有一个的部件，显卡，主板，CPU，电源，风扇。
>
> 库的优势，可以单独用，也能组合使用。

什么是框架(Framework)？

> 框架是为了解决一个(一类)问题，而开发的产品，而用户直接使用框架提供的类或者函数即可实现全部的功能。
>
> 例子：直接去黑心商家买的电脑整机。你还可以拆开它，然后替换其中的某些部件，虽然你可以直接用，但是也支持DIY。

学习一个新的框架的过程？

> 能动手不要动嘴， 边敲边理解，`不要说我理解后才敲`。

### 2.1 Spring基本概念

![pic-1605512946957](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210604102828.png)

介绍:

> Spring 被称为 [J2EE](https://baike.so.com/doc/901087-952427.html) 的春天，是一个`开源`的轻量级的 Java 开发框架， 具有`控制反转`（IOC）和`面向切面`（AOP）两大核心。Java Spring 框架通过声明式方式灵活地进行`事务`的管理，提高开发效率和质量。Spring 框架不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，`任何 Java 应用`都可以从 Spring 中受益。Spring 框架还是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力。

为什么要用spring？

> - 它定位的领域是许多其他刘新框架没有的，Spring关注提供一种方法，管理你的`业务对象`。
> - Spring是全面的`模块化`的。Spring有分层的体系结构，意味着你能选择使用它孤立的任何部分，并保证了架构仍然是内在稳定的。
> - Spring的设计，从底层帮助你编写易于测试的代码。Spring是用于测试驱动工程的理想框架。

### 2.2 Spring框架的优点

- `方便解耦`，简化开发：IOC容器，帮助我们将对象之间的依赖关系交给Spring进行控制，避免硬编码造成的过渡耦合。
- 方便`集成各种优秀框架`
- 降低api使用难度：封装了JDBC、JavaMail、远程调用等
- 方便测试
- AOP编程的支持
- 声明式事务的支持

### 2.3 Spring体系结构详解

![Image](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210604110616.gif)

图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。

重点模块标记红色

1. Data Access/Integration（数据访问／集成）
   - JDBC 模块：提供了一个 JDBC 的抽象层，大幅度减少了在开发过程中对数据库操作的编码。
   - ORM 模块:对流行的对象关系映射 API，包括 JPA、JDO、Hibernate 和 iBatis 提供了的集成层。
   - OXM 模块：提供了一个支持对象/XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。
   - JMS 模块：指 Java 消息服务，包含的功能为生产和消费的信息。
   - Transactions 事务模块:支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。
2. Web 模块
   - Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。
   - Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web 应用程序。
   - Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。
   - Portlet 模块：提供了在 Portlet 环境中使用 MVC实现，类似 Web-Servlet 模块的功能。
3. Core Container（核心容器）
   - Beans 模块(演员)：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。
   - Core 核心模块(道具)：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。可以把它理解为一个Util工具。用来发现、建立和维护每个Bean之间的关系。
   - Context 上下文模块(舞台)：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。它可以理解为Bean关系的集合。
   - Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。
4. 其他模块
   - AOP 模块:提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。
   - Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。
   - Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。
   - Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。

### [jar包下载点这里](https://repo.spring.io/simple/libs-release-local/org/springframework/spring)

## 2.3、IOC容器(重点，面试的重点)

### 1. 前言

> 重要性：它是万物的根基。只要是spring全家桶和springcloud等，最底层基础的内容就是IOC，就是这个思想。

IOC，俗称IOC容器，中文：`控制反转`。控制对象，`反转对象创建的方式`！由以前，开发自己new创建，变成了框架帮你创建。

IOC底层具体实现：反射，工厂，配置文件。参考我们自己写的BeanFactory！

IOC规范，定义，接口，它由BeanFactory来实现的。

### 2. BeanFactory

它是IOC实现的具体实现。

![image-20220324105627661](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203241056710.png)

```java
public class TestSpringFirst {
    public static void main(String[] args) {
        //没有自定义工厂了，用Spring的自带的工厂
//        BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
        //第二种方式，通过文件绝对路径来进行访问
        BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource("C:\\Users\\ASUS\\Desktop\\86期的笔记\\project86\\day01springdemo\\src\\applicationContext.xml"));
        //使用BeanFactory接口来获取配置文件，是在getBean的时候进行了实例化对象的操作
        //第二次getBean的时候，没有实例化对象，默认是单例模式！
        Person person = (Person) beanFactory.getBean("chinese");
        System.out.println(person);
        Person person1 = (Person) beanFactory.getBean("chinese");
        System.out.println(person1);
    }
}
```

了解即可，已经废弃过时！

### 3. ApplicationContext

![image-20220324111930660](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203241119735.png)

ApplicationContext是BeanFactory的子接口，那么它一定比它爸更厉害，它是spring的一个重要的核心容器，它包含所有的BeanFactory的功能，而且还添加了`国际化、资源访问、事件传播`等方面的支持。

#### 3.1 ClassPathXMLApplicationContext来获取配置文件

```java
package com.woniuxy.person;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.FileSystemResource;
/**
* @Author: 马宇航
* @Todo: 使用ApplicationContext来获取配置文件
* @DateTime:  22/03/24/0024 上午 11:24
* @Component: 成都蜗牛学苑
**/
public class TestSpringFirst {
    public static void main(String[] args) {
        //第一种，通过项目路径获取配置文件
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        Person person = applicationContext.getBean("chinese",Person.class);
        person.eat();
        System.out.println(person);
        Person person1 = applicationContext.getBean("chinese",Person.class);
        person1.eat();
        System.out.println(person1);
    }
}
```

> 注意：ApplicationContext，是在`读取配置文件的时候`，就实例化所有配置过对象了。

#### 3.2 FileSystemXmlApplicationContext

```java
package com.woniuxy.person;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;
import org.springframework.core.io.FileSystemResource;
/**
* @Author: 马宇航
* @Todo: 使用ApplicationContext来获取配置文件
* @DateTime:  22/03/24/0024 上午 11:24
* @Component: 成都蜗牛学苑
**/
public class TestSpringFirst {
    public static void main(String[] args) {
        //第一种，通过项目路径获取配置文件
//        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        //第二种，通过绝对路径获取配置文件
        ApplicationContext applicationContext = new FileSystemXmlApplicationContext("C:\\Users\\ASUS\\Desktop\\86期的笔记\\project86\\day01springdemo\\src\\applicationContext.xml");
        Person person = applicationContext.getBean("chinese",Person.class);
        person.eat();
        System.out.println(person);
        Person person1 = applicationContext.getBean("chinese",Person.class);
        person1.eat();
        System.out.println(person1);
    }
}
```

#### 3.3 区别

BeanFactory和ApplicationContext的区别：

> BeanFactory是在getBean的时候实例化对象；
>
> ApplicationContext是在加载配置文件的时候实例化；

## 2.4 Bean的概念

### 1. 定义

Bean在spring的作用，就像Object在OOP面向对象编程的意义一样。

Spring流行的一个关键因素，就是把对象的依赖关系，通过配置文件来管理，而且对象Bean也是通过Spring来维护它的全生命周期的。

![image-20220324113805776](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203241138828.png)

bean的配置：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd">
<!--  properties
    russia=com.woniuxy.firstfactory.impl.Russia
    chinese=com.woniuxy.firstfactory.impl.Chinese
    americanImpl=com.woniuxy.firstfactory.impl.AmericanImpl
    japer=com.woniuxy.firstfactory.impl.Japer
  -->
<bean id="chinese" class="com.woniuxy.person.impl.Chinese"/>
<bean id="american" class="com.woniuxy.person.impl.AmericanImpl"/>
</beans>
```

### 2. Bean的额外配置

可以配置name属性，定义多个不同的名称！

```
<bean name="chinese,china;ch" class="com.woniuxy.person.impl.Chinese"/>
```

如果id和name都没得？怎么办？

```
<bean class="com.woniuxy.person.impl.Chinese"/>
```

可以使用全限定类名来当做bean的名称！

### 3. Bean的实例化

类的实例化方式：

- 构造器实例化
- 反射实例化
- 工厂模式实例化

#### 3.1 构造器实例化

默认使用的无参构造器，如果有参，则需要添加新的子标签！

```xml
    <bean name="chinese" class="com.woniuxy.person.impl.Chinese">
        <constructor-arg value="马宇航"/>
    </bean>
```

构造实例化的多参形式：

```xml
   <bean name="chinese" class="com.woniuxy.person.impl.Chinese">
        <constructor-arg index="0" value="马宇航"/>
        <constructor-arg index="1">
            <list>
                <value>阿珂</value>
                <value>阿南</value>
                <value>阿东</value>
                <value>阿细</value>
            </list>
        </constructor-arg>
    </bean>
```

#### 3.2 工厂模式了解

分为静态方法和非静态方法：

java工厂代码如下：

```java
package com.woniuxy.person;
import com.woniuxy.person.impl.AmericanImpl;
import com.woniuxy.person.impl.Chinese;
import java.util.ArrayList;
/**
 * @Author: 马宇航
 * @Todo: 通过工厂模式来帮你实例化对象
 * @DateTime: 22/03/24/0024 下午 12:01
 * @Component: 成都蜗牛学苑
 **/
public class FactoryTest {
    public static Person doPerson(){
        return new Chinese("中国人");
    }
    public Person doPerson1doPerson(){
        return new AmericanImpl("美国人");
    }
}
```

配置文件：

```xml
<!--   静态工厂方法 -->
<!--  FactoryTest.doPerson()  -->
<bean name="factory" class="com.woniuxy.person.FactoryTest" factory-method="doPerson"></bean>
<!-- 非静态方法-->
<!--  FactoryTest fa = new FactoryTest()  -->
<bean id="fa" class="com.woniuxy.person.FactoryTest"></bean>
<!-- person = fa.doPerson1doPerson()  -->
<bean id="person" factory-bean="fa" factory-method="doPerson1doPerson"></bean>
```

### 4. bean的作用域范围

上面见过了 id，name，class，factory-bean，factory-method属性，还有一个属性`scope`，定义bean的作用域范围的。

什么是作用域范围？

> 作用域：当前的这个bean对象，可以在什么场景下使用，什么时候无法使用。

#### 4.1 非web环境下

##### 4.1.1 单例模式singleton

在整个作用域范围内，有且仅有一个对象，在堆中也只有一个对象。

```
<bean id="american,amer" class="com.woniuxy.person.impl.AmericanImpl" scope="singleton"/>
```

当IOC容器(工厂)关闭的时候，我们的对象才会销毁。

##### 4.1.2 原型模式prototype

```
<bean name="american,amer" class="com.woniuxy.person.impl.AmericanImpl" scope="prototype"/>
```

> 原型模式，每次getBean的时候都会创建一个对象。即使你是用的ApplicationContext 它也是getBean的时候创建的对象。

![image-20220324142541102](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203241425244.png)

#### 4.2 web环境下

##### 4.2.1 request

> 在一次http请求中，容器创建的bean对象是同一个实例。对于不同的http请求，创建的bean对象是不一样的。所以，我们的这个作用域范围，只包含Http request请求下。

##### 4.2.2 session

> 在一次http session会话中，容器创建的bean对象是同一个实例。对于不同的http请求，创建的bean对象是不一样的。所以，我们的这个作用域范围，只包含Http session请求下。

##### 4.2.3 application 应用

> 在每次ServletContext对象创建一个实例，仅在web相关的ApplicationContext容器中生效。

## 2.5 DI依赖注入(常见面试题)

### 1. 定义

> DI的全称(Dependency Injection)，中文叫做依赖注入，也称之为Bean的装配！

DI和IOC其实是描述的同一件事情，只不过，站的角度不同。

如果我站在框架的角度，框架帮忙创建对象，这个叫做IOC，控制的反转。

如果我站在代码的角度，由框架帮我注入属性，这个叫做DI，依赖注入。

DI：就是IOC的实现。

### 2. 注入方式

往一个类中设置属性，有哪些方法？？

> 1. 构造注入
> 2. setter注入
> 3. 反射
>
> spring中有2种注入方式：构造注入和setter注入。

#### 2.1 构造注入

```xml
<bean name="chinese" class="com.woniuxy.person.impl.Chinese">
    <constructor-arg index="0" value="马宇航"/>
    <constructor-arg index="1">
        <list>
            <value>阿珂</value>
            <value>阿南</value>
            <value>阿东</value>
            <value>阿细</value>
        </list>
    </constructor-arg>
</bean>
```

通过构造方法，对应传参即可。

写一个例子：`传对象进去`。

```xml
<!--  需要把自己写的类 配置到spring环境中  -->
    <bean id="wife" class="com.woniuxy.person.impl.Wife">
        <constructor-arg index="0" value="双儿"/>
        <constructor-arg index="1" value="18"/>
    </bean>
    <bean id="wife1" class="com.woniuxy.person.impl.Wife">
        <constructor-arg index="0" value="建宁公主"/>
        <constructor-arg index="1" value="21"/>
    </bean>
<!--  定义一个韦小宝  -->
    <bean id="haonanren" class="com.woniuxy.person.impl.Chinese">
        <constructor-arg name="name" value="韦小宝"/>
        <!-- ref 属性：它是reference 引用 配置过的 某个bean对象 -->
        <constructor-arg name="wife" ref="wife1"/>
    </bean>
<!-- 
对应java实现
Wife wife = new Wife("双儿",18);
Wife wife1 = new Wife("建宁公主",21);
Chinese haonanren = new Chinese("韦小宝",wife);
-->
```

#### 2.2 setter注入

必须对类中的属性提供set方法：

![image-20220324145147378](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203241451441.png)

```xml
<!--  定义一个韦小宝  -->
    <bean id="haonanren" class="com.woniuxy.person.impl.Chinese">
        <constructor-arg name="name" value="韦小宝"/>
<!--        <constructor-arg name="wife" ref="wife1"/>-->
<!--    在这里定义一个setter注入    -->
        <property name="wifemen">
            <list>
                <ref bean="wife"/>
                <ref bean="wife1"/>
                <bean class="com.woniuxy.person.impl.Wife">
                    <constructor-arg name="name" value="龙儿"/>
                    <constructor-arg name="age" value="36"/>
                </bean>
            </list>
        </property>
    </bean>
```

> 定义三个类：一个Clazz班级类 一个Student学生类，一个Teacher老师类

#### 2.3 autowire自动注入

> 在未来开发中，使用最多的形式！

会在整个IOC容器中，自动去帮你找到对应的bean对象，并成功注入到目标类中。

##### autowire=byName

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="eightyOne" class="com.woniuxy.person.autowiretest.ClazzEightyOne" autowire="byName">
        <property name="students">
            <list>
                <bean  class="com.woniuxy.person.autowiretest.Student">
                    <property name="name" value="张岩"/>
                    <property name="sex" value="男"/>
                </bean>
                <bean  class="com.woniuxy.person.autowiretest.Student">
                    <property name="name" value="邓敬"/>
                    <property name="sex" value="男"/>
                </bean>
            </list>
        </property>
    </bean>
    <bean id="teacher" class="com.woniuxy.person.autowiretest.Teacher">
        <property name="name" value="马宇航"/>
    </bean>
    <bean id="teacher1" class="com.woniuxy.person.autowiretest.Teacher">
        <property name="name" value="雷老师"/>
    </bean>
</beans>
```

> byName注入：是根据名称来注入，名称必须和`set方法的名称`来进行匹配！

![image-20220324160526614](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203241605676.png)

##### autowire=byType

```xml
  <bean id="eightyOne" class="com.woniuxy.person.autowiretest.ClazzEightyOne" autowire="byType">
        <property name="students">
            <list>
                <bean  class="com.woniuxy.person.autowiretest.Student">
                    <property name="name" value="张岩"/>
                    <property name="sex" value="男"/>
                </bean>
                <bean  class="com.woniuxy.person.autowiretest.Student">
                    <property name="name" value="邓敬"/>
                    <property name="sex" value="男"/>
                </bean>
            </list>
        </property>
    </bean>
    <bean id="teacher" class="com.woniuxy.person.autowiretest.Teacher">
        <property name="name" value="马宇航"/>
    </bean>
<!--    <bean id="teacher1" class="com.woniuxy.person.autowiretest.Teacher">-->
<!--        <property name="name" value="雷老师"/>-->
<!--    </bean>-->
```

> byType: 在整个IOC容器中，同一个类型，有且仅有一个的时候，我们才使用byType！否则xml中会报错。
>
> 同一个类型，是包含了所有的子类父类等类型。
>
> autowire=”default”
>
> 默认就是默认没有自动注入！

### 3. 注解装配

后面讲…… 我们将不再大量使用xml来配置我们自定义的类。为什么？

我一个项目，不多，也就500个类，你来。所以，以后我们学到后面，再讲解注解装配等方式。

## 2.6 补充知识(了解即可)

### 1. 命名空间简化配置

> 命名空间：国际化资源标识符(IRI)定义xml元素和属性集合的配置，约束文件的配置。通常称之为XML词汇。

![image-20220324162746528](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203241627602.png)

### 2.p标签和util命名空间

p是property的简写 用于处理setter注入！

![image-20220324162936869](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203241629964.png)

这个熟悉一下就行，以后工作后有公司这么写能看懂即可。

> util标签，可以让你在xml配置中，定义集合类型。类似new ArrayList();

![image-20220324163405053](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203241634146.png)

![image-20220324163158942](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203241631041.png)

# day03 SM整合含maven

## 1、复习

![image-20220325094219597](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203250942717.png)

## 2、Maven

### 1. 为什么要使用Maven

> 痛点：
>
> 1. jar难得找
> 2. jar包之间的依赖问题：spring的核心包依赖了 commons-logging
> 3. jar包之间的冲突 版本升级导致问题
> 4. jar包不方便管理：没有一个统一的文件夹来管理所有的jar包
> 5. 项目结构五花八门：没有一个统一的`约定`！
> 6. 项目的生命周期控制：自己写脚本来控制项目的生命周期，清理out输入的class文件，打包war、jar包等

### 2.Maven是什么？

可以解决上面所有痛点的一个工具，是开发者的福音。

> 核心概念：约定 > 配置

使用maven搭建的项目架构，都需要遵循同样的结构，`java源文件、资源文件、测试用例类文件、静态资源文件`这些都是约定好的，大家都按照这个约定来，所有如果你们的项目是使用maven创建的，招新人来接手，如果他们懂maven，根本不需要培训，上来就可以看懂整个项目的结构。

maven给每个jar定义了唯一的标志，这个在maven中叫做项目的`坐标`，通过这个坐标可以找到你需要用到的任何版本的jar包。

maven会`自动解决jar依赖`的问题，比如你用到了a-1.0.jar，而a-1.0.jar依赖于b-1.1.jar和c-1.5.jar，当我们通过maven把a-1.0.jar引入之后，b-1.1.jar和c-1.5.jar会自动被引入进来。

maven可以很容易的`解决不同版本之间的jar冲突`的问题。

maven使开发者更加方便的控制`整个项目的生命周期`，比如：

> mvn clear 可以清理上次已编译好的代码
> mvn compile 可以自动编译项目
> mvn test 可以自动运行所有测试用例
> mvn package 可以完成打包需要的所有操作(自动包含了清理、编译、测试的过程)

还有更多更多好用的操作，由于maven使所有项目结构都是约定好的，所以这些操作都被简化为了非常简单的命令。

再来看一下官方解释什么是maven：`maven是apache软件基金会组织维护的一款自动化构建工具，专注服务于java平台的项目构建和依赖管理`。

### 3. window安装maven

> 前置要求：必须安装JDK！

#### 1. 安装Maven

下载maven3.8.5
下载地址：https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.8.5

![image-20220325104115546](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251041605.png)

首先在conf/settings.xml文件：

添加本地仓库的位置的配置：

![image-20220325104613738](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251046799.png)

配置好以后，再配置一个国内镜像！

![image-20220325104838610](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251048656.png)

国内镜像：就是阿里在国内的服务器，里面有所有的国外maven仓库中的依赖。

![image-20220325105006370](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251050479.png)

打开系统环境变量：

在系统变量中添加M2_HOME的配置

![image-20220325105233510](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251052549.png)

在path变量中添加：

![image-20220325105327007](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251053053.png)

打开cmd：

![image-20220325105443042](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251054190.png)

#### 2.在IDEA中配置Maven

一个是当前set设置的配置，还有一个是new Project setting！

file->settings:

![image-20220325111446549](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251114631.png)

新项目默认打开的配置：

![image-20220325111534206](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251116164.png)

后面配置还是和之前一样。

> 额外补充：
>
> 未来一定会做一件事情，就是导入别人写好的maven项目！
>
> ![image-20220325111803354](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251118440.png)
>
> 导入别人的项目的时候，必须提前检查一下maven的配置，如果不对，一定改为本地的maven配置。
>
> 原因是因为，项目中有.mvn文件和.idea文件，一个是项目的maven配置，一个是项目的idea配置。
>
> 如果项目配置有问题，直接删掉.idea文件，重新配置即可。

#### 3. 在idea中创建maven项目！

打开idea，点击`File->New->Project`，或者new—>module选择`Maven`，如下：

![image-20210806140635959](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210806140636.png)

直接点击next，修改GroupId，后面再进行解释：

![image-20210806141053405](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210806141053.png)

创建成功，项目结构如下：

![image-20210806141306968](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210806141307.png)

#### 4. 文件目录

Maven 提倡使用一个共同的标准目录结构，Maven 使用**约定优于配置**的原则，大家尽可能的遵守这样的目录结构，如下所示：

| 目录                               | 目的                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| ${basedir}                         | 存放pom.xml和所有子目录                                      |
| ${basedir}/src/main/java           | 项目的java源代码                                             |
| ${basedir}/src/main/resources      | 项目的资源文件,放配置文件的地方, 比如property文件,springmvc.xml文件 |
| ${basedir}/src/test/java           | 项目的测试类,比如junit代码                                   |
| ${basedir}/src/test/resources      | 测试用资源文件                                               |
| ${basedir}/src/main/webapp/WEB-INF | web应用文件目录,web项目的信息,比如存放web.xml、本地图片、jsp视图页面 |
| ${basedir}/target                  | 编译和`打包`输出的地方                                       |
| ${basedir}/target/classes          | 编译输出目录                                                 |
| ${basedir}/target/test-classes     | 测试编译输出目录                                             |
| Test.java                          | Maven只会自动运行符合该命名规则的测试类                      |
| ~/.m2/repository                   | Maven默认的本地仓库目录位置                                  |

#### 5. pom文件

当我们在项目中需要用到maven帮我们解决jar包依赖问题，帮我们解决项目中的**编译、测试、打包、部署**时，项目中必须要有pom.xml文件，这些都是依靠pom的配置来完成的。

POM( Project Object Model，项目对象模型 ) 是 Maven 工程的`基本工作单元`，是一个XML文件，包含了项目的基本信息，用于描述`项目如何构件`，`声明项目依赖`，等等。

执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。

POM 中可以指定以下配置：

- 项目依赖
- 插件
- 执行目标
- 项目构件 profile
- 项目版本
- 项目开发者列表
- 相关邮件列表信息

在创建 POM 之前，我们首先需要描述项目组 (groupId)，项目的唯一ID。

项目maven相关的基本信息：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<!--  模型版本 当前项目用的maven的版本  -->
    <modelVersion>4.0.0</modelVersion>
<!-- 当前项目构件所属的组，通常是公司域名反过来 -->
    <groupId>com.woniuxy</groupId>
<!-- 项目的唯一id，一个groupId下面可以有多个不同的artifactId   -->
    <artifactId>day03maven</artifactId>
<!--  版本号  -->
    <version>1.3-SNAPSHOT</version>
<!--  可选的打包方式，比如war包或者jar包  -->
    <packaging>jar</packaging>
<!-- jdk对应版本-->
    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
</project>
```

> goupId：定义当前构件所属的组，通常与域名反向一一对应。
>
> artifactId：项目组中构件的编号。
>
> version：当前构件的版本号，每个构件可能会发布多个版本，通过版本号来区分不同版本的构件。
>
> packaging：定义该构件的打包方式，比如我们需要把项目打成jar包，采用`java -jar`去运行这个jar包，那这个值为jar；若当前是一个web项目，需要打成war包部署到tomcat中，那这个值就是war，可选（jar、war、ear、pom、maven-plugin），比较常用的是jar、war、pom。

上面接元素中，groupId、artifactId、version是必须要定义的，packaging可以省略，`默认为jar`。

#### 6. 引入依赖

直接通过dependences标签，就能让我们自定义依赖。

定义好依赖以后，必须刷新一下maven！

![image-20220325113526178](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251135252.png)

![image-20220325113545103](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203251135166.png)

```xml
 <dependencies>
        <!-- 在这里添加你的依赖坐标 -->
        <dependency>
            <!-- 核心依赖坐标3个配置 -->
            <groupId></groupId>
            <artifactId></artifactId>
            <version></version>
            <!-- 不用配置 默认是jar -->
            <type></type>
            <!-- 依赖范围 -->
            <scope></scope>
            <!-- 可选传递依赖 -->
            <optional></optional>
             <!-- 排除依赖 -->
            <exclusions>
                <exclusion> 
                    <groupId>com.woniuxy</groupId>
                     <artifactId>C</artifactId>
                </exclusion>
                <exclusion></exclusion>
            </exclusions>
        </dependency>
    </dependencies>
```

- dependencies元素中可以包含多个`dependency`，每个`dependency`就表示当前项目需要依赖的一个构件的信息

- dependency中groupId、artifactId、version是定位一个构件必须要提供的信息，所以这几个是必须的

- type：依赖的类型，表示所要依赖的构件的类型，对应于被依赖的构件的packaging。大部分情况下，该元素不被声明，默认值为jar，表示被依赖的构件是一个jar包。

- scope：依赖的范围，后面讲解

- optional：标记依赖是否可选，后面讲解

- exclusions：用来排除传递性的依赖

  通常情况下我们依赖的都是一些jar包，所以大多数情况下，只需要提供`groupId、artifactId、version`信息就可以了。

> 额外：
>
> maven坐标查询网址：https://search.maven.org/search?q=context

## 3、SM

Spring+Mybatis整合！

### 1.二阶段的mybatis配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!--
       Copyright 2009-2012 the original author or authors.
       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at
          http://www.apache.org/licenses/LICENSE-2.0
       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
-->
<!DOCTYPE configuration
    PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <settings>
        <setting name="lazyLoadingEnabled" value="true"/>
        <setting name="proxyFactory" value="JAVASSIST"/>
        <setting name="aggressiveLazyLoading" value="false" />
    </settings>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC">
                <property name="" value="" />
            </transactionManager>
            <dataSource type="UNPOOLED">
                <property name="driver" value="org.hsqldb.jdbcDriver" />
                <property name="url" value="jdbc:hsqldb:mem:javassist" />
                <property name="username" value="sa" />
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="org/apache/ibatis/submitted/javassist/Mapper.xml" />
    </mappers>
</configuration>
```

封装SqlSessionFactory：

```java
public class MybatisUtils{
    private static SqlSessionFactory sqlSessionFactory;
    private static SqlSession getSqlSession(){
        sqlSessionFactory = SqlSessionFactroy.build(MybatisUtils.class.getClassLoader.getResourceAsStream("mybatis-config.xml"));
       return sqlSessionFactory.openSession();
    }
}
```

总结：

1. 数据源DataSource
2. 配置Mapper.xml文件所在文件夹
3. 需要SqlSessionFactory，来制造SqlSession
4. 通过sqlSession.executor , executor .insert(“insert into mytable ^^^^”)
5. 还可以MapperStatement对mapper.xml进行一个映射

- 完整流程如下图：

  ![Image](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210611103932.png)

### 2.三阶段mybatis的使用

我们三阶段还是需要配置: `数据源、SQLSessionFactory，Mapper.xml映射(对应存在什么文件夹)！`

为了和二阶段的mybatis的使用的区别，多了一个jar包：

mybatis-spring.jar

说明这个jar包是mybatis厂商，为了结合适配spring，而开发的中间件。

这个jar包中，SqlSessionFactoryBean 这个类！

### 3.SM整合

#### 3.1 引入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.woniuxy</groupId>
    <artifactId>day03SM</artifactId>
    <version>1.0-SNAPSHOT</version>
    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
<!--  引入依赖  -->
    <dependencies>
<!--    1.spring必须要有    -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.16</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>5.3.16</version>
        </dependency>
<!--    2.spring-jdbc 和 spring事务    -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>5.3.16</version>
        </dependency>
        <!--    tx 是事务包    -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-tx</artifactId>
            <version>5.3.16</version>
        </dependency>
<!--     3.mybatis的依赖   -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.7</version>
        </dependency>
<!--     3.1 mybatis-spring   -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
            <version>2.0.6</version>
        </dependency>
<!--      4.mysql驱动  -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.27</version>
        </dependency>
<!--    5.数据源DBCP 连接池    -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-dbcp2</artifactId>
            <version>2.8.0</version>
        </dependency>
    </dependencies>
</project>
```

#### 3.2 添加db.properties

```properties
jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/woniu_k15
jdbc.username=root
jdbc.password=123456
```

#### 3.3 添加applicationContext.xml配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd ">
<!-- 配置 注解的扫描,这个配置后，就会扫描对应包下的类和子包下的类的注解   -->
    <context:component-scan base-package="com.woniuxy"/>
<!-- 读取db文件 这里引入db后，下方可以直接使用 ${key}  -->
    <context:property-placeholder location="classpath:db.properties"/>
<!--  1.配置数据源 BasicDataSource -->
<!--    <bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource">-->
<!--        <property name="driverClassName" value="${jdbc.driver}"/>-->
<!--        <property name="url" value="${jdbc.url}"/>-->
<!--        <property name="username" value="${jdbc.username}"/>-->
<!--        <property name="password" value="${jdbc.password}"/>-->
<!--    </bean>-->
<!-- 配置druid的数据源   -->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
<!--  2.配置工厂  -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
<!--     配置mapper.xml所在文件夹   -->
        <property name="mapperLocations" value="classpath:mapper/*.xml"/>
<!--     配置别名   -->
        <property name="typeAliasesPackage" value="com.woniuxy.entity"/>
    </bean>
<!--  额外扩展，推荐项目中，配置sqlSessionTemplate  这个包含的功能更强大  -->
    <bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate">
        <constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"/>
    </bean>
<!--  3.方式一：配置dao接口 但是dao是个接口，无法直接实例化 (不推荐) sqlSession.getMapper(RbacManagerDao.class) -->
<!--    <bean id="rbacManagerDao" class="org.mybatis.spring.mapper.MapperFactoryBean">-->
<!--&lt;!&ndash;     这个是 需要注入sqlsession 工厂   &ndash;&gt;-->
<!--        <property name="sqlSessionFactory" ref="sqlSessionFactory"/>-->
<!--&lt;!&ndash;      手动配置，你需要动态代理的 dao接口！ 框架底层 帮你实例化了dao接口 并注入sqlSessionFactory&ndash;&gt;-->
<!--        <property name="mapperInterface" value="com.woniuxy.dao.RbacManagerDao"/>-->
<!--    </bean>-->
<!-- 3. 方式二：使用MapperScanner扫描 自动帮我注册dao的实现类-->
    <bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer">
<!--      通过名字 自动注入对应的bean 但是不是使用ref了，底层会根据bean的名字 自动去IOC容器中找到这个工厂  -->
<!--        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>-->
<!--     有了SqlSessionTemplate 就不需要SqlSessionFactory   -->
        <property name="sqlSessionTemplateBeanName" value="sqlSessionTemplate"/>
        <property name="basePackage" value="com.woniuxy.dao"/>
    </bean>
</beans>
```

## 4.完整SM最终版流程(快速配置流程)

#### 1.引入依赖

#### 2. 配置db和applicationContext

### 3.开发业务代码entity层

### 4.开发业务代码dao层 和 mapper.xml

### 5.开发业务代码service

# day04 Spring-AOP

## 1、复习

![image-20220328094451554](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203280944655.png)

## 2、AOP的概述和出现背景

### 2.1 背景

AOP是什么？面向切面编程！那么，我们已经有了IOC，为什么还需要有AOP呢？

IOC：控制反转，解耦了对象与对象之间的耦合(不直接内部new对象了)。代码之间，有没有入侵性？我DI一个对象进入到另外一个对象中，有没有入侵性？(你的对象中，有我这个对象的类名。)

AOP：解决的是代码入侵 ！用了AOP，将`不会`出现代码的入侵！但是运行的时候，却能够执行其他的类的代码！我侵入了，但是又没完全侵入！`运行的时候`，确实就其他奇怪的代码在一起执行，但是，我去看源代码，又看不见入侵的代码。

现实生活中，有没有类似的现象？

> 跑马拉松，中途某些点，提供了可以随便拿的水。它现象就是运动员就是我们的代码，他们正常在执行，我们中途提供了一些水，但是这些水，不会摆放在道路中间，不会影响到正常的比赛。

AOP的目的，就是实现，在`不影响正常代码执行`的情况下，在你执行中，特定位置，额外运行一些其他的代码内容：事务，比如日志！

### 2.2 定义

> AOP的全称是Aspect-Oriented Programming，即面向`切面`编程。它是面向对象编程（OOP）的一种补充，目前已成为一种比较成熟的编程方式。
>
> 官方定义：可以通过 `预编译`方式和运行期 `动态代理`实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。
>
> 民间翻译：简单的说它就是把我们程序`重复的代码`抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。

## 3、静态代理

它没有违背AOP的特性，静态代理也可以没有侵入性！但是，它有弊端呢？

静态代理实现的无侵入性代理方法，它有一个什么弊端？一个静态代理，只能代理一个目标对象的方法。如果`有多个目标对象`(奥特蛋存在)，那么我就`需要多个静态代理来对它进行代理`。

它有一个设计原则：开闭原则！`对扩展开放，对修改关闭！`。

现实生活中有没有静态代理：

直播带货，微信朋友圈微商，他们是厂家的代理！真正货物是厂家提供。

![image-20220328112520302](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203281125363.png)

方法2种：

一种是继承统一个接口的方式实现静态代理；

一种继承目标类，子类拓展目标类。

## 4、动态代理

![image-20210615160741966](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210615160742.png)

### 4.1 JDK动态代理

JDK提供的代理方式：继承同一个接口实现的动态代理！

JDK的方法。核心类：Proxy.newProxyInstance()

```java
package com.woniuxy.jdkproxy;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
/**
 * @Author: 马宇航
 * @Todo: 使用的是JDK动态代理来实现 对目标类的增强
 * @DateTime: 22/03/28/0028 上午 11:28
 * @Component: 成都蜗牛学苑
 **/
public class JdkProxyFactory{
    /**
     * jdk动态代理的实现
     * ChangeLog : 1. 创建 (22/03/28/0028 上午 11:28 [马宇航]);
     *
     * @return java.lang.Object
    */
    public Object createProxyObject(Object obj){
        Object o = Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        //前置增强
                        System.out.println("怪兽1开始入侵地球！");
                        //通过反射，来动态实现目标对象方法的执行 反射执行方法
                        Object invoke = method.invoke(obj, args);
                        //后置增强
                        System.out.println("哥斯拉被打败了!");
                        return invoke;
                    }
                });
        return o;
    }
}
```

测试类：

```java
package com.woniuxy.jdkproxy;
import com.woniuxy.staticproxy.DiGer;
import com.woniuxy.staticproxy.Tailo;
import com.woniuxy.staticproxy.UtraMan;
import com.woniuxy.staticproxy.UtraManImpl;
/**
 * @Author: 马宇航
 * @Todo: 测试JDK动态代理的方法，现在的代理对象，是动态产生的，由于传入的对象改变而动态改变
 * @DateTime: 22/03/28/0028 上午 11:33
 * @Component: 成都蜗牛学苑
 **/
public class TestJDKProxyDemo {
    public static void main(String[] args) {
        //目标对象
        UtraMan utraMan = new Tailo();
        //jdk代理对象工厂
        JdkProxyFactory jdkProxyFactory = new JdkProxyFactory();
        //代理对象工厂 重新生成的一个 已经封装好的代理对象
        UtraMan utraMan1 = (UtraMan) jdkProxyFactory.createProxyObject(utraMan);
        //新的代理对象执行方法
        utraMan1.hit();
        System.out.println("战斗结束");
    }
}
```

### 4.2 CGlib动态代理

通过子类扩展父类的方式实现动态代理！

```java
package com.woniuxy.cglibproxy;
import org.springframework.cglib.proxy.Callback;
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;
/**
 * @Author: 马宇航
 * @Todo: CgLib动态代理，需要额外jar包 spring-aop,它支持没有接口的类！
 * @DateTime: 22/03/28/0028 上午 11:43
 * @Component: 成都蜗牛学苑
 **/
public class CglibProxyFactory {
    public Object createProxyObject(Object obj){
        Object o = Enhancer.create(obj.getClass(), new MethodInterceptor() {
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                //前置方法
                System.out.println("怪兽cglib入侵地球！");
                //这种写法不用去记忆
                Object o1 = methodProxy.invokeSuper(o, objects);
                //后置方法
                System.out.println("cglib怪兽被打败了！");
                return o1;
            }
        });
        return o;
    }
}
```

测试类：

```java
package com.woniuxy.cglibproxy;
import com.woniuxy.staticproxy.DiGer;
/**
 * @Author: 马宇航
 * @Todo: TODO
 * @DateTime: 22/03/28/0028 上午 11:52
 * @Component: 成都蜗牛学苑
 **/
public class TestCglibProxy {
    public static void main(String[] args) {
//        AtruManFather atruManFather = new AtruManFather();
        DiGer diGer = new DiGer();
        CglibProxyFactory cglibProxyFactory = new CglibProxyFactory();
        DiGer proxyObject = (DiGer) cglibProxyFactory.createProxyObject(diGer);
        proxyObject.hit();
    }
}
```

> 练习：
>
> 1. 定义一个service方法，比如addUser，findAll; 则两个方法写死，不用调用dao；
> 2. 定义一个日志类，preMethod()//前置增强方法， endMethod()//后置增强
> 3. 定义一个jdk动态代理
> 4. 定义一个测试类，传入service，通过动态代理，生成一个代理类
> 5. 执行代理类的方法。$proxy202
>
> 动态代理和静态代理的区别？
>
> 1. 什么时间点生成的代理对象？
>
>    静态代理是在编译之前，就写好了代理对象。这个是写死的固定的。
>
>    动态代理是在运行的时候，动态生成的代理对象，这个是后期由动态代理的方法，通过反射来实现的。

## 5、SpringAOP核心概念和应用

学习这个概念性的目的：为了能够正常沟通。

![image-20220328144529026](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203281445145.png)

### 5.1 术语

这些术语并非Spring特有：

`切面(方面)`：我们准备切入到目标类的方法、代码；比如：日志打印方法，事务提交方法。

`连接点`：目标类中，允许被切入的点。但是，java中，连接点是不能在方法内部的。

`切入点`：连接点上，被切面切的点。正式已经切入了的连接点。

`通知`：切面中提供的具体方法，叫做通知。比如：日志通知，事务提交通知。

`目标对象`：被切的对象。通常也指被切的对象的方法。

`AOP代理`：jdk动态代理和Cglib动态代理。

`织入`：就是切入。

![image-20220328143947753](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203281439876.png)

### 5.2 通知的类型

Spring AOP包括以下类型的通知:

`前置通知(Before advice)`: 在连接点之前运行但不能阻止执行流继续到连接点的通知(除非它抛出异常)。

`后置通知(After returning advice)`: 通知将在连接点正常完成后运行(例如，如果方法返回时没有抛出异常)。

`抛出异常后通知(After throwing advice)`: 如果方法通过抛出异常而退出，则执行通知。

`最终通知(After (finally) advice)`**: 无论连接点以何种方式退出(正常或异常返回)，都要执行通知。**

`环绕通知(Around advice)`: 围绕连接点(如方法调用)的通知。这是最有力的建议。Around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续到连接点，还是通过返回自己的返回值或抛出异常来简化建议的方法执行。

引介通知(了解)：通常是在对源代码进行修改的情况下，引入的通知。

![image-20220328144417842](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203281444951.png)

## 6、ProxyFactoryBean(了解)

Spring提供的一个动态代理的工厂！它内部帮我们写好了动态代理的方法。

### 1. 引入依赖

spring-context ： 内部包含了aop的！

### 2. 编写目标service代码

### 3. 编写切面类

需要继承MethodInterceptor，方法拦截器接口！才能够对目标方法进行拦截！

```java
package com.woniuxy.service.aspect;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.cglib.proxy.InvocationHandler;
import java.lang.reflect.Method;
/**
 * @Author: 马宇航
 * @Todo: 切面类，内部就是定义具体的前置后置方法的实现的
 * @DateTime: 22/03/28/0028 下午 2:14
 * @Component: 成都蜗牛学苑
 **/
public class MyAspect implements MethodInterceptor {
    public void log(){
        System.out.println("日志记录开始……");
    }
    public void commitTransation(){
        System.out.println("提交事务！");
    }
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        log();
        Object proceed = invocation.proceed();
        commitTransation();
        return proceed;
    }
}


```

### 4. 编写配置类

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd">
<!--  目标类  -->
    <bean id="rbacManagerService" class="com.woniuxy.service.impl.RbacManagerServiceImpl"/>
<!-- 切面类   -->
    <bean id="aspect" class="com.woniuxy.service.aspect.MyAspect"/>
<!-- 了解即可，ProxyFactoryBean，和之前自己实现的方法差不多   -->
    <bean id="factoryBean" class="org.springframework.aop.framework.ProxyFactoryBean">
<!--      配置我们的目标类对象  -->
        <property name="target" ref="rbacManagerService"/>
<!--     目标类的接口配置   -->
        <property name="proxyInterfaces" value="com.woniuxy.service.RbacManagerService"/>
<!--     切面类的名字   -->
        <property name="interceptorNames" value="aspect"/>
<!--     true使用的是cglib，false就是用的jdk动态代理！   -->
        <property name="proxyTargetClass" value="false"/>
    </bean>
</beans>
```

### 5. 测试类

```java
package com.woniuxy.service;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
/**
 * @Author: 马宇航
 * @Todo: TODO
 * @DateTime: 22/03/28/0028 下午 3:10
 * @Component: 成都蜗牛学苑
 **/
public class ProxyFactoryBeanTest {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("application.xml");
        RbacManagerService rbacManagerService = (RbacManagerService) applicationContext.getBean("factoryBean");
        rbacManagerService.addOne();
        rbacManagerService.findAll();
        rbacManagerService.findOne();
    }
}
```

## 7、AspectJ实现AOP

之前的ProxyFactoryBean它只能单个进行动态代理，类似之前MapperFactoryBean，在企业中，我们通常不会这么去配置，只是学习的时候，作为入门了解。

### 7.1 定义

> AspectJ它是基于Java的第三方AOP框架，它内部提供了强大的功能。
>
> 在Spring2.0以后，Spring-aop就引入了对AspectJ的支持，并允许直接通过AspectJ进行编程，而Spring-aop它的AOP的API，也尽量与AspectJ保持一致。新版本aop的开发，也都一定要基于AspectJ来实现。
>
> 实现AspectJ的两种方式：一种是基于xml的配置文件形式，一种是声明式注解的方式来实现。

### 7.2 基于xml的形式实现

#### 1. 引入依赖

```xml
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.16</version>
        </dependency>
<!--   aspectj的依赖     -->
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.7</version>
        </dependency>
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjrt</artifactId>
            <version>1.9.7</version>
        </dependency>
        <dependency>
            <groupId>aopalliance</groupId>
            <artifactId>aopalliance</artifactId>
            <version>1.0</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
            <version>5.3.16</version>
        </dependency>
```

#### 2. 定义切面

```java
package com.woniuxy.aspectj;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
/**
 * @Author: 马宇航
 * @Todo: 切面类
 * @DateTime: 22/03/28/0028 下午 3:27
 * @Component: 成都蜗牛学苑
 **/
public class MyAspectJ {
    /**
     * 前置通知
     * ChangeLog : 1. 创建 (22/03/28/0028 下午 3:28 [马宇航]);
     * @param joinpoint  连接点
     * @return void
    */
    public void myBefore(JoinPoint joinpoint){
        System.out.println("----------------------------------------");
        System.out.println("前置通知：日志打印开始……");
        System.out.println("对应目标类是："+joinpoint.getTarget());
        System.out.println("对应目标类的方法是："+joinpoint.getSignature().getName());
        System.out.println("----------------------------------------");
    }
    /**
     * 后置通知
     * ChangeLog : 1. 创建 (22/03/28/0028 下午 4:32 [马宇航]);
     * @param joinpoint
     * @return void
    */
    public void afterReturing(JoinPoint joinpoint){
        System.out.println("----------------------------------------");
        System.out.println("后置通知：事务提交开始……");
        System.out.println("对应目标类是："+joinpoint.getTarget());
        System.out.println("对应目标类的方法是："+joinpoint.getSignature().getName());
        System.out.println("----------------------------------------");
    }
    /**
     * 最终通知
     * ChangeLog : 1. 创建 (22/03/28/0028 下午 4:32 [马宇航]);
     *
     * @return void
    */
    public void after(){
        System.out.println("----------------------------------------");
        System.out.println("最终通知执行，无论你的代码是否发生异常。");
        System.out.println("----------------------------------------");
    }
    /**
     * 异常通知
     * ChangeLog : 1. 创建 (22/03/28/0028 下午 4:33 [马宇航]);
     * @param e
     * @return void
    */
    public void afterThrowing(Exception e){
        System.out.println("----------------------------------------");
        System.out.println("异常通知执行：报错类型是"+e.getMessage());
        System.out.println("----------------------------------------");
    }
    /**
     * 内部环绕：不推荐使用，因为环绕通知，可以修改入参。可以修改返回值！
     * ChangeLog : 1. 创建 (22/03/28/0028 下午 4:39 [马宇航]);
     * @param joinPoint
     * @return void
    */
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("环绕通知：前置通知……");
        //目标方法的入参
        Object[] args = joinPoint.getArgs();
        for (Object arg : args) {
            System.out.println(arg);
        }
        args[0] = 9;
        args[1] = 10;
        //环绕通知中，目标方法的执行
        Object proceed = joinPoint.proceed(args);
        System.out.println(proceed);
        System.out.println("环绕通知：后置通知……");
        return (int)proceed+1;
    }
}
```

#### 3. 定义目标service方法

#### 4. 定义配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd ">
    <context:component-scan base-package="com"/>
    <!--  目标类  -->
    <!-- 切面类   -->
    <bean id="aspectj" class="com.woniuxy.aspectj.MyAspectJ"/>
    <aop:config>
        <!--     切入点：具体要切入的什么地方   -->
        <aop:pointcut id="pointcut" expression="execution(* com.woniuxy.service.impl.*.find*(..))"/>
        <!--     切面类   -->
        <aop:aspect ref="aspectj">
            <aop:before method="myBefore" pointcut-ref="pointcut"/>
            <aop:after-returning method="afterReturing" pointcut-ref="pointcut"/>
        </aop:aspect>
    </aop:config>
</beans>
```

![image-20210617112216612](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210617112216.png)

> 那么，我们目标类使用的方式是不会发生改变，和之前一样使用，但是，切面类，在你不知情的情况下，织入了它内部的通知。

#### 5、切入点表达式

> 切入点表达式的标准模板规范：
>
> execution(modifiers-pattern? return-type-pattern 空格 declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
>
> modifiers-pattern? 表示访问修饰符，？问号表示可以省略
>
> return-type-pattern 表示返回类型，不可省略
>
> declaring-type-pattern? 类的类路径 可以省略的
>
> name-pattern 方法的名称，不允许省略 可以使用insert* 表示 所有前缀是 insert的方法比如，insertOne
>
> (param-pattern) 方法的入参，通常(..)表示任意参数都行 不允许省略
>
> throws-pattern? 抛出的异常类型 允许省略

各类demo如下，了解即可：

```xml
//拦截com.woniuxy.service包下所有类的所有方法
execution(* com.woniuxy.service.*.*(..))        
//拦截所有public方法
execution(public * *(..))
//save开头的方法
execution(* save*(..))
//拦截指定类的指定方法, 拦截时候一定要定位到方法
execution(public * com.woniuxy.g_pointcut.OrderDao.save(..))
//拦截指定类的所有方法  
execution(* com.woniuxy.g_pointcut.UserDao.*(..))
//拦截指定包，以及其子包下所有类的所有方法  
execution(* com..*.*(..))
//多个表达式
// ||和or表示两种满足其一即可，取两个表达式的并集
execution(* com.woniuxy.g_pointcut.UserDao.save()) || execution(* com.woniuxy.g_pointcut.OrderDao.save())
execution(* com.woniuxy.g_pointcut.UserDao.save()) or execution(* com.woniuxy.g_pointcut.OrderDao.save())
// &&和and 表示两种都同时满足才行，取交集
//下面2个且关系的，没有意义，最好是有范围类型的交集
execution(* com.woniuxy.g_pointcut.UserDao.save()) && execution(* com.woniuxy.g_pointcut.OrderDao.save())
execution(* com.woniuxy.g_pointcut.UserDao.save()) and execution(* com.woniuxy.g_pointcut.OrderDao.save())
//取非值   !和not表示不在该范围内的作为切点
!execution(* com.woniuxy.g_pointcut.OrderDao.save())
not execution(* com.woniuxy.g_pointcut.OrderDao.save())
```

### 7.3 基于注解的形式实现

同上，唯一区别：

1. 切面类有改动
2. 配置类方式不一样

切面类：

```java
package com.woniuxy.aspectj;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;
/**
 * @Author: 马宇航
 * @Todo: 切面类，工具类
 * @DateTime: 22/03/28/0028 下午 3:27
 * @Component: 成都蜗牛学苑
 **/
@Aspect //它是一个切面
@Component//组件 工具的意思
public class MyAspectJ {
    @Pointcut("execution(* *(..))")
    public void pointCut(){
    }
    /**
     * 前置通知
     * ChangeLog : 1. 创建 (22/03/28/0028 下午 3:28 [马宇航]);
     * @param joinpoint  连接点
     * @return void
    */
    @Before("pointCut()")
    public void myBefore(JoinPoint joinpoint){
        System.out.println("----------------------------------------");
        System.out.println("前置通知：日志打印开始……");
        System.out.println("对应目标类是："+joinpoint.getTarget());
        System.out.println("对应目标类的方法是："+joinpoint.getSignature().getName());
        System.out.println("----------------------------------------");
    }
    /**
     * 后置通知
     * ChangeLog : 1. 创建 (22/03/28/0028 下午 4:32 [马宇航]);
     * @param joinpoint
     * @return void
    */
    @AfterReturning("pointCut()")
    public void afterReturing(JoinPoint joinpoint){
        System.out.println("----------------------------------------");
        System.out.println("后置通知：事务提交开始……");
        System.out.println("对应目标类是："+joinpoint.getTarget());
        System.out.println("对应目标类的方法是："+joinpoint.getSignature().getName());
        System.out.println("----------------------------------------");
    }
    /**
     * 最终通知
     * ChangeLog : 1. 创建 (22/03/28/0028 下午 4:32 [马宇航]);
     *
     * @return void
    */
    @After("pointCut()")
    public void after(){
        System.out.println("----------------------------------------");
        System.out.println("最终通知执行，无论你的代码是否发生异常。");
        System.out.println("----------------------------------------");
    }
    /**
     * 异常通知
     * ChangeLog : 1. 创建 (22/03/28/0028 下午 4:33 [马宇航]);
     * @param e
     * @return void
    */
    @AfterThrowing(value = "pointCut()",throwing="e")
    public void afterThrowing(Exception e){
        System.out.println("----------------------------------------");
        System.out.println("异常通知执行：报错类型是"+e.getMessage());
        System.out.println("----------------------------------------");
    }
    /**
     * 内部环绕：不推荐使用，因为环绕通知，可以修改入参。可以修改返回值！
     * ChangeLog : 1. 创建 (22/03/28/0028 下午 4:39 [马宇航]);
     * @param joinPoint
     * @return void
    */
    @Around("pointCut()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("环绕通知：前置通知……");
        //目标方法的入参
        Object[] args = joinPoint.getArgs();
        //环绕通知中，目标方法的执行
        Object proceed = joinPoint.proceed(args);
        System.out.println(proceed);
        System.out.println("环绕通知：后置通知……");
        return proceed;
    }
}
```

配置类：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd ">
<!--  自动扫描  -->
    <context:component-scan base-package="com"/>
<!-- aop的自动配置标签   -->
    <aop:aspectj-autoproxy/>
</beans>
```

### 7.4 执行顺序

![image-20220120165716300](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202201201657423.png)

![image-20220120170310929](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202201201703028.png)

<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202201201705949.png" alt="image-20220120170552852" style="zoom:150%;" />



# day05 事务

## 1、复习

![image-20220329093907203](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203290939293.png)

## 2、事务的学习

### 2.1 基于xml配置事务

流程：

1. 引入依赖：spring-context 、 spring-aop相关的依赖、`spring-tx事务包`、SM整合

   ```xml
      <dependencies>
           <!--    1.spring必须要有    -->
           <dependency>
               <groupId>org.springframework</groupId>
               <artifactId>spring-context</artifactId>
               <version>5.3.16</version>
           </dependency>
           <dependency>
               <groupId>org.springframework</groupId>
               <artifactId>spring-test</artifactId>
               <version>5.3.16</version>
           </dependency>
           <!--    2.spring-jdbc 和 spring事务    -->
           <dependency>
               <groupId>org.springframework</groupId>
               <artifactId>spring-jdbc</artifactId>
               <version>5.3.16</version>
           </dependency>
           <!--    tx 是事务包    -->
           <dependency>
               <groupId>org.springframework</groupId>
               <artifactId>spring-tx</artifactId>
               <version>5.3.16</version>
           </dependency>
           <!--     3.mybatis的依赖   -->
           <dependency>
               <groupId>org.mybatis</groupId>
               <artifactId>mybatis</artifactId>
               <version>3.5.7</version>
           </dependency>
           <!--     3.1 mybatis-spring   -->
           <dependency>
               <groupId>org.mybatis</groupId>
               <artifactId>mybatis-spring</artifactId>
               <version>2.0.6</version>
           </dependency>
           <!--      4.mysql驱动  -->
           <dependency>
               <groupId>mysql</groupId>
               <artifactId>mysql-connector-java</artifactId>
               <version>8.0.27</version>
           </dependency>
           <!--    5.数据源DBCP 连接池    -->
           <dependency>
               <groupId>org.apache.commons</groupId>
               <artifactId>commons-dbcp2</artifactId>
               <version>2.8.0</version>
           </dependency>
           <dependency>
               <groupId>com.alibaba</groupId>
               <artifactId>druid</artifactId>
               <version>1.2.8</version>
           </dependency>
   <!--    AOP的相关依赖    -->
           <dependency>
               <groupId>org.aspectj</groupId>
               <artifactId>aspectjrt</artifactId>
               <version>1.9.7</version>
           </dependency>
           <dependency>
               <groupId>org.springframework</groupId>
               <artifactId>spring-aspects</artifactId>
               <version>5.3.16</version>
           </dependency>
           <dependency>
               <groupId>aopalliance</groupId>
               <artifactId>aopalliance</artifactId>
               <version>1.0</version>
           </dependency>
       </dependencies>
   </project>
   ```

1. 配置SM整合，以及事务管理器(通知)的配置，以及AOP切面配置！事务配置在Service，因为service可以执行多个数据库操作，原子性

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xmlns:tx="http://www.springframework.org/schema/tx"
          xmlns:aop="http://www.springframework.org/schema/aop"
          xsi:schemaLocation="http://www.springframework.org/schema/beans 
          http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd
           http://www.springframework.org/schema/tx
           http://www.springframework.org/schema/tx/spring-tx.xsd
           http://www.springframework.org/schema/aop
           http://www.springframework.org/schema/aop/spring-aop.xsd ">
   <!--  SM整合   -->
   <!--  1.读取db.properties文件，下方可以使用${}来使用db中的值  -->
       <context:property-placeholder location="classpath:db.properties"/>
   <!--  2.配置数据源  -->
       <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
           <property name="driverClassName" value="${jdbc.driver}"/>
           <property name="url" value="${jdbc.url}"/>
           <property name="username" value="${jdbc.username}"/>
           <property name="password" value="${jdbc.password}"/>
       </bean>
   <!--  3.配置SqlSessionFactoryBean   -->
       <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
           <property name="dataSource" ref="dataSource"/>
           <property name="mapperLocations" value="classpath:mapper/*.xml"/>
           <property name="typeAliasesPackage" value="com.woniuxy.entity"/>
       </bean>
   <!--  4.配置SqlSessionTemplate  -->
       <bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate">
           <constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"/>
       </bean>
   <!--  5.MapperScannerConfigurer 扫描dao的，然后使用动态代理自动创建实现类  -->
       <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
           <property name="basePackage" value="com.woniuxy.dao"/>
       </bean>
   <!-- SM配置结束   -->
   <!-- 事务配置开始  配置事务管理器   -->
       <bean id="dataSourceTransactionManager" class="org.springframework.jdbc.support.JdbcTransactionManager">
           <property name="dataSource" ref="dataSource"/>
       </bean>
   <!-- 配置事务通知(切面内的东西)，等待AOP切入   -->
       <tx:advice id="transactionInterceptor" transaction-manager="dataSourceTransactionManager">
           <tx:attributes>
   <!--         指定哪些方法 加上事务   -->
               <tx:method name="*"/>
               <tx:method name="add*" propagation="NEVER"/>
           </tx:attributes>
       </tx:advice>
       <aop:config>
   <!--    配置aop要使用的 通知器    -->
           <aop:advisor advice-ref="transactionInterceptor" pointcut="execution(* com.woniuxy.service.impl.*.*(..))"/>
       </aop:config>
   <!--  自己的业务对象的一个注册  -->
       <bean id="rbacManagerService" class="com.woniuxy.service.impl.RbacManagerServiceImpl">
   <!--     上面有配置MapperScanner 所以这里是可以直接ref引用   -->
           <property name="rbacManagerDao" ref="rbacManagerDao"/>
       </bean>
   </beans>
   ```

   > `<tx:method>`它有一些属性：
   >
   > name：表示对那些方法起事务的作用，比如：add*表示，对add开头的方法，有事务的效果。
   >
   > propagation：表示事务的传播行为；默认值Required；
   >
   > isolation：隔离级别；默认值是default
   >
   > read-only：事务是否只读；默认值是false；
   >
   > timeout：事务的超时时间；默认值-1，永不超时。
   >
   > rollback-for：指定异常回滚；指定多个对应的异常类，出现异常事务回滚的异常类。

### 2.2 基于注解的事务配置(未来开发主要的方式)

简单，在对应方法上面添加[@Transactional](https://github.com/Transactional)，就ok了。

然后配置文件中添加：

```xml
<!--最简单方式，直接配置事务注解驱动即可！然后就能直接使用@Transactional注解 来配置事务 -->
<!-- 事务配置开始  配置事务管理器   -->
    <bean id="transactionManager" class="org.springframework.jdbc.support.JdbcTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
<tx:annotation-driven transaction-manager="transactionManager"/>
```

```xml
@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.SERIALIZABLE)
```



## 3、事务的隔离级别

一个数据库可能拥有多个访问它的客户端，那么这些客户端同时对这个数据库进行并发访问或者修改数据的时候，如果没有采取隔离措施，就会出现问题。5类不同的问题：3类数据读取的问题：脏读、不可重复读、幻读。还有2类问题是更新导致的问题：第一类更新丢失和第二类更新丢失。

### 1. 脏读

A事务，读取到了B事务尚`未提交`的数据。A事务，在对数据进行操作的时候，B事务还未提交，然后出问题，B事务回滚后，就会导致A事务的`查询`的数据不正确，感觉像是出现了脏数据一样。

### 2. 不可重复读 update、delete 行级锁

A事务两次读取到的数据不一致，是因为B事务在中途已经提交的这个数据的更新或者删除操作。

### 3. 幻读 insert 表锁来处理

A事务两次读取到的数据不一致，读取到了B事务已经提交的新增数据（添加一条数据），就会引发幻读。一般是在求count、sum等聚合函数的操作中出现的问题。

> 区别：
>
> 不可重复读和幻读的区别：不可重复读主要是读取到了事务的更新或删除导致的变化后的数据，而幻读是读取到了事务已提交的新增数据。解决方案，`防止我们读取到更改或者删除的数据`通常我们都是添加`行级锁`，来防止操作中的数据被其他事务所修改。`防止读取到新增数据`，我们通常是添加`表锁`，防止表单的数据被其他事务新增。

### 4. 第一类更新丢失

A事务回滚的时候，把B事务已提交的数据给覆盖掉了。后回滚的事务，覆盖掉了前面提交的事务。

### 5. 第二类更新丢失

A事务提交更新的时候，把之前B事务提交的更新数据给覆盖掉了。后提交的事务，覆盖了前面提交的事务。

### 数据库隔离级别：

隔离级别，就是处理前面5大问题的方式：

![img](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210115121824.jpg)

隔离级别越高，并发性就越低。

并发：我一边吃饭一边唱歌。作用的目标是同一个。

并行：我一边听歌，一边唱歌。作用的目标是多个。同时进行。

### spring隔离级别(Isolation)

#### 1.spring提供的tx包，支持的事务隔离级别和mysql数据库的隔离级别是一个意思！

| 读数据一致性及允许的并发副作用 隔离级别 | 读数据一致性                                                 | 脏读 | 不可重复读 | 幻读 |
| --------------------------------------- | ------------------------------------------------------------ | ---- | ---------- | ---- |
| **读未提交（Read uncommitted）**        | **最低级别，只能保证不读取物理上损坏的数据**，事务可以看到其他事务没有被提交的数据（脏数据） | 是   | 是         | 是   |
| **读已提交**（Read committed）**        | **语句级**，事务可以看到其他事务已经提交的数据               | 否   | 是         | 是   |
| **可重复读**（Repeatable read）**       | **事务级**，事务中两次查询的结果相同                         | 否   | 否         | 是   |
| **串行化**（Serializable）**            | **最高级别**，事务级。顺序执行                               | 否   | 否         | 否   |

### spring控制事务隔离级别，属性有

#### 1）DEFAULT （默认）

这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.另外四个与JDBC的隔离级别相对应。

#### 2）READ_UNCOMMITTED （读未提交）

这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。

#### 3）READ_COMMITTED （读已提交）

保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。

#### 4）REPEATABLE_READ （可重复读）

这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读

#### 5）SERIALIZABLE（串行化）

这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。

## 4、事务传播机制(Propagetion)

A方法有事务，B方法没有事务，然后再A方法中调用了B方法，此时，(默认)事务传播下去了。

### 1. 默认是Required

默认的事务传播机制！

这个是默认配置：

A调用B， 如果A有事务，B没有事务，则事务包含A和B；

A调用B, 如果A没有事务，B有事务，这A和B都将`没有事务`！

下面两张图是第一种情况，传播下去！

![image-20210115143345410](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210115143345.png)![image-20210115143355168](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210115143355.png)

### 2. SUPPORTS supports 支持

A调用B，如果A没有事务，B有事务，则A和B都没有事务！

A调用B，如果A有事务，B没有事务，则A和B有事务，但是无法回滚,如下方解释！

直接调用B，则无事务

> 我们在正常开发过程中，要尽量避免事务的传播，不要在service中，自己调用自己service的方法，请直接service调用多个dao的方法都可以。

# day06 SpringMVC

## 1、复习

![image-20220330094801084](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203300948179.png)

## 2、SpringMVC概念

SpringMVC它是Spring提供的一个基于Java的WebMVC设计模式，可开发的轻量级Web框架。

> MVC：
>
> Model：实体类，用于封装数据
>
> View：视图页面
>
> Controller：控制器，后端的入口代码

### 1.1 SpringMVC的特点

- 是Spring框架的一部分，可以更加便捷整合使用Spring所提供的其他功能。
- 灵活性强，易于与其他框架集成(这个也是Spring框架的优势)。
- 提供了一个前端控制器`DispatcherServlet`，核心大脑，开发人员无需额外开发各种控制器对象。
- 可以`自动`绑定用户输入信息，并`正确地转换数据类型`。
- 内置了常见的校验器，可以校验用户输入。如果校验不能通过，那么就会重定向到输入表单。
- 支持国际化，可以根据用户区域显示多国语言。
- 支持多种视图技术。它支持JSP、Velocity和FreeMarker等视图技术。
- 使用基于XML的配置文件，在编辑后，不需要重新编译应用程序。

### 1.2 三层架构模型

![image-20210118155608397](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210118155608.png)

### 1.3 MVC设计模型：

![image-20210118104253829](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210118104300.png)

优势：

1、解耦：把视图，数据和控制器解耦，会增加一点前期开发的时间，但是项目结构清晰，易于扩展！

2、提供了一个前端控制器DispatcherServlet，使开发人员无需额外开发控制器对象！

劣势：

1、前期配置过多，小型项目，不如直接基于jsp开发的速度快！

2、大型项目，一定不要直接用jsp进行开发！我们的SpringMVC更适合大型项目！

## 3、搭建SpringMVC步骤

### 3.1 创建web项目

方式一：直接Maven选中下图，创建web项目！

![image-20220330103518559](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203301035649.png)

方式二：创建空的maven项目，在项目上右键，设置它为web项目！

![image-20220330103712399](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203301037460.png)

![image-20220330103739696](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203301037755.png)

> 如果src文件夹没有，手动创建即可！有提示，可以快速创建。

### 3.2 引入依赖

根据第一种创建web项目的方式，来添加的依赖配置！

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.woniuxy</groupId>
  <artifactId>day06springmvc</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>
  <name>day06springmvc Maven Webapp</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
<!-- springmvc项目最少需要配置这个：内部包含了spring-context所有依赖   -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.3.16</version>
    </dependency>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>servlet-api</artifactId>
      <version>2.5</version>
    </dependency>
  </dependencies>
  <build>
    <finalName>day06springmvc</finalName>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.1.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.22.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-war-plugin</artifactId>
          <version>3.2.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>
```

### 3.3 配置web.xml

最少配置，后期再添加个编码转换的，静态资源处理的配置即可，目前就按下面这个来！

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <servlet>
        <servlet-name>dispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
<!--     我们的ApplicationContext.xml配置文件所在的位置   -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
<!--     配置文件加载时机:一启动就加载   -->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcherServlet</servlet-name>
<!--    拦截所有请求    -->
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

### 3.4 创建applicationContext.xml

### 3.5 配置controller控制器

```java
package com.woniuxy.controller;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * @Author: 马宇航
 * @Todo: 就是我们后端的控制器
 * @DateTime: 22/03/30/0030 上午 10:46
 * @Component: 成都蜗牛学苑
 **/
public class MyFirstController implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
//        String username = request.getParameter("username");
        //后面再解释！
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject("msg","欢迎来到对抗路！");
        modelAndView.setViewName("/index.jsp");
        return modelAndView;
    }
}
```

### 3.6 配置controller成为bean

这个id的值，就是前端请求，所对应的接口名称：http://localhost:8080/myfirst 使用这个即可访问下面接口！

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- 怀念二阶段的servlet   -->
    <bean id="/myfirst" class="com.woniuxy.controller.MyFirstController"/>
</beans>
```

### 3.7 配置tomcat

通过右上角配置tomcat：

![image-20220330111559738](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203301115771.png)

添加tomcat

![image-20220330105257034](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203301052108.png)

配置项目打包的文件：

![image-20220330111702592](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203301117664.png)

选择带后缀的，这个是idea的特性，是虚拟war包，并非直接把项目打包放入webapp中。

![image-20220330111736983](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203301117020.png)

最后一步，推荐删掉下方的内容，否则，url会比较长……

![image-20220330111837811](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203301118886.png)

## 4、商业中开发的方式

### 4.1 [@Controller](https://github.com/Controller)注解

我们controller代码不用实现Controller接口！

就能够把我们的controller代码注册到Spring容器中，需要添加配置文件

```xml
<!-- 企业级开发方式   -->
<context:component-scan base-package="com.woniuxy.controller"/>
```

> 仅仅只是注册到容器中，那么URL映射？还没有！

### 4.2 [@RequestMapping](https://github.com/RequestMapping)

这个注解可以添加在类上和方法上，它有一些属性：value(url路径)，method(请求的方式)，

```java
@RequestMapping(value = "/findOne",method = RequestMethod.POST)
//这两种写法是一个意思
@PostMapping("/findOne")
```

其他另类用法，不常用：

```java
    // /*/findOne表示，findOne前面只能有一个层级，但是字符不限制 /laksjdflkajs/findOne
    // /**/one 表示，前面可以有多个层级，每个层级内部字符不限制 /askljdf/asdf/one
    @RequestMapping(value = {"/*/findOne","/**/one"},method = RequestMethod.GET)
```

### 4.3 处理请求

前端请求携带的参数，后端来分别对应处理！

> 字符串、数组、集合、对象
>
> 下面讲的内容：全都是基于`form表单`形式提交的数据！而且仅仅只是form表单才这么玩！

#### 4.3.1 字符串

```java
package com.woniuxy.controller;
import com.sun.org.apache.xpath.internal.operations.Mod;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
/**
 * @Author: 马宇航
 * @Todo: 登录请求
 * @DateTime: 22/03/30/0030 下午 3:19
 * @Component: 成都蜗牛学苑
 **/
@Controller
public class LoginContoller {
    @RequestMapping("/login")
    public ModelAndView login(String username,String password,int money){
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject("username",username);
        modelAndView.addObject("password",money);
        modelAndView.setViewName("/WEB-INF/jsp/success.jsp");
        return modelAndView;
    }
}
```

页面jsp：

```jsp
<%--
  Created by IntelliJ IDEA.
  User: ASUS
  Date: 22/03/30/0030
  Time: 上午 10:50
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<form action="/login" method="post">
    用户名： <input type="text" name="username"/><br/>
    密码：<input type="password" name="password"><br/>
    请付钱：<input type="number" name="money"><br/>
    <button type="submit">登录</button>
</form>
</body>
</html>
```

成功后返回页面：

```jsp
<%--
  Created by IntelliJ IDEA.
  User: ASUS
  Date: 22/03/30/0030
  Time: 上午 11:33
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>登录成功后页面</title>
</head>
<body>
   尊敬的 ${username} VIP用户，恭喜您登录成功，登录一次要的钱是${password}
</body>
</html>
```

> 如果前端不想改名字？怎么办？后端又不想改变量名？怎么办？
>
> 不可能打一架！
>
> 可以在属性参数前面加上ReqeustParam注解，可以设置别名，接收前端传来的不一样的属性名称！
>
> ```
> @RequestParam("pass")
> ```
>
> 这个注解，作用还有更多，请查看`集合参数处理`！

如果前端传的中文出现乱码，需要在web.xml中配置过滤器！

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
<!-- 处理前端传来的中文，发现后端接收后乱码，就需要配置这个编码过滤器！   -->
    <filter>
        <filter-name>characterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>characterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    <servlet>
        <servlet-name>dispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
<!--     我们的ApplicationContext.xml配置文件所在的位置   -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
<!--     配置文件加载时机:一启动就加载   -->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcherServlet</servlet-name>
<!--    拦截所有请求    -->
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

#### 4.3.1 数组

后端：

```java
@RequestMapping("/passArray")
public ModelAndView passArray(String username,String[] hobby){
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.addObject("username",username);
    modelAndView.addObject("msg", Arrays.toString(hobby));
    modelAndView.setViewName("/WEB-INF/jsp/show.jsp");
    return modelAndView;
}
```

前端：

```html
<hr/>
<h1>数组类型的数据格式</h1>
<form action="/passArray" method="post">
    用户名： <input type="text" name="username"/><br/>
    爱好：<input type="checkbox" name="hobby" value="Java"/>Java
         <input type="checkbox" name="hobby" value="PHP"/>PHP
         <input type="checkbox" name="hobby" value="Python"/>Python
    <button type="submit">登录</button>
</form>
```

#### 4.3.1 集合[@RequestParam](https://github.com/RequestParam)必须加

一定要在集合前面添加[@RequestParam](https://github.com/RequestParam)注解

```
@RequestParam List<String> hobby
```

后端代码：

```java
@RequestMapping("/passList")
    public ModelAndView passList(String username, @RequestParam List<String> hobby){
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject("username",username);
        modelAndView.addObject("msg", hobby);
        modelAndView.setViewName("/WEB-INF/jsp/show.jsp");
        return modelAndView;
    }
    @RequestMapping("/passMap")
    public ModelAndView passMap(@RequestParam Map<String,Object> info,@RequestParam List<String> hobby){
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject("msg", info+","+hobby);
        modelAndView.setViewName("/WEB-INF/jsp/show.jsp");
        return modelAndView;
    }
```

前端代码：

```html
<h1>List集合类型的数据格式</h1>
<form action="/passList" method="post">
    用户名： <input type="text" name="username"/><br/>
    爱好：<input type="checkbox" name="hobby" value="Java"/>Java
    <input type="checkbox" name="hobby" value="PHP"/>PHP
    <input type="checkbox" name="hobby" value="Python"/>Python
    <button type="submit">登录</button>
</form>
<hr/>
<h1>Map集合类型的数据格式</h1>
<form action="/passMap" method="post">
    用户名： <input type="text" name="username"/><br/>
    密码：<input type="password" name="pass"><br/>
    请付钱：<input type="number" name="money"><br/>
    爱好：<input type="checkbox" name="hobby" value="Java"/>Java
    <input type="checkbox" name="hobby" value="PHP"/>PHP
    <input type="checkbox" name="hobby" value="Python"/>Python
    <button type="submit">登录</button>
</form>
```

#### 4.3.1 对象

可以不用加[@RequestParam](https://github.com/RequestParam)注解

优先创建实体类对象：

```java
package com.woniuxy.entity;
import java.util.List;
/**
 * @Author: 马宇航
 * @Todo:
 * @DateTime: 22/03/30/0030 下午 4:13
 * @Component: 成都蜗牛学苑
 **/
public class UserManager {
    String username;
    String password;
    int money;
    List hobby;
    @Override
    public String toString() {
        return "UserManager{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", money=" + money +
                ", hobby=" + hobby +
                '}';
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public int getMoney() {
        return money;
    }
    public void setMoney(int money) {
        this.money = money;
    }
    public List getHobby() {
        return hobby;
    }
    public void setHobby(List hobby) {
        this.hobby = hobby;
    }
}
```

对应controller代码：

```java
@RequestMapping("/passObject")
    public ModelAndView passObject(UserManager userManager){
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject("msg", userManager);
        modelAndView.setViewName("/WEB-INF/jsp/show.jsp");
        return modelAndView;
    }
```

对应前端代码：

```html
<h1>对象类型的数据格式</h1>
<form action="/passObject" method="post">
    用户名： <input type="text" name="username"/><br/>
    密码：<input type="password" name="password"><br/>
    请付钱：<input type="number" name="money"><br/>
    爱好：<input type="checkbox" name="hobby" value="Java"/>Java
    <input type="checkbox" name="hobby" value="PHP"/>PHP
    <input type="checkbox" name="hobby" value="Python"/>Python
    <button type="submit">登录</button>
</form>
```

# day07 SpringMVC进阶

## 1、复习

![image-20220331093101159](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203310931254.png)

## 2、处理Json请求

在未来用得最多的一种方式，特别是3阶段项目。在以后工作之中，只要是前后端分离项目，我们通通都是采用这个方式来进行数据接收。

ajax，异步请求，发送的时候，application/json，类型的格式数据。

```json
{
  "name":"马宇航",
   "age":20,
    "sex":1,
    "girlfriends":[
        {"name":"rose"}，
        {"name":"tom"}
    ]
}
```

### 2.1 引入依赖

```xml
<!--  这个配置是比较常见的：json转换等操作  -->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.13.1</version>
    </dependency>
```

### 2.2 测试json的数据接收

直接使用字符串接收请求体的json数据！

```java
//String name,添加了@RequestBody注解后，才成功接收到了前端发来的请求体json数据。
public ModelAndView comeJson(@RequestBody String name,String age)
```

> 由于请求体数据json有且仅有一个，所以后端的参数中只允许最多一个[@RequestBody](https://github.com/RequestBody)注解！
>
> String name接收到的是 整个请求体的json数据。

### 2.3 json对象接收

后端使用对象接收前端的json数据！

这个DTO对象包含了其他两个对象的数据，GirlFriend对象，和RbacManager对象。

```java
package com.woniuxy.entity;
import java.util.List;
/**
 * @Author: 马宇航
 * @Todo: DTO：data transport object 数据传输对象
 * @DateTime: 22/03/31/0031 上午 11:02
 * @Component: 成都蜗牛学苑
 **/
public class RbacManagerDTO extends RbacManager{
    List<GirlFriend> girlFriends;
    @Override
    public String toString() {
        return "RbacManagerDTO{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                ", girlFriends=" + girlFriends +
                '}';
    }
    public List<GirlFriend> getGirlFriends() {
        return girlFriends;
    }
    public void setGirlFriends(List<GirlFriend> girlFriends) {
        this.girlFriends = girlFriends;
    }
}
```

前端json：

```json
{
  "name":"马宇航",
   "age":20,
   "sex":1,
   "girlFriends":[
        {"name":"rose"},
        {"name":"tom"}
    ]
}
```

> [@RequstBody](https://github.com/RequstBody) 主要用来配置在controller方法参数前面，通常我们controller方法，只有一个参数，由于Get请求是没有请求体，所以，我们前端的请求多是POST请求，然后携带JSON请求体。
>
> [@ReqeustBody](https://github.com/ReqeustBody) 这个注解，一个方法参数`只能写一个`！

缝合怪！包含很多类型的json格式数据！

```json
{
   "name":"马宇航",
   "age":20,
   "sex":1,
   "girlFriends":[
        {"name":"rose"},
        {"name":"tom"}
    ],
    "clazz":{
      "name":"86期",
      "num":38,
      "classMaster":{
        "name":"雷老师",
        "age":25,
        "sex":0,
        "boyFriends":[
          {"name":"jack"}
        ]
      }
    },
    "status":true,
    "date":"2022-03-04"
}
```

## 3、SpringMVC的执行流程(面试题)

![image-20220331141448366](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203311414477.png)

步骤：

1. 用户通过浏览器往后端发起请求，先进入前端控制器，web.xml配置了拦截，拦截的是所有的请求。
2. 拦截请求以后，根据URL请求，去找我们能够匹配这个URL的controller处理器的类和方法。
3. 成功找到以后，返回给前端控制器。
4. 前端控制器通过适配器，对携带的请求参数信息，进行消息转换。
5. 转换以后就会封装到Handler处理器的方法参数中，然后后续执行三层架构。
6. 查完数据后，返回一个数据库消息，并把它封装到ModelAndView对象中。
7. 同上
8. 解析ModelAndView中的视图配置，找到对应的jsp页面。
9. 返回页面给DispatcherServlet
10. 后端对jsp页面进行渲染，替换el表达式。转换页面成html。
11. 发送html页面到浏览器。

## 4、处理响应

### 4.1 Form表单的响应处理

目前使用的是ModelAndView这个对象！

首先配置视图解析器，然后处理响应后跳转页面。

```xml
<!--  视图解析器  -->
    <bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
<!--      视图解析器 解析方式  前缀  -->
        <property name="prefix" value="/WEB-INF/jsp/"/>
<!--      后缀  -->
        <property name="suffix" value=".jsp"/>
    </bean>
```

在代码中，只需要配置，视图名称即可！

```java
@RequestMapping("/comeJson")
public ModelAndView comeJson(@RequestBody RbacManagerDTO rbacManager){
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.addObject("msg",rbacManager);
    modelAndView.setViewName("boy/heiheihei");
    return modelAndView;
}
```

我不想要ModelAndView这个对象，不想new对象！

我直接返回字符串 String！

```java
 @RequestMapping("/comeFormReturnString")
    public String comeFormReturnString(String name){
        return "success";
    }
```

它能直接通过视图解析器找到对应的页面！但是，数据就是带不进去！

解决，return字符串的情况下，希望能够带上我后端的数据。

```java
@RequestMapping("/comeFormReturnString")
public String comeFormReturnString(Model model, ModelMap modelMap,String name){
    //方案一
    model.addAttribute("msg",name);
    //方案二  二选一即可！
    modelMap.addAttribute("msg",name);
    return "success";
}
```

> 前后端不分离可以这么玩，但是，我们现在大量的项目都是前后端分离！

### 4.2 Json格式的响应处理(重点)

> 用于处理前后端分离项目，比如app手机端，或者vue搭建的前端项目。

新注解：[@ResponseBody](https://github.com/ResponseBody) 响应一个json格式对象出去！

这个注解可以写在类上，和方法上！

如果加了这个[@ResponseBody](https://github.com/ResponseBody)注解，return一个视图，此时，将不再走视图解析器，不去找jsp页面！直接把字符串响应回前端。

通常的开发模式是：

```java
  @RequestMapping("comeJsonReturnObject")
    @ResponseBody
    public RbacManagerDTO comeJsonReturnObject(@RequestBody RbacManagerDTO rbacManager){
        //模拟数据库查询方法
        return rbacManager;
    }
```

除了String和对象以外，List，Map等集合，或者数组等，都能通过`@ResponseBody`这个注解，转换成json对象。

未来开发，我们的controller都是返回json对象了，所以，有一个语法糖，

`@RestController` 包含了：[@ResponseBody](https://github.com/ResponseBody)+[@Controller](https://github.com/Controller)

### 4.3 重定向与转发

```
重定向：
```

方法一：使用Servlet的方式来进行重定向！

```java
@RequestMapping("testRedirect")
    public String testRedirect(HttpServlcetResponse response) throws IOException {
        //方式1 使用servlet的模式来重定向
       response.sendRedirect("/rbacManager/comeFormReturnString?name=123");
        return null;
    }
```

方式二：spring的重定向方式

```java
@RequestMapping("testRedirect")
    public String testRedirect() throws IOException {
//        Spring重定向的写法  redirect:success.jsp 也可以重定向到页面
        return "redirect:/rbacManager/comeFormReturnString?name=123";
    }
```

`转发：`

方式一：

```java
@RequestMapping("testForword")
    public String testForword(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
        //方式1 使用servlet的模式来转发
//        request.getRequestDispatcher("/rbacManager/comeFormReturnString?name=333").forward(request,response);
        return null;
    }
```

方式二：

```java
 @RequestMapping("testForword")
    public String testForword() throws ServletException, IOException {
        return "forward:/rbacManager/comeFormReturnString?name=333";
    }
```

### 4.4 统一响应体封装

我们前后端，有一个约定，大家统一一下响应回来的数据格式！

```json
{
    "code"：200,
    "message":"成功访问",
    "data":{
        "name":"mayuhang",
        "age":16
    }
}
```

```java
package com.woniuxy.entity;
import org.omg.PortableInterceptor.SUCCESSFUL;
/**
 * @Author: 马宇航
 * @Todo: 统一封装的响应体对象
 * @DateTime: 22/03/31/0031 下午 3:38
 * @Component: 成都蜗牛学苑
 **/
public class ResponseEntity<T> {
    int code;
    String message;
    T data;
    public static final ResponseEntity SUCCESSFUL = new ResponseEntity(200,"执行成功",null);
    public static final ResponseEntity FAIL = new ResponseEntity(500,"执行失败",null);
    public ResponseEntity() {
    }
    public ResponseEntity(int code, String message, T data) {
        this.code = code;
        this.message = message;
        this.data = data;
    }
    public int getCode() {
        return code;
    }
    public void setCode(int code) {
        this.code = code;
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
    public T getData() {
        return data;
    }
    public void setData(T data) {
        this.data = data;
    }
}
```

未来的开发，将会统一controller的格式：

```java
 @RequestMapping("comeJsonReturnObject")
    public ResponseEntity comeJsonReturnObject(@RequestBody RbacManagerDTO rbacManager){
        //执行service方法，返回对象，封装后发给前端
        ResponseEntity<RbacManagerDTO> rbacManagerDTOResponseEntity = new ResponseEntity<>(200,"成功",rbacManager);
        return rbacManagerDTOResponseEntity;
    }
```

测试出的效果未来将如下所示：

![image-20220331154739448](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202203311547582.png)

## 5、数据校验

在早期，我们的数据校验，通常是用if和正则表达式来进行后端的校验。以及前端页面中非空、邮箱、手机号的校验。

```java
if(StringUtils.isEmpty(username)){}
else if(){
}
……
```

每个servlet都要写！代码过于冗余！

> 正常在公司，每日的有效代码量是70~100行！

### 5.1 JSR-303简介

Java6里面推出了一种规范：JSR-303，JSR是Java Specification Reqeusts的缩写，Java规范提案，又叫做Bean Validation！

JSR-303它是java为Bean提供的一种数据合法性校验的标准框架。

核心实现jar包是：Hibernate Validator是Bean Validation的参考实现。

Bean Validation中内置的注解：通常是加到实体类的属性上。

| Constraint约束注解                                     | 详细信息                                                     |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| [@Null](https://github.com/Null)                       | 被注释的元素必须为null                                       |
| [@NotNull](https://github.com/NotNull)                 | 被注释的元素必须不为null                                     |
| [@AssertTrue](https://github.com/AssertTrue)           | 被注释的元素必须为true                                       |
| [@AssertFalse](https://github.com/AssertFalse)         | 被注释的元素必须为False                                      |
| [@Min](https://github.com/Min)(value)                  | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值     |
| [@Max](https://github.com/Max)(value)                  | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值     |
| [@DecimalMin](https://github.com/DecimalMin)(value)    | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值(Bigdecimal) |
| [@DecimalMax](https://github.com/DecimalMax)(value)    | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值(Bigdecimal) |
| [@Size](https://github.com/Size)(max,min)              | 被注释的元素的大小必须在指定的范围内                         |
| [@Digits](https://github.com/Digits)(integer,fraction) | 被注释的元素必须是一个数字，其值必须在可接受的范围内         |
| [@Past](https://github.com/Past)                       | 被注释的元素必须是一个过去的日期                             |
| [@Future](https://github.com/Future)                   | 被注释的元素必须是一个将来的日期                             |
| [@Pattern](https://github.com/Pattern)(value)          | 被注释的元素必须符合指定的正则表达式                         |

Hibernate Validator 附加的注解：

| Constraint                               | 详细信息                               |
| ---------------------------------------- | -------------------------------------- |
| [@Email](https://github.com/Email)       | 被注释的元素必须是电子邮箱地址         |
| [@Length](https://github.com/Length)     | 被注释的字符串的长度必须在指定的范围内 |
| [@NotEmpty](https://github.com/NotEmpty) | 被注释的字符串必须非空                 |
| [@Range](https://github.com/Range)       | 被注释的元素必须在合适的范围内         |

### 5.2 校验开发流程

引入依赖：

```xml
<dependency>
  <groupId>org.hibernate</groupId>
  <artifactId>hibernate-validator</artifactId>
  <version>6.0.8.Final</version>
</dependency>
```

使用方式：直接在实体类上添加对应的注解

```java
package com.woniuxy.entity;
import javax.validation.Valid;
import javax.validation.constraints.Email;
import javax.validation.constraints.NotEmpty;
import java.util.List;
/**
 * @Author: 马宇航
 * @Todo: DTO：data transport object 数据传输对象
 * @DateTime: 22/03/31/0031 上午 11:02
 * @Component: 成都蜗牛学苑
 **/
public class RbacManagerDTO extends RbacManager{
    @Email(message = "email error！")
    String email;
    @NotEmpty(message = "username not null")
    String username;
    List<GirlFriend> girlFriends;
// 这里加了这个注解，就支持嵌套校验
    @Valid
    Clazz clazz;
    public String getEmail() {
        return email;
    }
    public void setEmail(String email) {
        this.email = email;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public Clazz getClazz() {
        return clazz;
    }
    public void setClazz(Clazz clazz) {
        this.clazz = clazz;
    }
    @Override
    public String toString() {
        return "RbacManagerDTO{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                ", status=" + status +
                ", date=" + date +
                ", girlFriends=" + girlFriends +
                ", clazz=" + clazz +
                '}';
    }
    public List<GirlFriend> getGirlFriends() {
        return girlFriends;
    }
    public void setGirlFriends(List<GirlFriend> girlFriends) {
        this.girlFriends = girlFriends;
    }
}
```

如果需要自定义封装校验消息返回的数据：在controller方法中定义

```java
  @RequestMapping("comeJsonReturnObject")
    @ResponseBody
    public ResponseEntity comeJsonReturnObject(@RequestBody @Valid RbacManagerDTO rbacManager, BindingResult bindingResult){
//       手动对 校验消息的封装！
        if (bindingResult.hasErrors()) {
            FieldError fieldError = bindingResult.getFieldError();
            String defaultMessage = fieldError.getDefaultMessage();
            return new ResponseEntity<>(500,defaultMessage,null);
        }else{
            ResponseEntity<RbacManagerDTO> rbacManagerDTOResponseEntity = new ResponseEntity<>(200,"成功",rbacManager);
            return rbacManagerDTOResponseEntity;
        }
    }
```

唯一需要注意的是：

在controller方法的参数前，必须添加[@Valid](https://github.com/Valid)或者Validated注解，才会开启数据的校验。

如果有嵌套校验：

需要在对应的嵌套的实体类的属性上，添加[@Valid](https://github.com/Valid)或者[@Validated](https://github.com/Validated)

```java
public class RbacManagerDTO extends RbacManager{
    @Email(message = "email error！")
    String email;
    @NotEmpty(message = "username not null")
    String username;
    List<GirlFriend> girlFriends;
// 这里加了这个注解，就支持嵌套校验 Clazz内部的@Range注解才会进行校验判断
    @Valid
    Clazz clazz;
}
```





# day08 SpringMVC最终

## 1、复习

![image-20220401093806643](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204010938738.png)

## 2、RestFul

### 2.1 REST定义

> REST全称是Representational State Transfer，中文意思是表述性（编者注：通常译为表征）状态转移。REST指的是一组`架构约束条件和原则`。如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。
>
> 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。
>
> 比如get请求，put请求，post请求，他们对应的操作是不一样的：
>
> localhost:8080/rbacManager/user —-get请求 获取数据
>
> localhost:8080/rbacManager/user —-post请求 新增数据
>
> localhost:8080/rbacManager/user —-put请求 更新数据
>
> localhost:8080/rbacManager/user —-delete请求 删除数据

### 2.2 RESTful架构

理解一个核心概念：

1. 资源与URI
2. 统一资源接口

#### 2.2.1 资源与URI

REST全称`表述`性状态转移，什么是表述？其实这个表述就是指我们的资源。浏览器通过URL请求的不同，表述出的数据结果(资源)不一样。资源：可以是一个实体，比如手机号码，也可以是一些抽象的概念，价值！

在浏览器中，我们的资源要被识别到，并具有表述性，需要在形式上，给人一种直观的关联；

https://www.woniuxy.com/studentarea

https://www.woniuxy.com/studentcourse/70

> URI和URL的关系：
>
> URI: 统一资源标志符(Uniform Resource Identifier)，表示web上每一种可以用的资源，比如Html文档、图像、视频片段、程序等。都是由URI进行标识的：
>
> URI通常由三个部分组成：
>
> 1. 资源的命名机制
>
> 2. 存放资源的主机
>
> 3. 资源自身的名称
>
>    注意：这只是一般URI资源的命名方式，只要是可以唯一标识资源的都被称为URI，上面三条合在一起是URI的充分不必要条件）
>
>    以http://www.woniuxy.com/studentarea为例：
>
>    我们可以这样解释它：
>
>    ①这是一个可以通过http协议访问的资源，
>
>    ②位于主机 www.woniuxy.com上，
>
>    ③通过“studentarea”可以对该资源进行唯一标识（注意，这个不一定是完整的路径）
>
>    注意：以上三点只不过是对实例的解释，以上三点并不是URI的必要条件，URI只是一种概念，怎样实现无所谓，只要它唯一标识一个资源就可以了。
>
> `URL`是URI的一个`子集`。它是Uniform Resource Locator的缩写，译为“统一资源定位符”。
>
> http://www.woniuxy.com/playvideo/119268
>
> 比如这里，可以通过`URL定位到具体的资源位置`。
>
> 他们的核心区别，URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。URL是一种具体的URI，它是URI的一个子集(类似URI接口的实现)，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。

#### 2.2.2 统一资源接口

RESTful架构应该遵循`统一接口原则`，统一接口包含了一组`受限的预定义的操作`，`不论什么样的资源，都是通过使用相同的接口进行资源的访问`。接口应该使用标准的HTTP方法如GET，PUT，DELETE和POST，并遵循这些方法的语义。

下面列出了GET，DELETE，PUT和POST的典型用法:

> `幂等`含义：无论请求多少次，都不会改变服务器状态。

| 请求类型 | 行为                                                         | 特性           |
| -------- | :----------------------------------------------------------- | -------------- |
| GET      | 获取, 变更时获取（缓存）                                     | 安全且幂等     |
| POST     | 使用`服务端`管理的（自动产生）的实例号创建(子)资源；部分更新资源；如果没有被修改，则不更新资源 | 不安全且不幂等 |
| PUT      | 用`客户端`管理的实例号创建一个资源，通过替换的方式更新资源，如果未被修改，则更新资源 | 不安全但幂等   |
| DELETE   | 删除资源                                                     | 不安全但幂等   |

`统一资源接口`要求使用标准的HTTP方法对资源进行操作，所以`URI只应该来表示资源的名称，而不应该包括资源的操作`。通俗来说，URI不应该使用动作来描述。例如，下面是一些`不符合`统一接口要求的URI:

GET /getUser/1

POST /createUser

PUT /updateUser/1

DELETE /deleteUser/1

应改为：

GET /User/1 获取某个资源

POST /User 后端create创建资源

PUT /User/1 后端update更新资源

DELETE /User/1 后端delete删除资源

对应后端的接口写法：

新的注解：

```java
package com.woniuxy.controller;
import com.woniuxy.entity.RbacManager;
import org.springframework.web.bind.annotation.*;
/**
 * @Author: 马宇航
 * @Todo: 使用RestFul风格的开发模式
 * @DateTime: 22/04/01/0001 上午 11:00
 * @Component: 成都蜗牛学苑
 **/
@RestController
@RequestMapping("/rbacManager")
public class RbacManagerController {
    @GetMapping("/User")
    public String findAll(){
        return "findAll";
    }
    @PostMapping("/User")
    public String addOne(@RequestBody RbacManager rbacManager){
        return "post请求："+rbacManager.toString();
    }
    @PutMapping("/User/{currentPage}/{pageSize}")
    public String updateOne(@RequestBody RbacManager rbacManager,@PathVariable int currentPage,@PathVariable("pageSize") int size){
        return "put请求："+rbacManager.toString();
    }
    //url：... /User/2/uname/马宇航
    @DeleteMapping("/User/{id}/uname/{username}")
    public String deleteOne(@PathVariable int id,@PathVariable String username){
        return "删除了这个"+id+"的用户"+username;
    }
}
```

## 3、静态资源处理

RestFul风格，希望URL用优雅的风格，来请求服务的资源。不希望访问的url资源中有.html或者.do的这种请求。由于web.xml中配置了DispatcherServlet，它拦截所有的 / 的请求，它也会拦截其他的比如静态资源获取的请求。

### 3.1 非WEB-INF下的静态资源

方式一：直接在web.xml最前面添加这个servlet映射！让这种后缀的请求，走tomcat自带的servlet，不要经过DispatcherServlet！

```xml
<!-- 这个意思就是，让.png的URL请求后缀，不走DispatcherServlet，走tomcat的默认的servlet
   这个配置只能解决 静态资源在非WEB-INF下的情况
  -->
   <servlet-mapping>
<servlet-name>default</servlet-name>
<url-pattern>*.css</url-pattern>
</servlet-mapping>
<servlet-mapping>
<servlet-name>default</servlet-name>
<url-pattern>*.gif</url-pattern>
</servlet-mapping>
<servlet-mapping>
<servlet-name>default</servlet-name>
<url-pattern>*.mp4</url-pattern>
</servlet-mapping>
<servlet-mapping>
<servlet-name>default</servlet-name>
<url-pattern>*.png</url-pattern>
</servlet-mapping>
<servlet-mapping>
<servlet-name>default</servlet-name>
<url-pattern>*.jpg</url-pattern>
</servlet-mapping>
<servlet-mapping>
<servlet-name>default</servlet-name>
<url-pattern>*.js</url-pattern>
</servlet-mapping>
<servlet-mapping>
<servlet-name>default</servlet-name>
<url-pattern>*.html</url-pattern>
</servlet-mapping>
```

servlet-name标签配置的是default，default是tomcat的默认servlet。

要配置多个，每种文件配置一个。要写在DispatcherServlet的前面， 让defaultServlet先拦截。
不同的Web应用服务器默认Servlet的名字有所不同，如下说明(了解即可)：

> Tomcat, Jetty, JBoss, and GlassFish 默认 Servlet的名字 – “default”
>
> Google App Engine 默认 Servlet的名字 – “_ah_default”
>
> Resin 默认 Servlet的名字 – “resin-file”
>
> WebLogic 默认 Servlet的名字 – “FileServlet”
>
> WebSphere 默认 Servlet的名字 – “SimpleFileServlet”

方案二：它可以去掉方案一的配置！

```
<!--  配置 <mvc:default-servlet-handler/> 处理静态资源的时候，必须配置注解驱动，否则controller请求都无法访问 -->
    <mvc:annotation-driven/>
<!--  方式二 处理静态资源  default-servlet-name="default" 可以省略，前提你是tomcat-->
    <mvc:default-servlet-handler default-servlet-name="default"/>
```

### 3.2 WEB-INF下的静态资源

在applicationContext.xml配置文件中添加！

```xml
<!--  mapping 它是在使用的时候，我们手动输入的前缀，url可以指定这个名称 
    location  它是目标静态资源所在的文件夹！
 -->
    <mvc:resources mapping="/jspp/**" location="/WEB-INF/jsp/"></mvc:resources>
<!--  WEB-INF下的图片资源！   -->
    <mvc:resources mapping="/png/**" location="/WEB-INF/"/>
```

> jsp不是静态资源！

## 4、拦截器

### 4.1 拦截器和过滤器的区别

过滤器(filter)

1. Filter它是属于Servlet，只要是web的项目都可以使用
2. 过滤器主要是对所有的请求(静态资源请求)进行拦截过滤
3. Filter过滤器的执行时机会早于拦截器

拦截器(Interceptor)

1. `SpringMVC的技术`，必须要有SpringMVC的环境才允许使用
2. 拦截器，`主要是对controller(handler)的请求进行拦截`
3. 拦截器只拦截DispatcherServlet所处理过的请求

### 4.2 拦截器的作用

1）日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。

2）权限检查：如登录检测，进入处理器检测是否登录，如果没有直接返回到登录页面；

3）性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）；

4）通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，`只要是多个Controller中的处理方法都需要的，我们就可以使用拦截器实现`。

5）OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。

拦截器本质也是AOP（面向切面编程），也就是说符合`横切关注点的所有功能`都可以放入拦截器实现。

### 4.3 代码实现(面试，和考试)

![image-20220401142936833](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204011429977.png)

我们的Interceptor的代码，需要实现HandlerInterceptor接口：

```java
package com.woniuxy.interceptors;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * @Author: 马宇航
 * @Todo: 第一个拦截器
 * @DateTime: 22/04/01/0001 下午 2:15
 * @Component: 成都蜗牛学苑
 **/
public class MyFirstInterceptor implements HandlerInterceptor {
    /**
     * 这里是拦截器 进入后执行的第一个方法
     * ChangeLog : 1. 创建 (22/04/01/0001 下午 2:20 [马宇航]);
     * @param request
     * @param response
     * @param handler
     * @return boolean
    */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("MyFirstInterceptor.preHandle:success！");
        return true;
    }
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("MyFirstInterceptor.postHandle:controller over！");
    }
    @Override
    public void afterCompletion(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("MyFirstInterceptor.afterCompletion: jsp page after execution is complete");
    }
}
```

配置文件：

```xml
<!--  拦截器是属于SpringMVC的技术  -->
    <mvc:interceptors>
        <mvc:interceptor>
<!--        对应拦截URL    -->
            <mvc:mapping path="/rbacManager/**"/>
            <bean class="com.woniuxy.interceptors.MyFirstInterceptor"/>
        </mvc:interceptor>
        <mvc:interceptor>
            <!--        对应拦截URL    -->
            <mvc:mapping path="/rbacManager/**"/>
            <bean class="com.woniuxy.interceptors.MyFirstInterceptor2"/>
        </mvc:interceptor>
    </mvc:interceptors>
```

## 5、返回JSON带中文显示？号的情况

配置文件中的注解驱动，这个是简写模式，它会默认DefaultAnnotationHandlerMapping，与AnnotationMethodHandlerAdapter两个bean，我们spring请求，消息转换必备的内容。

返回[@ResponseBody](https://github.com/ResponseBody)来进行json返回，默认用的是MappingJacksonHttpMessageConverter，对象返回的时候，并没有发现有乱码 ？号的情况。

但是使用String类型的消息返回，[@ResponseBody](https://github.com/ResponseBody)后，前端发现乱码

![image-20220401151358920](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204011513967.png)

原因是底层使用的是StringHttpMessageConverter，底层编码格式ISO_8859_1的编码，所有我们乱码！

![image-20220401151508346](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204011515422.png)

配置文件，重新对StringHttpMessageConverter进行编码属性设置：

```xml
 <mvc:annotation-driven>
        <mvc:message-converters>
            <bean class="org.springframework.http.converter.StringHttpMessageConverter">
                <property name="defaultCharset" value="UTF-8"/>
            </bean>
        </mvc:message-converters>
    </mvc:annotation-driven>
```

![image-20220401151741645](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204011517684.png)

## 6、文件上传

> 不推荐大家记住代码，未来的开发，更多的是使用云服务的一个存储，阿里OSS服务，或者七牛云的服务，他们都有免费使用的大小。在3阶段项目中，文件的存储上传，请使用以上的方式来进行文件附件，视频图片等的存储操作。

文件上传，传到本地的服务器(tomcat中)

步骤：

1.引入依赖

```xml
  <dependency>
        <groupId>commons-fileupload</groupId>
        <artifactId>commons-fileupload</artifactId>
        <version>1.4</version>
    </dependency>
```

2.配置文件

```xml
<!-- 文件上传的配置-->
    <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
        <property name="defaultEncoding" value="UTF-8"/>
        <property name="maxUploadSize" value="2380000"/>
    </bean>
```

3.代码

```java
package com.woniuxy.controller;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
/**
 * @Author: 马宇航
 * @Todo: 处理文件的上传
 * @DateTime: 22/04/01/0001 下午 3:25
 * @Component: 成都蜗牛学苑
 **/
@Controller
public class FileController {
    @RequestMapping("/upload")
    public String upload(HttpServletRequest request, HttpServletResponse response,
            MultipartFile multipartFile) throws IOException {
        //推荐使用七牛云
        //判断文件是否为空
        if (!multipartFile.isEmpty()) {
            //获取上传文件存储路径
            String realPath = request.getSession().getServletContext().getRealPath("/imagic/");
            //上传文件名
            String originalFilename = multipartFile.getOriginalFilename();
            File file = new File(realPath, originalFilename);
            if (!file.getParentFile().exists()){
                //可以创建一个文件夹
                file.getParentFile().mkdirs();
            }
            //用流把文件存储到服务器中
            multipartFile.transferTo(new File(realPath+File.separator+originalFilename));
            return "success";
        }else {
            return "文件不能为空";
        }
    }
}
```

> 使用方案二创建web项目：会出现依赖包未实时同步到项目打包成war后的文件中，每次引入新的依赖，都要来手动put into output root！
>
> ![image-20220401160400073](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204011604207.png)

## 7、SSM整合

### 7.1 引入SSM依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.woniuxy</groupId>
  <artifactId>day08SSM</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>
  <name>day08SSM Maven Webapp</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
<!-- mybatis的配置   -->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>3.5.9</version>
    </dependency>
<!--  mybatis厂家给Spring开发的依赖 中间件  -->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis-spring</artifactId>
      <version>2.0.7</version>
    </dependency>
<!--  mysql数据库的链接驱动  -->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.28</version>
    </dependency>
<!--  druid连接池  -->
    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.2.8</version>
    </dependency>
<!--  sl4j日志   -->
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>1.7.30</version>
    </dependency>
<!--  Spring-jdbc(包含了tx) 和Spring-tx事务包   -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>5.3.16</version>
    </dependency>
<!--  spring-webmvc   -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.3.16</version>
    </dependency>
<!--  jackson  -->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.13.1</version>
    </dependency>
  </dependencies>
  <build>
    <finalName>day08SSM</finalName>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.1.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.22.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-war-plugin</artifactId>
          <version>3.2.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>

```

### 7.2 配置web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
  <!-- 这个意思就是，让.png的URL请求后缀，不走DispatcherServlet，走tomcat的默认的servlet
     这个配置只能解决 静态资源在非WEB-INF下的情况
     方式一
    -->
  <!--    <servlet-mapping>-->
  <!--        <servlet-name>default</servlet-name>-->
  <!--        <url-pattern>*.png</url-pattern>-->
  <!--    </servlet-mapping>-->
  <!--    <servlet-mapping>-->
  <!--        <servlet-name>default</servlet-name>-->
  <!--        <url-pattern>*.html</url-pattern>-->
  <!--    </servlet-mapping>-->
  <!--    <servlet-mapping>-->
  <!--        <servlet-name>default</servlet-name>-->
  <!--        <url-pattern>*.js</url-pattern>-->
  <!--    </servlet-mapping>-->
  <!--    <servlet-mapping>-->
  <!--        <servlet-name>default</servlet-name>-->
  <!--        <url-pattern>*.css</url-pattern>-->
  <!--    </servlet-mapping>-->
  <filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
      <param-name>encoding</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
      <param-name>forceResponseEncoding</param-name>
      <param-value>true</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
  <servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:applicationContext.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>
```

### 7.3 配置applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">
<!-- mybatis的配置 -->
<!--  1.读取db配置文件  -->
    <context:property-placeholder location="classpath:db.properties"/>
<!--  2.配置druid数据源  -->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
<!--  3.SqlSessionFactoryBean  -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="mapperLocations" value="classpath:mapper/*.xml"/>
        <property name="typeAliasesPackage" value="com.woniuxy.entity"/>
    </bean>
<!--  4.sqlSessionTemplate  -->
    <bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate">
        <constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"/>
    </bean>
<!--  5.MapperScannerConfigurer  -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="com.woniuxy.dao"/>
<!--     这个配置是可以省略   -->
        <property name="sqlSessionTemplateBeanName" value="sqlSessionTemplate"/>
    </bean>
<!--  mybatis整合结束  -->
<!--  springmvc的配置  -->
    <context:component-scan base-package="com.woniuxy"/>
<!--  注解驱动  -->
    <mvc:annotation-driven/>
</beans>
```

### 7.4 开发controller

```java
package com.woniuxy.controller;
import com.woniuxy.entity.RbacManager;
import com.woniuxy.entity.ResponseEntity;
import com.woniuxy.service.RbacManagerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
/**
 * @Author: 马宇航
 * @Todo: RbacManager的controller接口(非interface)
 * @DateTime: 22/04/01/0001 下午 4:34
 * @Component: 成都蜗牛学苑
 **/
@RestController
@RequestMapping("/rbacManager")
public class RbacManagerController {
    @Autowired
    RbacManagerService rbacManagerService;
    @PostMapping("/manager")
    public ResponseEntity addOne(@RequestBody RbacManager rbacManager){
        return rbacManagerService.addOne(rbacManager);
    }
    @DeleteMapping("/manager/{id}")
    public ResponseEntity deleteOne(@PathVariable int id){
        return rbacManagerService.deleteOne(id);
    }
    @PutMapping("/manager")
    public ResponseEntity updateOne(@RequestBody RbacManager rbacManager){
        return rbacManagerService.updateOne(rbacManager);
    }
    @GetMapping("/manager/{id}")
    public ResponseEntity findOne(@PathVariable int id){
        return rbacManagerService.findOne(id);
    }
    @GetMapping("/manager")
    public ResponseEntity findAll(){
        return rbacManagerService.findAll();
    }
}
```

### 7.5 开发service

```java
package com.woniuxy.service.impl;
import com.woniuxy.dao.RbacManagerDao;
import com.woniuxy.entity.RbacManager;
import com.woniuxy.entity.ResponseEntity;
import com.woniuxy.service.RbacManagerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
/**
 * @Author: 马宇航
 * @Todo: TODO
 * @DateTime: 22/04/01/0001 下午 4:39
 * @Component: 成都蜗牛学苑
 **/
@Service
public class RbacManagerServiceImpl implements RbacManagerService {
    @Autowired
    RbacManagerDao rbacManagerDao;
    @Override
    public ResponseEntity addOne(RbacManager rbacManager) {
        int i = rbacManagerDao.addOne(rbacManager);
        if (i>0){
           return ResponseEntity.SUCCESSFUL;
        }else {
            return ResponseEntity.FAIL;
        }
    }
    @Override
    public ResponseEntity deleteOne(int id) {
        int i = rbacManagerDao.deleteOne(id);
        if (i>0){
            return ResponseEntity.SUCCESSFUL;
        }else {
            return ResponseEntity.FAIL;
        }
    }
    @Override
    public ResponseEntity updateOne(RbacManager rbacManager) {
        int i = rbacManagerDao.updateOne(rbacManager);
        if (i>0){
            return ResponseEntity.SUCCESSFUL;
        }else {
            return ResponseEntity.FAIL;
        }
    }
    @Override
    public ResponseEntity findOne(int id) {
        RbacManager rbacManager = rbacManagerDao.findOne(id);
        return new ResponseEntity<RbacManager>(200,"查询成功",rbacManager);
    }
    @Override
    public ResponseEntity findAll() {
        return new ResponseEntity<>(200,"查询成功",rbacManagerDao.findAll());
    }
}
```

### 7.6 开发dao

```java
package com.woniuxy.dao;
import com.woniuxy.entity.RbacManager;
import com.woniuxy.entity.ResponseEntity;
import java.util.List;
/**
 * @Author: 马宇航
 * @Description: TODO
 * @DateTime: 22/04/01/0001 下午 4:39
 * @Component: 成都蜗牛学苑
 **/
public interface RbacManagerDao {
    int addOne(RbacManager rbacManager);
    int deleteOne(int id);
    int updateOne(RbacManager rbacManager);
    RbacManager findOne(int id);
    List<RbacManager> findAll();
}
```

### 7.7 开发mapper.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.woniuxy.dao.RbacManagerDao">
    <select id="findAll" resultType="rbacManager">
        select * from rbac_manager
    </select>
    <delete id="deleteOne">
        delete from rbac_manager where id=#{id}
    </delete>
    <update id="updateOne">
        update rbac_manager set account=#{account},password=#{password},status=#{status} where id = #{id}
    </update>
    <select id="findOne" resultType="com.woniuxy.entity.RbacManager" >
        select * from rbac_manager where id = #{id}
    </select>
    <insert id="addOne">
        insert into rbac_manager (account,password,status) values (#{account},#{password},#{status})
    </insert>
</mapper>
```

### 7.8 开发统一响应对象

```java
package com.woniuxy.entity;
/**
 * @Author: 马宇航
 * @Todo: 统一封装的响应体对象
 * @DateTime: 22/03/31/0031 下午 3:38
 * @Component: 成都蜗牛学苑
 **/
public class ResponseEntity<T> {
    int code;
    String message;
    T data;
    public static final ResponseEntity SUCCESSFUL = new ResponseEntity(200,"执行成功",null);
    public static final ResponseEntity FAIL = new ResponseEntity(500,"执行失败",null);
    public ResponseEntity() {
    }
    public ResponseEntity(int code, String message, T data) {
        this.code = code;
        this.message = message;
        this.data = data;
    }
    public int getCode() {
        return code;
    }
    public void setCode(int code) {
        this.code = code;
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
    public T getData() {
        return data;
    }
    public void setData(T data) {
        this.data = data;
    }
}
```

# day09 Springboot

## 一、SpringBoot快速起步

### 1.SpringBoot简述

Spring Boot是Spring开源组织下的子项目，是Spring组件`一站式解决`方案，其设计目的是用来简化Spring应用项目的搭建以及开发过程，简化繁琐的配置，提供了各种启动器，开发者能快速上手。

该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置

- SpringBoot就是spring以及springmvc的衍生，是“**懒人工具包**”
- SpringBoot只是一个配置工具,整合工具,辅助工具.
- SpringBoot 最大化的实现了convention over configuration(**约定大于配置**)

这个框架的底层，依旧是：`前面课程中说讲的内容`。

> 启动器（名词记忆，重点词语）

启动器：就是SpringBoot将很多的框架进行独立的封装，并在封装的Jar中完成了对应的依赖关系，以及各种配置

Eg:

- spring-boot-starter-web:支持全栈web开发，里面包括了Tomcat和Spring- webmvc。
- spring-boot-starter-mail:提供对javax.mail的支持。
- spring-boot-starter-ws: 提供对Spring Web Services的支持。
- spring-boot-starter-test:提供对常用测试框架的支持，包括JUnit，Hamcrest 以及Mockito等。
- spring-boot-starter-actuator:支持产品环境下的一些功能，比如指标度量及监控等。
- spring-boot-starter-jetty:支持jetty容器。
- spring-boot-starter-log4j:引入默认的log框架（logback）

更多启动器，工作中使用后慢慢了解！

### 2.SpringBoot的优点

1. 遵循”约定优于配置”原则,使用Spirng Boot只需很少的配置,大部分时候可以
2. 使用默认配置;
3. 项目快速搭建,另外还可以无配置整合第三方框架- springscrerity;
4. 简化Maven及Gradle配置;
5. 内嵌入Servlet如Tomcat、jetty容器,应用可用jar包运行(java -jar);
6. 可完全不使用xml配置,只使用自动配置和Java Config;
7. 有多种强大的开发包，支持热启动

### 3.SpringBoot与SpringMVC的区别

`Spring MVC`提供了一种轻度耦合的方式来开发web应用。它是Spring的一个模块，是一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。解决的问题领域是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。

`Spring Boot`实现了`自动配置`，降低了项目搭建的复杂度。它主要是为了解决使用Spring框架需要进行大量的配置太麻烦的问题，所以它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，Spring Boot应用中这些第三方库几乎可以零配置的`开箱即用`(out-of-the-box)。

## 二、Springboot搭建

创建springboot项目方式一：`网页创建！`

![image-20220406102951852](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204061029045.png)

直接使用idea的springboot初始化创建即可:

![image-20220406103124464](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204061031527.png)

点击 next选择对应需要的依赖：

首先先选一个spring-web即可，它内部包含了spring-webmvc和jackson转换等依赖。

### 2.1 启动类的位置

推荐启动类在最外层，作为顶级的文件。才能自动扫描我们添加的类注解。

```java
package com.woniuxy;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
@SpringBootApplication
//因为我们没有遵守约定：我们启动类必须是在最外层，它才会自动扫描(启动类的同级或者子级的包)包
//和之前配置的xml：context:componet-scan 一个效果
//@ComponentScan("com.woniuxy.controller")
public class Day09springboot01Application {
    public static void main(String[] args) {
        SpringApplication.run(Day09springboot01Application.class, args);
    }
}
```

### 2.2 文件夹介绍

![image-20220406111240560](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204061112664.png)

src/main/java：写java源码的包路径

src/main/resources：写配置文件的地方

src/main/resources/static：放静态资源的地方比如：logo图片，js，css等文件的地方

src/main/resources/templates：类似之前SSM项目中的WEB-INF，里面通常是`放html页面`，同时必须通过controller才能够直接访问。springboot官方推荐，不要用jsp!

src/test: 直接可以基于Spring的环境(IOC的环境)来进行测试。代码如下：

```java
package com.woniuxy.day09springboot01;
import com.woniuxy.controller.MyController;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
@SpringBootTest
class Day09springboot01ApplicationTests {
    @Autowired
    MyController myControl;
    @Test
    void contextLoads() {
        String test = myControl.test();
        System.out.println(test);
    }
    @Test
    void test2(){
    }
}
```

target：编译后的class文件。

### 2.3 pom.xml文件

可以通过文件中的parant标签找到对应的父依赖：

![image-20220406112350290](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204061123457.png)

dependencyManagement：这个标签表示，帮你管理了这些依赖的对应名称和对应版本，但是你子项目pom中，如果不用，那么整个项目中就没有这些依赖，如果你要用，可以直接输入groupId和artifactId即可，不需要自己去指定对应的version版本号了。

管理的意义在于：统一依赖的版本，尽量减少因为版本的不同而出现的依赖冲突等问题。

## 三、SpringBoot的配置文件

### 1. 配置文件的类型

#### 1.1 有两种配置文件类型

Springboot的项目中，配置文件的类型是properties，但是为了好看，我们通常不使用这个格式！

原因，properties配置文件key前缀很多会出现重复，导致不方便人类阅读。

![image-20220406145024919](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204061450090.png)

> 所以，我们通常在springboot或者springcloud项目中，使用yaml配置文件！
>
> YML文件格式，YAML(YAML Aint Markup Language)编写的文件格式。这个格式肯定能被我们电脑识别的数据序列化格式，而且也是便于人类阅读，很容易通过代码或者脚本来进行文件读取解析，它不仅仅只是支持java，其他语言C、C++、PHP、Python等也支持，这个文件比传统的xml和properties文件，更加简洁！
>
> 文件写法：application.yml 或者 application.yaml
>
> yml类型的配置文件，属性和属性值之间(冒号后面)必须有空格，中间使用`:`进行连接。

![image-20220406150050325](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204061500457.png)

和python语法类似，没有分号，直接靠缩进来进行编写。

#### 1.2 常见的配置

```yaml
#server.port=8081
#server.address=
#server.servlet.context-path=
#spring.datasource.url=
#spring.datasource.driver-class-name=
#spring.datasource.username=
#spring.datasource.password=
server:
  port: 8081
  servlet:
    context-path: /api #配置 servlet的上下文配置，请求路径中间就需要添加/api url:localhost:8081/api/hello
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/woniu_k15
    username: root
    password: 123456
  # springMVC的基于form表单配置的日期类型转换
  mvc:
    format:
      date:
        # 也可选配置成数组形式 多参数
        - yyyy-MM-dd
        - yyyy-MM-dd HH:mm:ss
  # Spring传json对象，携带日期类型的情况
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: Asia/Shanghai
```

#### 1.3 加载配置文件中的数据

> 核心：
>
> 1. [@ConfigurationProperties](https://github.com/ConfigurationProperties)
> 2. [@EnableConfigurationProperties](https://github.com/EnableConfigurationProperties) 同上
> 3. [@Value](https://github.com/Value)

[@ConfigurationProperties](https://github.com/ConfigurationProperties)，自动映射配置文件，找到对应的配置并获取值，然后封装到当前对象中。

它必须把目标类注册到spring容器中，才能生效，所以可以使用两种方案。

1. 直接使用spring的注解：[@Componet](https://github.com/Componet)或者[@Configuration](https://github.com/Configuration)
2. 可以使用它的扫描[@ConfigurationPropertiesScan](https://github.com/ConfigurationPropertiesScan) 添加到启动类上即可(或者任意能够被spring扫描的类)

[@Value](https://github.com/Value) 用得多点，它比较灵活！

对应的自定义的配置文件mayuhang.properties

```
# 从配置文件中获取到自定义的配置，或者获取常规的配置
datasourceMy.url=jdbc:mysql://localhost:3306/woniu_k15
datasourceMy.username=root
datasourceMy.password=123
```

对应获取配置文件的对象：

```java
package com.woniuxy.entity;
import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;
/**
 * @Author: 马宇航
 * @Todo: 使用实体类来获取他们的配置文件中的信息
 * @DateTime: 22/04/07/0007 下午 3:09
 * @Component: 成都蜗牛学苑
 **/
@Data
@PropertySource("classpath:mayuhang.yml")
@Component
public class MyDataSourceEntity {
    @Value("${datasource-my.url}")
    String url;
    @Value("${datasource-my.username}")
    String username;
    @Value("${datasource-my.password}")
    String password;
}
```

使用[@PropertySource](https://github.com/PropertySource)注解，只能解析properties的格式的key=value形式的配置，无法解析yml格式的配置。

#### 1.4 多环境配置(了解)

在企业开发，我们不同的情况下对应的配置是不一样的：

- 开发环境 dev
- 测试环境 test
- 上线环境 prod

##### 1、配置在同一个文件中

```yaml
spring:
  profiles:
    # 激活的目标环境
    active: dev
---
# 开发环境
server:
  port: 8081
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/woniu_k15
    username: root
    password: 123456
    #对应的环境名称
  profiles: dev
---
# 测试环境
server:
  port: 8082
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/woniu_k15
    username: root
    password: 123456
  profiles: test
---
# 线上环境
server:
  port: 8083
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/woniu_k15
    username: root
    password: 123456
  profiles: prod
```

##### 2、多配置文件的形式

![image-20220407160203803](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204071602907.png)

然后使用maven的插件，package进行打包，打包成jar包：

然后去win文件夹中使用cmd，输入对应的命令即可启动项目：

```
java -jar xxxx.jar --spring.profiles.active=test
```

通常项目开发完成，部署到线上后，我们都会使用的启动方式(前提是jdk安装好了)；

linux 中的命令同上，java -jar的命令 是jdk中的。

#### 1.5 配置文件的位置(了解)

配置文件放的位置不一样的话，优先级不同：优先级由高到低！

> 目前项目中的配置文件，是优先级最低的：
>
> 项目根目录下：/config 文件夹中的配置文件是优先级最高的！
>
> 项目根目录下：第二优先级
>
> classpath: /config 文件夹，第三优先级
>
> classpath： 最低优先级(springboot默认的配置文件放的地方)

如果有多个配置文件，那么相同配置，优先级最高的生效，不同配置，将会累加进去！

#### 1.6 Java Config配置(极为重要)

> 未来的开发，我们通常手动配置，就是使用Java Config的方式。用它来替代Xml配置。
>
> Springboot2.0版本以后，推荐使用的方式！

常用注解：

[@Configuration](https://github.com/Configuration) 这个注解，表示当前类是`配置类`，然后会被spring扫描并注入到spring容器中。

[@Bean](https://github.com/Bean) 这个注解，通常加在方法上，表示该方法是一个Bean的配置！

开发：

```java
package com.woniuxy.config;
import com.woniuxy.utils.String2DateConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.format.FormatterRegistry;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
/**
 * @Author: 马宇航
 * @Todo: 配置类
 * @DateTime: 22/04/07/0007 下午 4:13
 * @Component: 成都蜗牛学苑
 **/
@Configuration
public class MyConverter implements WebMvcConfigurer {
    //<bean id=“string2DateConverter 方法名” class=“com.woniuxy.utils.String2DateConverter”/>
    //注册成bean 还不够，之前我们还需要把这个bean对象注入到springmvc流程中
    @Bean
    public String2DateConverter string2DateConverter(){
        return new String2DateConverter();
    }
    //注册到SpringMVC环境中
    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverter(string2DateConverter());
    }
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        //设置欢迎页面 thymeleaf 底层设置了视图解析器的前缀/templates和后缀.html
        registry.addViewController("/").setViewName("index");
        //设置生效的优先级
        registry.setOrder(Ordered.HIGHEST_PRECEDENCE);
    }
}
```

> WebMvcConfigurer 这个对象非常关键的：
>
> 这个接口，是Spring的内部配置方式，通常MVC相关的配置，使用JavaConfig模式配置的话，底层的一些Handler配置，Interceptor配置，ViewResolver，MessageConverter。对应的配置类，都需要实现WebMvcConfigurer 接口。
>
> 以此配置，来替代SSM中的xml配置。

下节课：

详细使用Java Config来注册任意bean对象，以及依赖注入其他对象！

> 定义一个类：My86Clazz属性有，clazzName 班级名称，List属性 ，Teacher对象属性
>
> 定义student类和Teacher类。把他们注入到My86Clazz中。
>
> 使用，JavaConfig的形式来注入。也不使用Autowire注解注入。

![image-20220407170855016](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204071708130.png)

```java
package com.woniuxy.config;
import com.woniuxy.entity.My86Clazz;
import com.woniuxy.entity.Student;
import com.woniuxy.entity.Teacher;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import java.util.ArrayList;
import java.util.List;
/**
 * @Author: 马宇航
 * @Todo: 模拟xml的形式使用javaconfig模式配置bean对象的注入关系
 * @DateTime: 22/04/07/0007 下午 4:53
 * @Component: 成都蜗牛学苑
 **/
@Configuration
public class MockXmlConfigurationBeans {
    /**
     * @Bean注解的使用，类似之前的xml中的配置
     * <bean id="teacher" class="">
     *     <constructor-arg name="name" value="马宇航"></constructor-arg>
     * </bean>
    **/
    @Bean
    public Teacher teacher(){
        // <constructor-arg name="name" value="马宇航"></constructor-arg>
        return new Teacher("马宇航");
    }
    @Bean
    public Teacher teacher1(){
        // <constructor-arg name="name" value="马宇航"></constructor-arg>
        return new Teacher("雷老师");
    }
    /**
     * @Bean注解的使用，类似之前的xml中的配置,多了一个形参？形参是哪里来的？
     * <bean id="my86Clazz" class="My86Clazz">
     *     形参名称 对应的是 ref后面的名称
     *      <property name="teacher" ref="teacher1"></property>
     * </bean>
     **/
    //@Bean 对应方法的形参，spring底层，会去找到对应的bean对象，来帮你注入进去
    // 默认用的是@Resource
    // 根据byName优先注入，如果没有名称，则使用的是byType
    @Bean
    public My86Clazz my86Clazz(Teacher teacher,List<Student> productionStudents){
        My86Clazz my86Clazz = new My86Clazz();
        my86Clazz.setName("86期");
        my86Clazz.setTeacher(teacher);
        my86Clazz.setSudents(productionStudents);
        return my86Clazz;
    }
    /**
     * <util:list id="productionStudents">
     *       <bean class="Student">
     *          <constructor-arg name="name" value="苏寅洪"></constructor-arg>
     *       </bean>
     *       <bean class="Student">
     *          <constructor-arg name="name" value="邓云溪"></constructor-arg>
     *       </bean>
     *       <bean class="Student">
     *           <constructor-arg name="name" value="许泊宁"></constructor-arg>
     *       </bean>
     * </util:list>
    **/
    @Bean
    public List<Student> productionStudents(){
        List<Student> list = new ArrayList<>();
        list.add(new Student("苏寅洪"));
        list.add(new Student("邓云溪"));
        list.add(new Student("许泊宁"));
        return list;
    }
}
```

## 四、SpringBoot+Mybaits整合

### 1. 创建springboot项目引入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.6.6</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.woniuxy</groupId>
    <artifactId>day09springbootMybatis</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>day09springbootMybatis</name>
    <description>day09springbootMybatis</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.2.2</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### 2. 配置yml文件

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/woniu_k15
    username: root
    password: 123456
#mybaits的配置
#mybatis mapper.xml的配置
mybatis:
  #配置mybatis-config.xml配置  但是通常用不上
#  config-location: classpath:mybatis-config.xml
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.woniuxy.entity
```

### 3. 就能直接开始写代码了

> dao的扫描：
>
> 不在使用xml配置：MapperScannerConfigurar
>
> 直接在启动类上使用：
>
> [@MapperScan](https://github.com/MapperScan)(“com.woniuxy.dao”)
>
> 或者：在dao上面配置[@Mapper](https://github.com/Mapper)
>
> 上述方法二选一即可！

省略三层架构和mapper.xml

# day10 Vue-ES6

## 一、ES6语法

### 1. 基础语法

ECMAScript6 (简称ES6) 是JavaScript的下一代语言标准。它是在2015年发布，所以ECMAScript2015(ES2015)。

目的：并非是让你玩得6，仅仅只是为了你能看得懂。

> `let`，`const`，`class`，extends，super，arrow functions，template，String，destructuring，default，rest arguments。
>
> 这些都是常见的ES6语法。

#### 1.1 let

let和const它们两个的用户和var类似，都是用来声明变量的。它们和var的区别是非常大的。

> let 声明的变量只在let命令所在的代码块内有效。类似java的变量。
>
> const 声明一个只读的常量，一旦声明，常量的值就不能改变。final。

示例：

```html
<script>
        var name ='m马宇航'
        while(true){
            var name = '雷老师'
            console.log(name);//雷老师
            break
        }
        console.log(name);//雷老师
    </script>
```

使用var，两次输出都是雷老师，因为ES5的时候，只有全局作用域和函数作用域，并没有块级作用域，这种场景比较不合理。`内层变量覆盖了外层变量`。let是JavaScript中新增的块级作用域的变量声明，用法就参考java！

```js
<script>
        let name ='马宇航'
        while(true){
            let name = '雷老师'
            console.log(name);//雷老师
            break
        }
        console.log(name);//马宇航
    </script>
```

第二个场景，for循环计数，出现变量泄露为全局变量。

```js
 <script>
       var a = []
       for(var i = 0;i<10;i++){
           a[i] = function(){
               console.log(i)
           };
       }
       a[1]();//就是获取数组下标6的值，这个是一个方法调用。 
       a[9]();//结果都是10
    </script>
```

对应示例图，希望的效果应该是如下所示，但是实际上结果都是10！

![image-20220408094956726](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204080949875.png)

原因是var来声明的i变量。这个i作用范围是全局范围。每次循环的时候，i的新值，就会覆盖掉之前的旧值，导致最终输出的所有i都是最后一轮++后的值。使用let就可以无这个情况！

```js
<script>
       var a = []
       for(let i = 0;i<10;i++){
           a[i] = function(){
               console.log(i)
           };
       }
       a[1]();//就是获取数组下标6的值，这个是一个方法调用。 1 
       a[9]();//9
    </script>
```

let声明的i，是块级作用域，只在代码块内生效。let就当java的变量来使用即可！

第三种情况：`变量提升问题`

let不存在变量提升，var会变量提升：

```js
<script>
       console.log(b) //undefined
       var b = "ksjdfl";
       console.log(a)//Cannot access 'a' before initialization
       let a = "laksjdf";
    </script>
```

变量b使用的是var，当我们js脚本开始启动的时候，b变量就已经存在了，但是还没有赋值，所以，会输出undefined；

变量a使用的是let，不存在变量提升的问题，必须声明之后才能够使用，否则直接报错！

#### 1.2 const

和let差不多，但是它声明的变量声明后是不允许改变的。所以，我们const，声明的变量，必须初始化赋值，否则会报错！

基本用法简单，直接略过。

`暂时性死区`：

![image-20220408102228553](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204081022626.png)

ES6明确规定，代码块内如果存在let或者const，那么代码块会对这些命令声明的变量，从块的一开始就形成一个封闭的作用域。即使代码块外面声明了这个变量，如果代码块内，重新使用let或者const来声明，就会如上图报错。

```js
<script>
      var PI = "3.14159265358"
      if(true){ 
          //代码块内部，暂时性不能使用PI
          console.log(PI);
          const PI = "123"
          //这里以后就可以使用PI 打印出123
      }
      console.log(PI)//3.14159265358
    </script>
```

额外拓展：前置知识java中的数据绑定对象地址的特性。

const如何确保变量在声明初始化之后不允许发生改变的呢？const其实保证的是该变量指向的`内存地址所保存的数据不允许改变`。

简单数据类型(java基本数据类型)等同于常量，没有太大区别。

复杂的数据类型，对象类型，数组类型，函数function类型，变量指向的内存地址其实保存的不一定是数据，很多时候保存的其实是指向另外一个数据的指针地址，所以，const保证的是指针是固定的，但是指针指向的下一个地址的数据会不会发生改变，那么就无法控制。

结论，在复杂情况使用const，需要慎重！

#### 1.3 for-of

遍历数据

```js
<script>
      var arr=['冯位移','邓雨茜','廖封雨']
      for(var item of arr){
          console.log(item)
      }
    </script>
```

会遍历出每一项！

遍历数组中的对象



```js
//遍历数组中的对象
      var students=[
        {name:'方敏',age:18},
        {name:'方海鹏',age:28},
        {name:'冯成龙',age:38}
      ]
      for(let item of students){
          console.log("打印对象：",item) //对象拼接 字符串的时候，不要使用+来拼接
      }
```

> ES6的语法：for-of无法遍历对象！

#### 1.4 for-in

和for-of的区别①：for-of不能`遍历对象`，当for-in可以！

```js
 var one ={name:"李斌",age:22,sex:"男"}
      for(let item in one){
          console.log(item,one[item])//输出key和对象one的对应key的value值！
      }
        //输出结果如下：
      //name 李斌
      //age 22
      //sex 男
```

区别②：for-of和for-in都去遍历数组，for-in遍历出的是`数组的索引index`

```js
 //遍历数组中的对象
      var students=[
        {name:'方敏',age:18},
        {name:'方海鹏',age:28},
        {name:'冯成龙',age:38}
      ]
      for(let item of students){
          console.log("打印forof对象：",item) //对象拼接 字符串的时候，不要使用+来拼接
      }
      for(let item in students){
        console.log("打印forin对象：",item) //对象拼接 字符串的时候，不要使用+来拼接
    }
```

![image-20220408105351686](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204081053784.png)

区别③: 数组的`自定义属性`，`for-in会遍历`，for-of不会！

```js
//遍历数组中的对象
      var students=[
        {name:'方敏',age:18},
        {name:'方海鹏',age:28},
        {name:'冯成龙',age:38}
      ]
      //自定义属性key为name，value是86期班的学生们
      students.name="86期班的学生们"
      for(let item of students){
          console.log("打印forof对象：",item) //对象拼接 字符串的时候，不要使用+来拼接
      }
      for(let item in students){
        console.log("打印forin对象：",item,students[item]) //对象拼接 字符串的时候，不要使用+来拼接
    }
```

![image-20220408105709619](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204081057735.png)

### 2. 箭头函数

更加简洁的函数书写方式。基本的语法是：

> 参数 => 函数体

java的语法是：

> 参数 -> 函数体
>
> 示例：
>
> ```
> new Thread(()->{}).start;
> ```

基本用法：

```js
var func = v => v;
//等价于
var func = function(v){
    return v;
}
//调用该方法：
func(2)；//返回一个2
```

如果有多个参数或者没有参数，必须用括号()括起来！

```js
var func = (a,b) => a+b;//省略了{} 结果自己返回！
func(1,2);//3
```

如果函数体有多行，那么久必须加`{}` 大括号包起来，如果代码块只有一行语句，并且需要返回结果时，可以省略`{}`，结果会自动返回。

```js
var func = (a,b) => {
  let sum =a+b;
  return sum;
}
func(1,2);//3
```

当箭头函数要返回对象的时候，为了区分代码块，要用`()`将对象包裹起来。

> 因为前端的对象，本来就是{name:’na’,age:15}
>
> v =>{name:’na’,age:15}//这个写法是错误的！

```js
  <script>
      //箭头函数，如果返回的是一个对象，那么为了区别{}代码块，我们必须把对象用括号包起来。前置条件是就一行。
      var func = (a,b) =>({name:a,age:b});
      var obj = func('123',12);
      console.log(obj)
    </script>
```

### 3. 解构

#### 3.1 概述

解构用于`赋值`，是对赋值运算符的一种扩展。

```
镜像对称赋值！
```

> 解构模型：
>
> 解构的目标=解构的源

#### 3.2 数组模型的解构

基本

```js
let [a,b,c] = [1,2,3]
// a = 1
// b = 2
// c = 3
```

可嵌套

```js
let [a,[b,[c,d]]] = [1,[2,[3,4]]]
//结果就不说了
```

可忽略

```js
let [a,,b] = [1,2,3]
// a = 1 
// b = 3
```

不完全解构

```js
let [a = 1,b] = []
// a = 1
// b = undefined
```

剩余运算符

```js
let [a,...b] = [1,2,3,4]
// a = 1
// b = [2,3,4]
```

字符串

```js
let [a,b,c,d,e] = `yuema`;
//结果不用细表 中文也行 每个变量表示一个中文
// a = 'y'
// b = 'u'
// ...
```

解构默认值

```js
let [a = 1] = [undefined]
// a = 1
```

当解构模式没有匹配结果，且匹配结果是undefined时，会触发默认值作为返回结果。

```js
let [a = 3,b = a] = [];
// a = 3 , b = 3
let [a = 3, b = a] =[1];
// a = 1 ,b = 1
let [a = 3, b = a] = [1,2];
// a = 1, b = 2
```

#### 3.3 对象模型的解构

基本

```js
let {name,age} = {name:'mayuhang',age:'19'};
// name = mayuhang ,age = 19
let {age} = {name:'mayuhang',age:'19'};
 // age = 19
let {name:myname,age:myage} = {name:'mayuhang',age:'19'};
// myname = mayuhang  ,myage = 19
//实际使用，可以在import引入的时候直接使用
import {name,age} form ../city.js
```

可嵌套，可忽略

```js
let obj = {p:['yuema',{y:'buyue'}]};
let {p:[x,{y}]} = obj;
// x = yuema   , y = buyue
let {p:[x,{}]} = obj;
// x = yuema
```

不完全解构

```js
let obj = {p:['yuema',{y:'buyue'}]};
let {p:[,{y},x]} = obj;
// x = undefined , y = buyue
```

剩余运算符

```js
let {a,b,...last} = {a:10,b:20,c:30,d:40};
// a = 10, b = 20 ,last= {c:30,d:40}
```

解构默认值

```js
let {a = 10,b = 5} ={a:3};
// a= 3 ,b = 5
let {a:aa=10,b:bb=5} = {a:3}
//aa = 3  ,bb= 5
```

> 解构默认值，如果有变的源中，有值，则左边默认值不生效，最终值为右边源的值。

## 二、Vue基础概念

### 1. Vue基本介绍

Vue课程是基于Vue2.x版本，各位同学都是全栈(全干)工程师，Vue一定要会，有了vue的基础，那么其他的前端框架上手就会更加的简单，最差也能看懂前端的页面代码，能够依葫芦画瓢地开发前端的页面。

> Vue ：读音类似View，法语！这个是一套用于构建用户界面的`渐进式框架`！

### 2. 渐进式

渐进式：`主张最少`。只需要引入vue.js就可以直接开发，也可以片段替换之前二阶段的项目页面！

> 渐进式：可以逐步蚕食，一点点替换。

比如说：*Angular*。它两个版本都是强主张的，如果你用它，必须接受以下东西：

- 必须使用它的模块机制
- 必须使用它的依赖注入
- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）

所以 *Angular* 是带有比较强的`排它性`的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。

再比如：*React*。它也有一定程度的主张，它的主张主要是`函数式编程`的理念。比如说：你需要知道什么是副作用、什么是纯函数、如何隔离副作用等。它的侵入性看似没有 *Angular* 那么强，主要因为它是软性侵入。

而 *Vue*，没有什么强主张，我们可以在原有大系统的上面，把一两个组件改用 *Vue* 实现，把它当 *jQuery* 用；也可以整个用 *Vue* 全家桶来进行项目开发，把它当 *Angular* 用；还可以用它的视图，搭配我们自己设计的整个下层应用。也可以在底层数据逻辑的地方用 *OO*P 和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已。

通俗的来讲，*Vue* 就是一个已经搭建好的空屋。与单纯使用 *jQuery* 这种库比，*Vue* 可以更好地实现代码复用，减少工作量；与*Angular* 这种家具电器一应俱全的框架相比，又不需要一件件挑选，再把自己不喜欢的一件件扔了。

简而言之，***Vue\* 只做自己该做的事，不会做职责以外的事。**

### 3. MVVM

*Vue* 采用了 *MVVM* 的设计模式。*MVVM*，即 *Model - View - ViewModel*，它是`数据驱动模式`，即所有的一切通过操作数据来进行，而`尽量避免操作DOM树`。document.getElementById(“input”)。

![img](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210123172415.png)

- *Model* ：模型层，主要负责业务数据相关；
- *View*：视图层，顾名思义，负责视图相关，细分下来就是 *html + css* 层；
- *ViewModel*：*View* 与 *Model* 沟通的桥梁，负责监听 *View* 或者 *Model* 的修改，是实现 *MVVM* 双向绑定的要点；

### 4. MVVM与MVC的关系：

![image-20210123172608074](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210123172608.png)

*MVVM* 支持双向绑定，意思就是当 *Model* 层数据进行修改时，*ViewModel* 层会监测到其变化，然后通知 *View* 层进行相应的修改；反之修改 *View* 层则会通知 *Model* 层数据进行修改，以此也实现了视图与模型层的相互解耦。

![image-20210123172513561](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210123172513.png)

换句话说，我们不关注 *DOM* 的结构，而是考虑数据该如何储存，用户的操作在 *View* 中通过 *ViewModel* 进行数据处理，分情况是否与 *Model* 层进行交互，再返回到 *View* 层，在这个过程中 *View* 和 *ViewModel* 的数据双向绑定使得我们完全的摆脱了对 *DOM* 的繁琐操作，而是专心于对用户的操作进行处理，避免了 *MVC* 中 *controller* 层过厚的问题。

## 三、Vue的安装

### 1. 安装使用

#### vscode

nodeJS: http://nodejs.cn/download/
vsstudio: https://code.visualstudio.com/
在文件夹中 cmd code . 则直接打开当前工程。
安装 auto rename tag插件。
安装code runner插件。
安装open in brower插件。
安装live server插件。
vetur 写vue必备插件
Vue 2 Snippets 写vue必备插件
axios插件
VueHelper vscode插件，vue，vue-router和vuex的代码提示
Path Intellisense 路径自动补全
Auto Close Tag 自动闭合标签
Beautify 格式化文件,保证正确的缩进
HTML CSS Support CSS提示插件
JavaScript (ES6) code snippets es6代码提示插件
VSCode Great Icons 给文件夹增加图标的插件

#### Vue

要学习使用 *Vue*，首先需要在项目中去安装引入 *Vue*。官方提供了下列几种 *Vue* 的安装方式：

- `<script>` 直接引入
- *NPM*
- 命令行工具 (*CLI*)

对于初学者来说，我们还是建议从第一种最简单的安装方式来学习 *Vue*。

1. `<script>` 引入

在 *HTML* 文档中通过 `<script>` 标签引入 *Vue* 的依赖文件 *Vue.js* ，是最简单快速的安装方式。官网提供了两个版本的依赖文件：

- 开发版本：包含完整的警告和调试模式；
- 生产版本：删除了警告，*33.30KB min+gzip*；

我们可以选择将 *Vue.js* 文件下载到本地后直接在项目中引入。

```
<!-- 开发环境版本，包含了有帮助的命令行警告 --><script src="./js/vue.js"></script>
```

或者：

```
<!-- 生产环境版本，优化了尺寸和速度 --><script src="./js/vue.min.js"></script>
```

下载地址：[开发版地址 - *vue.js*](https://vuejs.org/js/vue.js)、[生产版地址 - *vue.min.js*](https://vuejs.org/js/vue.min.js)

当然，懒得下载的话我们也可以在项目中直接通过 *CDN* 引入。

```
<!-- 开发环境版本，包含了有帮助的命令行警告 --><script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
```

或者：

```
<!-- 生产环境版本，优化了尺寸和速度 --><script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
```

### 2. NPM(入门后学)

在用 *Vue* 构建大型应用时推荐使用 NPM 安装。NPM 能很好地和诸如 [webpack](https://webpack.js.org/) 或 [Browserify](http://browserify.org/) 模块打包器配合使用。同时 *Vue* 也提供配套工具来开发[单文件组件](https://cn.vuejs.org/v2/guide/single-file-components.html)。

```
# 最新稳定版$ npm install vue
```

### 3. 命令行工具 CLI(入门后学)

*Vue* 提供了一个[官方的 *CLI*](https://github.com/vuejs/vue-cli)，为单页面应用 (*SPA*) 快速搭建繁杂的脚手架。它为现代前端工作流提供了 *batteries-included* 的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 *lint* 校验，以及生产环境可用的构建版本。

> *CLI* 工具要求用户对 *Node.js* 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下熟悉 *Vue* 本身之后再使用 *CLI*。

## 四、Vue的使用

### 1. Vue的实例(重要)

每个Vue的页面开发，都是必须要实例化Vue对象后，才能够进行的！

#### 1.1 创建Vue实例

创建一个html页面后，引入vue.js文件，Vue被注册为一个全局的变量，它是一个构造函数。可以直接new Vue();

```js
const vm = new Vue({
})；//有参数的，参数是一个对象！就是有参构造方法！
```

这个参数对象，里面的选项列表很多：[*API* 文档](https://cn.vuejs.org/v2/api/#选项-数据)

在控制台，输入vm即可打印下图：

![image-20220408142629770](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204081426051.png)

#### 1.2 选项/数据 model

`data`属性：它就是MVVM 中的 model！用于存放数据！

当我们Vue的实例被创建后，data属性中的所有内容，都会被加载到Vue的响应式系统中。

data属性可以使用的类型：

1. 对象类型

```js
const vm = new Vue({
            //这个就是data使用属性的写法
            data:{
                name:"雷老师",
                action:"没唱歌"
            }
        });
```

函数类型(重点)

```js
const vm = new Vue({
            //data属性使用函数定义
            data() {
                return {
                    name: "雷老师",
                    action: "没唱歌"
                }
            }
        });
```

> 后面学习Vue组件，我们的data类型只能是函数写法，所以，建议同学们直接使用函数的写法来声明data属性。

#### 1.3 选项/DOM

`el`属性：绑定DOM坐标，定位到浏览器中的某个DOM标签上，让我们Vue的内容，在那个标签里面进行渲染！

它用的是CSS选择器的值。

```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 开发环境版本，包含了有帮助的命令行警告 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
</head>
<body>
    <div id="app">
        {{name}}<!-- 该标签会被vue渲染，直接使用data中的name值 -->
    </div>
    {{name}}<!-- 该标签不会被vue渲染直接会显示出来 -->
    <script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                   name:"雷老师唱征服！"
               }
           },
        });
    </script>
</body>
</html>
```

![image-20220408143855786](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204081438869.png)

> 注意：我们挂载(div id=app)的元素会被Vue生成的DOM节点给替换(使用模板属性的时候)，所以我们挂载el的时候，不要挂到`<html>`和`<body>`，不要写成这样`<html id="app">`！

### 2. 模板语法

Vue.js使用的是基于HTML的模板语法，允许开发者声明式地将DOM绑定至底层的Vue实例数据上。所有的Vue.js模板最后都会渲染成合法的HTML标签，能够被浏览器正常解析。

Vue的底层实现上，Vue将模板编译成`虚拟DOM`渲染函数。结合响应系统，Vue能够动态计算出最少需要重新渲染多少组件(标签)，并把DOM操作次数减少到最少。

#### 2.1 插值表达式

`文本`：{{num + 2}} 既然是表达式那么就可以使用运算或者函数方法

数据绑定最常见的形式使用“Mustache”语法(双大括号)的文本插值：

```html
<div id="app">
        {{name}}<!-- 该标签会被vue渲染，直接使用data中的name值 -->
        <h1>{{name}}在{{year}}-{{mouth}}-{{day}}这一天</h1>
        <h2>{{name}}</h2>
        {{name}}
        {{name}}
        {{name}}
    </div>
    {{name}}<!-- 该标签不会被vue渲染直接会显示出来 -->
    <script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                   name:"雷老师唱征服！",
                   year:"2022",
                   mouth:"04",
                   day:"09"
               }
           },
        });
    </script>
```

特殊类型对象类型：

```html
<h2>{{name}}她有没有男朋友？{{boyfrind.name}};她有什么要求？岁数在{{boyfrind.age}}</h2>
 <script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                   name:"雷老师",
                   boyfrind:{
                       name:"还没",
                       age:"0~18岁"
                   }
               }
           },
        });
    </script>
```

#### 2.2 v-text

它和插值表达式是一样的!区别是这个是使用在标签上，作为标签的属性来使用！

```
<h3 v-text="name">{{name}}她有没有男朋友？{{boyfrind.name}};</h3>
```

> 使用v-text属性来进行普通文本的渲染，它会覆盖掉该标签原有的标签内部的值。
>
> {{name}}她有没有男朋友？{{boyfrind.name}};都会被覆盖掉。
>
> v-text=”name” 这个name是什么？data属性中的key值！(model中的数据！)
>
> ```
> 数据驱动视图！
> ```

#### 2.3 v-html

我们的插值表达式会将数据解释成普通文本，而不是HTML代码。如果想要通过data中的值，动态渲染HTML代码，那么就必须使用v-html指令。(类似innerHTML())。

```html
<div id="app">
       <h2>{{woniuxy}}</h2>
        <h2 v-html="woniuxy"></h2>
    </div>
    <script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                  woniuxy:'<a href="http://www.woniuxy.com">欢迎来到蜗牛学苑！</a> '
               }
           },
        });
    </script>
```

展示效果：

![image-20220408152557357](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204081525527.png)

> 拓展知识：
>
> 如果想要渲染到页面的html元素是多个，多行的情况，用什么符号？加号拼接？
>
> 可以使用多行文本符号：`` ESC下面的符号~ 这个符号下面的

```vue
			data() {
               return {
                  woniuxy:
                  `
                  <h1>点下面进行报名：</h1>
                  <a href="http://www.woniuxy.com">欢迎来到蜗牛学苑！</a>
                  <div>
                    <table></table>
                    </div>
                  `
               }
           },
```

## 五、Vue的指令(极度重要)

v-xxx，指令！

> 指令，带有`v-`前缀特殊特征。是vue特有的！
>
> 指令的职责，当表达式的值发生改变的时候，将其产生的连带影响，响应式地作用于DOM。

v-text,v-html都是对应的指令！

### 1. v-show

根据表达式的true或者false来控制页面dom是否显示，v-show使用的是CSS的属性display来进行渲染的，控制dom节点的显示与否。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 开发环境版本，包含了有帮助的命令行警告 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
</head>
<body>
    <div id="app">
       <h2>火车票购买</h2>
        <h2 v-show="flag1">上铺：399，<a href="#">点击购买</a></h2>
        <h2 v-show="flag2">中铺：299，<a href="#">点击购买</a></h2>
        <h2 v-show="flag3">下铺：199，<a href="#">点击购买</a></h2>
    </div>
    <script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                  flag1:false,
                  flag2:true,
                  flag3:true,
               }
           },
        });
    </script>
</body>
</html>
```

### 2. v-if

v-if指令，根据条件，来决定是否渲染某一个dom节点，如果是false，则整个dom节点都消失！

从性能的角度来说，和v-show谁的要好一点？v-show性能要好一点！

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 开发环境版本，包含了有帮助的命令行警告 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
</head>
<body>
    <div id="app">
       <h2>火车票购买</h2>
        <h2 v-if="flag1">上铺：399，<a href="#">点击购买</a></h2>
        <h2 v-if="flag2">中铺：299，<a href="#">点击购买</a></h2>
        <h2 v-if="flag3">下铺：199，<a href="#">点击购买</a></h2>
    </div>
    <script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                  flag1:false,
                  flag2:true,
                  flag3:true,
               }
           },
        });
    </script>
</body>
</html>
```

> 既然v-show和v-if，在浏览器中，看起来都一样，那么什么时候用v-show，什么时候用v-if？
>
> 1. 频繁隐藏或显示的某些标签 ！v-show比较好，会节省性能。
> 2. 权限菜单，某些菜单你没有权限查看！v-if！



`v-else`和`v-else-if`

```html
<div id="app">
       <h2>火车票购买</h2>
        <h2 v-if="type === 'A'">上铺：399，<a href="#">点击购买</a></h2>
        <h2 v-else-if="type === 'B'">中铺：299，<a href="#">点击购买</a></h2>
        <h2 v-else-if="type === 'C'">下铺：199，<a href="#">点击购买</a></h2>
        <h2 v-else="type">地铺：99<a href="#">点击购买</a></h2>
    </div>
<script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                  flag1:true,
                  flag2:true,
                  flag3:true,
                  type:"D"
               }
           },
        });
    </script>
```

### 3. v-bind(用的第二多)

#### 3.1 绑定标签属性

当我们希望`动态`地去绑定一些HTML属性时，可以通过v-bind指令来 响应式更新该DOM节点。

```html
<div id="app">
      请输入歌名：<input v-bind:type="inputtype"/>
    </div>
    <script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                //   用这个数据,来决定上面的输入框是什么类型的!是文本还是密码还是数字等
                   inputtype:"date"
               }
           },
        });
    </script>
```

> v-bind用得比较多，该指令可以使用缩写形式，缩写成`:`。v-bind:href 缩写成 :href

#### 3.2 绑定class属性

操作dom节点中的class属性，让它变成动态改变，已达到样式地动态切换，这个是一个常见的需求。

class是所有的html标签都有的属性，一旦使用v-bind绑定后，我们就可以根据表达式来切换class属性的值。

```
原始写法
```

使用普通的class绑定，不使用vue。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 开发环境版本，包含了有帮助的命令行警告 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <style>
        .setColor{
            color: rgb(167, 106, 106);
        }
        .setFontSize{
            font-size: 50px;
        }
        .setBorder{
            border: 1px solid seagreen;
        }
    </style>
</head>
<body>
    <div id="app">
      <!-- 请输入歌名：<input :type="inputtype"/>
      测试动态网站：<a :href="url">点我</a> -->
      <div class="setBorder">传统class属性的样式</div>
    </div>
    <script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
               }
           },
        });
    </script>
</body>
</html>
```

Vue绑定该class属性：使用`对象形式`绑定

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 开发环境版本，包含了有帮助的命令行警告 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <style>
        .setColor{
            color: rgb(167, 106, 106);
        }
        .setFontSize{
            font-size: 50px;
        }
        .setBorder{
            border: 1px solid seagreen;
        }
    </style>
</head>
<body>
    <div id="app">
      <!-- 请输入歌名：<input :type="inputtype"/>
      测试动态网站：<a :href="url">点我</a> -->
      <div :class="{setBorder:isSetBorder,setColor:isSetColor,setFontSize:isSetFontSize}">传统class属性的样式</div>
    </div>
    <script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                //   这个数据用来确定class属性中的值 是否存在
                isSetBorder:true,
                isSetColor:true,
                isSetFontSize:true
               }
           },
        });
    </script>
</body>
</html>
```

Vue绑定class属性：使用`数组语法`绑定

使用数组来绑定class属性，传入不同的class样式列表。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 开发环境版本，包含了有帮助的命令行警告 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <style>
        .setColor{
            color: rgb(167, 106, 106);
        }
        .setColorRed{
            color: red;
        }
        .setFontSize{
            font-size: 50px;
        }
        .setBorder{
            border: 1px solid seagreen;
        }
    </style>
</head>
<body>
    <div id="app">
      <!-- 请输入歌名：<input :type="inputtype"/>
      测试动态网站：<a :href="url">点我</a> -->
      <!-- 对象形式动态绑定class -->
      <div :class="{setBorder:isSetBorder,setColor:isSetColor,setFontSize:isSetFontSize}">传统class属性的样式</div>
      <!-- 属性形式动态绑定class -->
      <div :class="[activeColor,activeBorder,activeFontSize]">传统class属性的样式</div>
    </div>
    <script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                //   用这个数据,来决定上面的输入框是什么类型的!是文本还是密码还是数字等
                isSetBorder:true,
                isSetColor:true,
                isSetFontSize:true,
                activeColor:'setColorRed',
                activeBorder:'setBorder',
                activeFontSize:'setFontSize'
               }
           },
        });
    </script>
</body>
</html>
```

#### 3.3 绑定内联样式

标签中的style属性，直接使用vue绑定，看着就像是CSS写法，但是`实际上是JS来控制的样式`。

这个是`对象的写法`

```html
 <!-- 内联style样式修改,对象写法 -->
 <div :style="{color:activeColor,fontSize:size+'px'}">内联style样式修改</div>
<script>
new Vue({
    data(){
        return {
              activeColor:"blue",
              size:55
            }
        }
    });
    </script>
```

数组写法

```html
<!-- 内联style样式修改,s数组写法 -->
        <div :style="[mycolor,mysize]">内联style样式修改</div>
<script>
new Vue({
    data(){
        return {
              mycolor:{color:'red',border:'1px solid seagreen'},
              mysize:{fontSize:'80px'}
            }
        }
    });
</script>
```

### 4. v-on(用的第三多)

监听(绑定)事件用的

Vue使用v-on指令，来绑定DOM的事件，并触发运行事件方法。

> 事件有哪些？
>
> 1. onclick点击事件
> 2. onblur鼠标移入移出
> 3. onkeyup键盘事件
> 4. oninput输入事件
> 5. onchange改变事件

入门demo：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 开发环境版本，包含了有帮助的命令行警告 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
</head>
<body>
    <div id="app">
        <button v-on:click="num += 1">加1</button>
        {{num}}
    </div>
    <script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                    num:1
               }
           },
        });
    </script>
</body>
</html>
```

这里的click事件，是任意的标签都有的！v-on:click=”表达式”它类似之前的html中的onclick属性！

> 由于v-on有的地方多，所有它也有缩写，缩写是@ 。v-on:click 就可以简写为[@click](https://github.com/click)

但是上面的写法，会有点点不方便，如果我的函数方法触发的内容比较多，写在标签中的方法会很不方便。所以，我们的事件触发的方法，通常都要提出去，提到Vue的属性中去定义。

> 这个Vue的属性就叫做 `methods`！

使用购物车，来模拟方法的触发：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 开发环境版本，包含了有帮助的命令行警告 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <style>
        table tr td {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>书城购物车</h1>
        <table style="border: 1px solid black;">
            <tr>
                <td>
                    {{goods[0].name}}
                </td>
                <td>单价 {{goods[0].price}}</td>
                <td><button @click="subtraction(0)">-</button> {{goods[0].num}}
                    <button v-on:click="add(0)">+</button>
                </td>
            </tr>
            <tr>
                <td>
                    {{goods[1].name}}
                </td>
                <td>单价 {{goods[1].price}}</td>
                <td><button @click="subtraction(1)">-</button> {{goods[1].num}}
                    <button v-on:click="add(1)">+</button>
                </td>
            </tr>
            <tr>
                <td>
                    {{goods[2].name}}
                </td>
                <td>单价 {{goods[2].price}}</td>
                <td><button @click="subtraction(2)">-</button> {{goods[2].num}}
                    <button v-on:click="add(2)">+</button>
                </td>
            </tr>
        </table>
        <br>
        总和：{{sum}}
    </div>
    <script>
        new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
            el: "#app",
            data() {
                return {
                    goods: [
                        {   
                            name:'java最牛逼',
                            price: 99,
                            num: 0
                        },
                        {
                            name:'php是世界上最好的语言',
                            price: 19,
                            num: 0
                        },
                        {
                            name:'python谁也打不过',
                            price: 39,
                            num: 0
                        }
                    ],
                    sum: 0
                }
            },
            methods: {
                subtraction(index) {
                    if (this.goods[index].num < 1) {
                        alert("数量不能小于0")
                        return
                    }
                    this.goods[index].num -= 1
                    this.sum -= this.goods[index].price
                },
                add(index) {
                    this.goods[index].num += 1
                    this.sum += this.goods[index].price
                }
            },
        });
    </script>
</body>
</html>
```

### 5. v-for

Vue中就可以使用v-for指令来基于一个数组渲染一个列表。

> 语法：item in items items 就是源数组，item是遍历后的数组的别名

`v-for遍历数组`

```html
<table style="border: 1px solid black;">
            <tr v-for="item in goods">
                <td>{{item.name}}</td>
                <td>{{item.price}}</td>
                <td><button @click="subtraction(0)">-</button> {{item.num}}
                    <button v-on:click="add(0)">+</button>
                </td>
            </tr>
</table>
<script>
        new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
            el: "#app",
            data() {
                return {
                    goods: [
                        {   
                            name:'java最牛逼',
                            price: 99,
                            num: 0
                        },
                        {
                            name:'php是世界上最好的语言',
                            price: 19,
                            num: 0
                        },
                        {
                            name:'python谁也打不过',
                            price: 39,
                            num: 0
                        }
                    ],
                    sum: 0
                }
            },
            methods: {
                subtraction(index) {
                    if (this.goods[index].num < 1) {
                        alert("数量不能小于0")
                        return
                    }
                    this.goods[index].num -= 1
                    this.sum -= this.goods[index].price
                },
                add(index) {
                    this.goods[index].num += 1
                    this.sum += this.goods[index].price
                }
            },
        });
    </script>
```

v-for除了item，还支持`第二个参数 index！`索引！

```html
<table style="border: 1px solid black;">
            <tr v-for="(item,index) in goods">
                <td>{{index}}</td>
                <td>{{item.name}}</td>
                <td>{{item.price}}</td>
                <td><button @click="subtraction(index)">-</button> {{item.num}}
                    <button v-on:click="add(index)">+</button>
                </td>
            </tr>
        </table>
```

可以使用of来替代in作为分隔符，平时开发用的最多的一定是in！
of和 in分隔符的区别。在数组的使用上，没什么区别，但是换成对象，也没什么区别！

`v-for中用于遍历对象`：

v-for遍历对象第一个参数是：value值

v-for遍历对象第二个参数是：key值

v-for遍历对象第三个参数是：index

```html
<ul>
      <li v-for="(value,key,index) of address">
            {{index}} ----   {{key}} ---- {{value}}
      </li>
</ul>
```

> 注意事项：
>
> 建议在使用v-for的时候，要提供key，来对每行数据做一个唯一标识。
>
> ```html
> <ul>
>      <li v-for="(value,key,index) of address" :key="key">
>          {{index}} ----   {{key}} ---- {{value}}
>      </li>
> </ul>
> ```
>
> 

维护状态(key)：了解

当Vue正在更新使用v-for渲染列表元素的时候，它默认使用的是“就地更新”的策略。

如果数据项的顺序被改变，Vue将不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素，并确保他们在每个索引位置正确渲染。

所以，为了给Vue一个提示，以便它能跟踪每个阶段的身份，从而重用和重新排序现有的元素，结论，我们需要为每一个项提供唯一表示 `key`属性。

> 不要使用`对象`或者`数组`类型来做为key的值。需要用字符串或者数值类型的值。



### 6. v-model(用的第一多)

它是语法糖，作用：`双向绑定`！

> 需求：我在注册的时候，填的数据，需要把它同步到model中。

![image-20220409113245880](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204091132068.png)

这种情况，我们在开发中用得非常多，比如，编辑某个页面的时候。

以上的这个逻辑，就是双向绑定手动实现的逻辑。

> 问题：
>
> 1. 代码量比较多！
> 2. 页面中很多这种输入框，如果都用这个方法来绑定，那么开发量就比较大。

#### 6.1 v-model处理双向绑定问题

```html
使用v-model绑定用户名：<input type="text" v-model="rbacManager.username">
<script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                //    这个data中的值，最终会通过ajax，发送到后台，所以，我们页面中值改变，这里必须变！
                    rbacManager:{
                        username:"default",
                        password:"123456"
                    }
               }
           }
        });
    </script>
```

直接使用v-model就能够成功双向绑定想要的数据。

> Vue中提供的v-model可以绑定什么标签呢？
>
> 表单：`<input>`、`<textarea>`、`select`等元素上。
>
> v-model被称之为语法糖：v-bind和v-on的一种简写。
>
> v-model它会忽略所有表单元素中的value、checked、selected属性的初始值，而将data中的数据作为数据的来源。

#### 6.2 绑定文本

略

#### 6.3 绑定多行文本

```html
<h1>绑定多行文本</h1>
       <textarea v-model="textarea" cols="30" rows="10"></textarea>
       {{textarea}}
<script>
     data() {
               return {
                //    这个data中的值，最终会通过ajax，发送到后台，所以，我们页面中值改变，这里必须变！
                    textarea:`
                        我是一个多行文本，我骄傲；
                        我有很多东西，我志豪。
                    `
               }
           },
</script>
```

#### 6.4 绑定复选框

```html
<h1>绑定复选框</h1>
       爱好：
       <input type="checkbox" v-model="checked">
       <label for="checkbox">男{{checked}}</label>
       <input type="checkbox" v-model="checked1">
       <label for="checkbox">女{{checked1}}</label>
<script>
     data() {
               return {
                //    这个data中的值，最终会通过ajax，发送到后台，所以，我们页面中值改变，这里必须变！
                    checked:false,
                    checked1:false,
               }
           },
</script>
```

实际应用：

```html
<h1>绑定复选框</h1>
       爱好：
       <ul>
           <li v-for="item in hobbies">
               <!-- value前面加冒号，表示动态绑定，后面的值是一个表达式 -->
            <input type="checkbox" :value="item"  id="item.id" v-model="rbacManager.hobby">
            <label for="item.id">{{item.name}}</label>
           </li>
       </ul>
       {{rbacManager}}
<script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                //    这个data中的值，最终会通过ajax，发送到后台，所以，我们页面中值改变，这里必须变！
                    rbacManager:{
                        username:"root",
                        password:"123456",
                        hobby:[]
                    },
                    hobbies:[
                        {id:0,name:"篮球"},
                        {id:1,name:"足球"},
                        {id:2,name:"乒乓球"},
                        {id:3,name:"台球"},
                        {id:4,name:"保龄球"},
                    ]
               }
           },
        });
    </script>
```

#### 6.5 绑定单选按钮

```html
<h1>绑定单选按钮</h1>
       <ul>
           <li v-for="item in sex">
                <input type="radio" :value="item" v-model="rbacManager.sex">{{item.name}}
           </li>
       </ul>
       传入后端的json数据：{{rbacManager}}
<script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                //    这个data中的值，最终会通过ajax，发送到后台，所以，我们页面中值改变，这里必须变！
                    rbacManager:{
                        username:"root",
                        password:"123456",
                        sex:0,
                    },
                    //动态性别获取
                    sex:[
                        {id:0,name:"女"},
                        {id:1,name:"男"},
                        {id:2,name:"其他"},
                    ]
               }
           }
        });
    </script>
```

#### 6.6 绑定下拉列表

```html
<h1>绑定下拉列表</h1>
       <select v-model="rbacManager.mingzu">
            <option disabled value="">请选择</option>
            <option v-for="item in allmingzu" :value="item">
                {{item.name}}
            </option>
       </select>
<script>
        const vm = new Vue({
            //绑定到上面view页面中的dom节点，该节点内部就可以使用vue的组件
           el:"#app", 
           data() {
               return {
                //    这个data中的值，最终会通过ajax，发送到后台，所以，我们页面中值改变，这里必须变！
                    rbacManager:{
                        username:"root",
                        password:"123456",
                        mingzu:""
                    },
                    allmingzu:[
                        {id:1,name:"汉族"},
                        {id:2,name:"朝鲜族"},
                        {id:3,name:"白族"},
                        {id:4,name:"回族"},
                        {id:5,name:"藏族"},
                        {id:6,name:"羌族"},
                    ]
               }
           },
        });
    </script>
```



# day11 Vue进阶

## 一、Node.js

### 1. Node.js简介

Node.js 是一个开源与跨平台的 `JavaScript 运行时环境`。 它是一个可用于几乎任何项目的流行工具！

Node.js 在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核）。 这使 Node.js 表现得非常出色。

Node.js 可以在一台服务器上处理数千个并发连接，而无需引入管理线程并发的负担（这可能是重大 bug 的来源）。

Node.js 具有独特的优势，因为为浏览器编写 JavaScript 的数百万前端开发者现在除了`客户端代码`之外还可以编写`服务器端代码`，而无需学习完全不同的语言。

在 Node.js 中，可以毫无问题地使用新的 ECMAScript 标准，因为不必等待所有用户更新其浏览器，你可以通过更改 Node.js 版本来决定要使用的 ECMAScript 版本，并且还可以通过运行带有标志的 Node.js 来启用特定的实验中的特性。

> 从广泛使用 JavaScript 的前端开发者的角度来看，Node.js 应用程序具有巨大的优势：使用单一语言轻松编程所有一切（前端和后端）。

### 2. 安装Node.js

官网下载地址：**http://nodejs.cn/download/**

下载完成后，双击“ **node-v14.16.1-x64.msi**”，开始安装：

![image-20210812143706383](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812143706.png)

点击“ Next ”按钮 :

![image-20210812143907001](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812143907.png)

勾选后，点击next：

![image-20210812144144851](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812144144.png)

选择安装目录，点击“ Next ”按钮

![image-20210812144250279](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812144250.png)

选择安装项，此处选择默认，点击“ Next ”按钮 ：

![image-20210812144657935](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812144657.png)

点击“ Install ”按钮，开始安装 ……

安装完成后finish即可

查看是否安装成功 ：

在cmd黑窗口中：

A、node -v 查看 node 版本
B、npm -v 查看 npm 版本

出现下图内容，则表示安装完成：

![image-20210812145003292](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812145003.png)

安装完成后文件目录如下图 ：

![image-20210812145119681](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812145119.png)

> npm是我们要使用的命令！
>
> 类似maven mvn 这个命令，可以帮我们下载依赖。
>
> npm 就是帮我们下载前端工具等内容的。

## 四、Vue CLI

Vue CLI是一个基于Vue.js进行快速开发的完整系统，其中提供了搭建交互式项目的脚手架。

> 脚手架：有点类似java中的 创建maven项目一样。直接建好后，啥都提供出来。

### 1.安装VueCLI

使用npm执行以下命令，全局安装Vue CLI(前置要求Node.js安装完成，npm -v能打印出版本号)

打开cmd命令行窗口，执行下列命令：

```
npm i -g @vue/cli
```

安装完成后，基于node.js，创建Vue项目：

在需要创建 vue 项⽬的⽬录中，运行cmd命令行窗口，执⾏以下命令（其中 vue-project 是项⽬⽂件名）：

```
 vue create vue-project
```

> 如果说没有安装脚手架会出现vue找不到该命令，如下图：
>
> ![image-20210812152641226](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812152641.png)
>
> 此时重新安装脚手架即可。

如果vue create 项目名，创建成功，将出现下图：

![image-20210812153050830](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812153050.png)

此处有三个选择，使用方向机上下来进行选项切换：

default vue2|3，是默认模式，提供vue2.0或者vue3.0的项目创建，我们的课程基于vue2.0，所以，我们就还是老老实实使用Manually，自定义手动模式创建，可以自己选择需要的功能。

所以此处，选择第三项(最后一项)：

进入自定义模式，选中Router和Vuex，即使不选，后期可以自己配置也行，但是推荐勾选上，可以不用，但是我必须有：

![image-20210812153735808](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812153735.png)

选择完后，回车：

![image-20210812153855784](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812153855.png)

选择2.x版本，回车：

![image-20210812153931465](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812153931.png)

这里让我们选择是否使用history router：

这里我们选N，回车进入下一步：

![image-20210812154106936](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812154119.png)

该页面，是选择关于Babe、PostCSS、ESLint、etc. 这些配置文件是放在package.json里面，还是单独放在外面。

编辑器一般默认会在项目根目录下寻找配置文件，所以这里外面就直接回车，选择In dedicated config files即可。

![image-20210812154540921](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812154540.png)

是否将以上设置保存为未来项⽬的预配置，也就是可以快速创建这次配置的vue项目。是否保存，都无所谓，此处直接N，回车：

![image-20210812154659431](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812154659.png)

此时，将会在对应cmd打开的目录下，创建vue项目；

![image-20210812155559091](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812155559.png)

创建完成后，显示如上图所示，可以直接通过命令 cd vue-project，切换进入项目目录，然后使用npm run serve运行项目：

![image-20210812155700626](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812155700.png)

运行成功如下，浏览器访问http://localhost:8080/即可，出现下图，即表示成功！

![image-20210812155754659](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812155754.png)

## 五、组件

### 1. 组件介绍

组件可以理解为后端代码的封装，可以把某些页面或者某些功能(地址三级联动下拉框)，抽取成组件，然后再任意页面中，都能快速使用。

组件可以拓展HTML元素、封装`可重用`的代码。根据项目需求，抽象一些组件，每个组件里面都包含了`页面的显示、按钮的功能、整体演示、后端数据对接`。

组件可以是一个完整的页面，也可以是某些单独的功能按钮，只要组件页面发生修改，那么其他所有使用了这个组件的地方都会同时修改。

![006tNc79gy1g4ww3vkuldj30x40cyjsa](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210812161240.png)

学好组件，前端页面开发就会更加灵活和快速。也是Vue的最重要功能。

> 组件口诀：
>
> ```
> 声子 挂子 用子
> ```
>
> 声明子组件 挂载子组件 使用子组件

### 2. 组件的注册

引入element-ui来使用官方的组件！

#### 2.1 自定义组件

1. 在components文件夹下，创建一个自定义的vue页面

```vue
<template>
<!-- template下的 标签，只能有一个根标签 vue2.x版本 -->
    <div>
        <h1>我是一个子组件</h1>
        <input type="text" v-model="myinput">
    </div>
</template>
<script>
export default {
    data() {
        return {
            myinput:""
        }
    },
}
</script>
```

2. 在目标页面声子、挂子、用子

```vue
<template>
  <div class="about">
    <h1>This is an about page</h1>
    <!-- 3.用子 -->
    <minput/>
  </div>
</template>
<script>
//1. 声子
import mymyinput from '@/components/myinput.vue'
  export default {
    //2.挂子
    components:{
      // 冒号左边 表示当前页面的别名  右边 表示import上写的名字
        minput:mymyinput
    }
  };
</script>
```

效果已经出现



> 挂子的时候，如果冒号左右两边的名字是一样的，则可以只写一个名字即可！
>
> ```vue
> components:{
> // 冒号左边 表示当前页面的别名  右边 表示import上写的名字
> mymyinput，//<==>  mymyinput:mymyinput
> }
> ```
>
> 

#### 2.2 elementui的组件

配置步骤：

1. 在目标项目下 运行 npm i element-ui -S 这个-S表示局部，当前项目中安装，-g表示全局安装！
2. main.js注册：

```vue
import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';
Vue.use(ElementUI);
```

1. 直接使用官方的例子来创建组件！

### 3.父子组件传值(难度略高，重要性很重要)

#### 3.1 父传子

> 父组件和子组件是啥 ？？
>
> 在A页面，使用声子挂子用子引入了B组件，那么A就是B的父组件。
>
> 为什么父子组件之间要传值呢？
>
> 分页组件每个页面都有！但是每个页面显示的具体是哪一页，每页显示多少条，都会不一样，这些内容是不能直接写死的，currentPage当前页，pageSize每页显示多少条。
>
> ![image-20220409171435897](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204091714229.png)

数据父传子：必须`在子组件中，自定义属性！`

在子组件中，使用props属性，即可定义子组件拥有的自定义的属性。

props属性：props是组件特有的重要属性，我们所有组件或页面，都可以通过props来自定义对应的标签属性。然后，父组件在使用子组件标签的时候，就能使用这个属性，往对应的子组件传入不同的值！

##### 3.1.1 props数组定义

在子组件的页面中，我们通过props使用数组直接定义多个不同的属性。

```vue
export default {
  name: 'HelloWorld',
  props: ['msg', 'name', 'age']
}
```

在父组件中：

```vue
<template>
    <son msg="父的信息1" :name="父组件动态值" :age="父组件动态年龄"></son>
</template>
```

##### 3.1.2 props 对象定义

当我们希望每个 *prop* 都有指定的值类型。这时，你可以以对象形式列出 *prop*，这些属性的名称和值分别是 *prop* 各自的名称和类型：

```js
export default {
  name: 'HelloWorld',
  props: {
    title: String,
    likes: Number,
    isPublished: Boolean,
    commentIds: Array,
    author: Object,
    callback: Function,
    contactsPromise: Promise  // or any other constructor
  }
})
```

> 额外知识—-限制传递数据类型(了解即可)：
>
> ```js
> export default {
> props: {
> // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
> propA: Number,
> // 多个可能的类型
> propB: [String, Number],
> // 必填的字符串
> propC: {
> type: String,
> required: true
> },
> // 带有默认值的数字
> propD: {
> type: Number,
> default: 100
> },
> // 带有默认值的对象
> propE: {
> type: Object,
> // 对象或数组默认值必须从一个工厂函数获取
> default: function () {
>   return { message: 'hello' }
> }
> },
> // 自定义验证函数
> propF: {
> validator: function (value) {
>   // 这个值必须匹配下列字符串中的一个
>   return ['success', 'warning', 'danger'].indexOf(value) !== -1
> }
> }
> }
> }
> ```
>
> 当 *prop* 验证失败的时候，(开发环境构建版本的) *Vue* 将会产生一个控制台的警告。
>
> > #### 注意那些 prop 会在一个组件实例创建**之前**进行验证，所以实例的属性 (如 `data`、`computed` 等) 在 `default` 或 `validator` 函数中是不可用的。

##### 3.1.3 单向数据流

通过在子组件中定义props自定义属性，父组件就可以通过子组件的自定义属性往子组件中传值，这个父子之间形成的单向下行绑定：父组件传值到子组件中，向下流动的意思。

单向数据流：单一向下流动，不能反向流动。

设置`单向数据流`的原因是，防止子组件意外改变父组件的状态，从而导致你的应用程序数据流向很难理解。

> 额外的：
>
> 每次父组件发生了更新，子组件中props都会刷新为最新的值！这个就意味着，我们不应该在一个子组件内部去改变props定义的属性，改了后就会报错。

方案一：

prop用来传递一个初始值，子组件把这个值作为本地数据的来源直接使用。

```js
 props:{
        //子组件内部，不允许直接操作自定义属性 接收的父组件的值！
        value:{
            type:Number
        }
    },
   //data属性实例化完成后，才允许用this.sonvalue     
    data() {
      return {
          //方案一：设置会有一个问题，它只有一次值！
        sonvalue: this.value
      }
    }
```

> 方案一的场景：
>
> 通常是子组件获取一次父组件的初始值后，就不会被父组件的值来进行修改了。

方案二：

prop以原始值传入后，且需要进行转换或者复杂的计算，通常会为它定义一个`计算属性`：

https://cn.vuejs.org/v2/guide/computed.html 不讲，自己以后用到了自己去看！

方案三：推荐

侦听器，监听器；

Vue提供的一个比较通用的方式，来观察和响应Vue实例上的数据变动；watch属性。

```js
    props: {
      //子组件内部，不允许直接操作自定义属性 接收的父组件的值！
      value: {
        type: Number,
      },
    },
    //它是个内存地址，在Vue对象实例化的时候，会开辟一个空间把这个地址的值放进入
    data() {
      return {
        //方案一：设置会有一个问题，它只有一次值！
        sonvalue: this.value,
      };
    },
//监听属性
    watch:{
        //value表示被监听的值，value发生变化，方法就会执行
        value:function(newValue,oldValue){
            // console.log(newValue,oldValue);
            //data中的sonvalue初始化以后不再改变，但是我们可以手动去修改它！
            this.sonvalue  = newValue;
        }
    }
```

#### 3.2 子传父

```
自定义事件！
```

> 子组件可以使用内建的$emit方法，传入自定义事件名称，来触发一个事件，响应给父组件！

方法一：

子组件的代码：

```html
<template>
  <div class="block">
    <el-slider v-model="sonvalue" show-input @change="$emit('callFather',sonvalue)"> </el-slider>
  </div>
</template>
```

> [@change](https://github.com/change)是子组件标签的事件；v-on:change
>
> 一旦发生改变，就会触发事件！
>
> $emit(‘callFather’,sonvalue)
>
> $emit 这个就是会用来创建自定义事件的！
>
> 第一个参数：自定义事件的名称！在父组件中可以使用的名称！
>
> 第二个参数：该自定义事件传过去的参数。

父组件的代码：

> [@callFather](https://github.com/callFather)=”methodFather”
>
> callFather是子组件中定义好的事件名称！
>
> methodFather是父组件的方法名。

方法二：

子组件定义的方法比较复杂的话，需要把$emit提出去！不要写在页面上！

```js
 <el-slider v-model="sonvalue" show-input @change="sonMethod"> </el-slider>
<script>
    methods:{
        //方法二： 子组件的方法
        sonMethod(){
            //其他逻辑业务要写
            this.$emit("callFather",this.sonvalue);
        }
    }
</script>
```

> 注意：
>
> 提出方法的话，$emit前面必须加this！



# day12 Vue进阶最后一天

## 一、复习

![image-20220411140046959](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204111400049.png)

## 二、路由

### 1. 什么是路由

Vue Router 是Vue.js官方的路由管理器，它与Vue是深度集成的，让构建页面应用更加的简单。

路由实际上是一种`指向`，点击某个按钮后，会跳转`显示对应的页面`。

Vue Router官网地址：https://router.vuejs.org/zh/

### 2. Vue Router开发

之前在通过脚手架创建vue项目时：通过命令vue create vue-project，在其中一个选项中勾选了router，所以我们创建的项目中，就已经集成了router路由了。

如果没有勾选怎么办？

我们可以在命令行中输入npm install vue-router -g来安装vue-router，安装完之后我们可以打开package.json文件，在package.json文件中可以看到vue-router的版本号：

![image-20210813154842282](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210813154842.png)

到这一步我们的准备工作就完成了，如果说src下没有router文件夹，则可以创建一个即可，然后在该文件夹下创建index.js；如果是脚手架创建时，就选中了vue，则会有系统自带的路由demo，如下：

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
//引入目标路由页面
import Home from '../views/Home.vue'
//全局引入
Vue.use(VueRouter)
//自定义路由数组
const routes = [
  {
    //路由路径  
    path: '/',
    name: 'Home',
    //对应路由界面的第一种写法
    component: Home
  },
  {
    path: '/about',
    name: 'About',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
      //额外引入路由页面组件的第二种写法
    component: () => import(/* webpackChunkName: "about" */ '../views/About.vue')
  }
]
//创建VueRouter对象，返回该对象
const router = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes  //就是routes：routes
  //也可以直接写在里面，不过提出去直观一点
  //routes: [...]
})
})
export default router
```

至此路由配置是完成了，直接通过url可以访问：

比如http://localhost:8080/about 可以访问上面配置的path为/about的组件页面About.vue；

之前学习过a标签，可以跳转到对应url上，在我们vue项目中，其实也能用a标签。

```html
<template>
  <div id="app">
    <nav>
      <router-link to="/">Home</router-link> |
      <!-- <router-link to="/about">About</router-link> | -->
      <a href="/about">新增的页面</a>
    </nav>
    <router-view/>
  </div>
</template>
```

> 为什么不用a标签？
>
> 点击a标签，会跳转到另外一个页面，通过a标签来跳转，它会重新加载页面，相当于重新打开了一个网页。
>
> 类似form表单，全局同步请求。
>
> router-link：
>
> 用router-link进行跳转，不会跳转到新的网页，不会重新渲染，它会根据路由所指向的组件页面，进行渲染。
>
> 类似ajax的局部异步请求。

语法：

```html
<router-link to=""></router-link>
<!-- 类似  <a  href></a>   to 就相当于a标签的href -->
<!-- 必备路由出口:router-link to的url所对应的页面，最终渲染的地方 -->
<router-view/>
```

### 3. 路由嵌套

路由嵌套：在一级路由出口router-view所渲染的A页面中，还有一个router-view路由出口渲染B页面，那么，就说明，A页面中嵌套了一个B页面。

![image-20220411143014238](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204111430384.png)

#### 3.1 构建一个路由嵌套

> 通常在项目中，路由的嵌套一般不超过3层。

步骤：

1. 先注册路由，在router/index.js中配置对应的路由

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import HomeView from '../views/HomeView.vue'
Vue.use(VueRouter)
const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/about',
    name: 'about',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue')
  },
  {
    //第一级路由
    path: '/routerOne',
    name: 'routerOne',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue'),
    children: [
      {
        //第二级路由
        path: '/routerOne/routerTwo',
        name: 'routerTwo',
        // route level code-splitting
        // this generates a separate chunk (about.[hash].js) for this route
        // which is lazy-loaded when the route is visited.
        component: () => import(/* webpackChunkName: "about" */ '@/components/system/context.vue'),
        children:[
          //配置三级路由
        ]
      },
      {
        //第二级路由2
        path: '/routerOne/routerTwo2',
        name: 'routerTwo2',
        // route level code-splitting
        // this generates a separate chunk (about.[hash].js) for this route
        // which is lazy-loaded when the route is visited.
        component: () => import(/* webpackChunkName: "about" */ '@/components/system/context2.vue'),
      }
    ]
  }
]
const router = new VueRouter({
  routes
})
export default router
```

> 核心内容：子路由，必须由父路由的children属性来定义。

1. 在目标页面配置路由链接

```
<router-link to="之前在index.js中配置的path"></router-link>
```

1. 在父路由所在页面上，配置路由出口；

```js
component： () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue'),
    //在父路由的对应页面上配置出口，就是子路由的页面渲染的地方
    children：[]
```

### 4、动态路由传参

我们在跳转某个页面的时候，需要携带上用户userid，然后来促使路由页面显示不同的内容。

通过动态路由传参，使用的有2种方式：

1. xxxx.vue/userinfo/1 params属性来传参
2. oooo.vue/userinfo?userid=1 query参数属性来传参

示例一：使用`拼接`的手段，直接拼接动态参数上去。

```html
<el-menu-item index="1-1">
    <!-- xxxx.vue/userinfo/1      params属性来传参 -->
            <router-link :to="{path:'/routerOne/routerTwo/'+userid}">二级路由出口1</router-link>
            </el-menu-item>
<el-menu-item index="1-2">
    <!-- oooo.vue/userinfo?userid=1   query参数属性来传参 -->
             <router-link :to="{path:'/routerOne/routerTwo2?userid='+userid}">二级路由出口2</router-link>
</el-menu-item>
```

示例2：命名路由传参

```html
<el-menu-item index="1-1">
    <!-- xxxx.vue/userinfo/1      params属性来传参 -->
            <router-link :to="{name:'routerTwo',params:{useridkey:userid}}">二级路由出口1</router-link>
            </el-menu-item>
<!-- oooo.vue/userinfo?userid=1   query参数属性来传参 -->
          <el-menu-item index="1-2">
             <router-link :to="{name:'routerTwo2',query:{useridkey:userid}}">二级路由出口2</router-link>
            </el-menu-item>
```

对应的效果：

![image-20220411160125212](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204111601305.png)

![image-20220411160116383](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204111601504.png)

> 同时点一个路由2次，其实页面没有刷新？生命周期钩子函数，created(){}，它只会在页面渲染的第一次时候生效。如果再次点击该页面，即使传入的userid有变化，但是实际上并不会触发created函数。vue会让组件的实例复用，因为`两次路由触发都是渲染的同一个组件`的情况，比起销毁vue实例，再创建vue实例，复用效率会更高。所以，我们的生命周期钩子函数，不会再一次被调用。
>
> 怎么处理？
>
> 使用监听watch:监听`$route`!
>
> ```
> watch:{
>      $route(to,from){
>          //to就是新的值 到哪里去
>          console.log(to);
>          //from就是旧值 从哪里来
>          console.log(from);
>      }
> ```
>
> 

### 5、导航守卫(了解)

也称之为`路由守卫`：导航，通常表示路由正在发生变化。

> 类似java中的拦截器或过滤器！preHandler和postHandler！
>
> 对应前端的路由守卫：beforeEach和afterEach！

在通过路由跳转之前，和跳转成功之后，可以对该路由进行拦截，并相应的处理某些业务：比如，是否放行。

可以用来处理：未登录，跳转到login页面。可以配置全局前置路由，来拦截路由的跳转，如果登录了就允许next()跳转到对应路由页面。如果没有登录，则会拦截，next({name:”Login”})。

https://router.vuejs.org/zh/guide/advanced/navigation-guards.html

## 三、Axios

官网链接：http://www.axios-js.com/zh-cn/docs/index.html

> 简而言之：Axios把它当做ajax来使用即可！

根据官网安装配置即可：
根据官网安装配置即可：

1. 先通过npm指令安装axios：npm i axios
2. 项目中，main.js中配置

```vue
import axios from 'axios'
Vue.use(axios);
//在任意页面中 直接使用  this.$axios  方法来直接使用axios进行请求
Vue.prototype.$axios = axios;
axios.defaults.baseURL = 'http://localhost:7070';
```

1. 页面中2种方案使用

方案1：直接在方法中定义：

```vue
//钩子函数 在组件第一次渲染的时候才执行
    created(){
      this.findAllManager();
    },
    methods: {
      findAllManager(){
        this.$axios.get("/rbacManager/manager").then((res)=>{
          console.log(res);
          if(res.data.code ==200){
            this.tableData = res.data.data
          }
        }).catch(()=>{});
      }
    },
```

方案2：在页面中引入axios：

```vue
import axios from 'axios'；
//对应axios使用的时候：直接用
axios.get("/rbacManager/manager").then((res)=>{
          console.log(res);
          if(res.data.code ==200){
            this.tableData = res.data.data
          }
        }).catch(()=>{});
```

### 3.1 跨域问题后端解决方案

发起请求的时候，会报错：

前端的url: [http://localhost:8080](http://localhost:8080/)

后端的url:[http://localhost:7070](http://localhost:7070/)

> 什么情况下会出现跨域：
>
> 1. 前端的服务器的请求方式，http和https与后端不匹配、
> 2. ip和后端不匹配localhost
> 3. 端口号和后端不匹配 8080 与7070
>
> 什么是跨域呢？
>
> 1. 跨域是浏览器的安全机制，它检查出来，你是在跨服务进行业务请求，它不允许！
> 2. 相当于京东的请求，去访问淘宝的后台。不允许。

后端怎么解决呢？

> 1. 配置过滤器或者拦截器
> 2. 配置注解！在controller类上或者方法上加 `@CrossOrigin`



# day13 练习前后端crud



# day14 shiro

## 一、RBAC概念

> 基于角色的权限访问控制(Role-Based Access Control)作为传统访问控制(自主访问，强制访问)的有前景的代替受到广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。
>
> 这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。
>
> 角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。

第一类权限信息: 只有用户和权限表 1对多

![image-20210427143408048](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210427143408.png)

如果用户群体大, 是不是每一个用户都需要配置一遍?? 如果要去掉某一批基层员工的某个权限, 就需要去修改每个人的权限信息!

第二类加中间表: 和第一类 仅仅只是sql语句存储的数据不同

![image-20210427145024713](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210427145024.png)

第三类: 有角色表!RBAC 的最基本的内容！

画图讲解^ ^用户 角色 权限 如果没有角色会怎样??

![image-20210425225959659](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210425225959.png)

在RBAC模型中，角色是系统根据管理中相对稳定的职权和责任来划分，每种角色可以完成一定的职能。用户通过饰演不同的角色获得角色所拥有的权限，一旦某个用户成为某角色的成员，则此用户可以完成该角色所具有的职能。通过将权限指定给角色而不是用户，在权限分派上提供了极大的灵活性和极细的权限指定粒度。

最简单的RBAC权限表有5张：用户表 —- 用户角色中间表 —- 角色表 —- 角色权限中间表 —- 权限表

第四类[了解]: 加菜单 用户表 —- 用户角色中间表 —- 角色表 —- 角色权限中间表 —- 权限表 —- 角色菜单中间表 —- 菜单表

第五类[了解]: 租户 SAAS系统! 通用服务! 内部系统—-定制化开发! PAAS系统 (平台)，就是一堆SAAS系统。

第六类：中台 合久必分 分久必合 现在2022年 拆中台 去中心化

![image-20210427153247025](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210427153247.png)

第七类：未来趋势DDD 领域驱动设计 国内这个DDD的落地比较假

## 二、常见的认证机制

> 认证的目的：登录后，如何判断你是登录成功？如何判断你这个用户是谁？
>
> Auth：authorization 授权意思
>
> ​			authentication 认证

### 1. HTTP Basic Auth

HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码`暴露给第三方客户端`的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth

### 2. Cookie Auth(前后端不分离)

Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效

> 弊端：前后端分离项目中就无法使用了。

### 3. OAuth(第三方认证)

OAuth（开放授权）是一个开放的授权标准(类似USB的通用协议)，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问`特定`的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。

![image-20210429011812526](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210429011812.png)

![image-20210429154047759](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210429154047.png)

### 4. Token Auth(重点)

> 和第一类 HTTP Basic Auth认证的形式是一样的，它支持前后端分离，APP手机端认证，都是采用的token认证机制。
>
> Token令牌，它是一串加密的字符串，里面可能会包含账号，密码。只不过和Http basic 认证的区别是，不是用的明文。

使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：

1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，服务端会签发(生成一个)一个 Token，再把这个 Token 发送给客户端(浏览器)
4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里，LocalStorage
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证(验证token有没有被篡改，有没有过期)成功，就向客户端返回请求的数据

![image-20210429011902435](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210429011902.png)Token Auth的优点:

1.支持`跨域`访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.
2.`无状态`(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.
3.更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.
4.`去耦`: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.
5.更适用于`移动`应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。
6.`CSRF`:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。
7.性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多.
8.不需要为登录页面做特殊处理: 如果你使用postman做功能测试的时候，不再需要为登录页面做特殊处理.
9.基于标准化:你的API可以采用标准化的 `JSON Web Token (JWT).` 这个标准已经存在多个后端库（.NET, Ruby,Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.

## 三、JWT入门(基本应用)

Json Web Token！json令牌！

JJWT jar包!

```java
package com.woniuxy;
import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import java.util.Date;
/**
 * @Author: 马宇航
 * @Todo: 测试Java-JWT用
 * @DateTime: 22/04/13/0013 下午 2:08
 * @Component: 成都蜗牛学苑
 **/
public class Test {
    public static void main(String[] args) {
        JwtBuilder jwtBuilder = Jwts.builder().setId("857").setSubject("admin").setIssuedAt(new Date())
                //如果我想要自定义信息放进去，然后再解密出来行不行呢？
                .claim("myMoney",188)
                .claim("myName","马宇航")
                .claim("mycity","四川省")
                .signWith(SignatureAlgorithm.HS256, "woniu");
        System.out.println(jwtBuilder.compact());
    }
}
```

解析该jwt：

```java
package com.woniuxy;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
/**
 * @Author: 马宇航
 * @Todo: 解析jwt的值
 * @DateTime: 22/04/13/0013 下午 2:11
 * @Component: 成都蜗牛学苑
 **/
public class ParasJWT {
    public static void main(String[] args) {
        String token = "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4NTciLCJzdWIiOiJhZG1pbiIsImlhdCI6MTY0OTgzMDk2MiwibXlNb25leSI6MTg4LCJteU5hbWUiOiLpqazlrofoiKoiLCJteWNpdHkiOiLlm5vlt53nnIEifQ.WainLInsvGzJEuANTc7Hs7izoXfGWDMWFooCY8ZsdyE";
        //signingkey 签名  签名是有唯一性的！
        Claims claims = Jwts.parser().setSigningKey("woniu")
                .parseClaimsJws(token).getBody();
        System.out.println(claims.getId());
        System.out.println("主体是哪个用户："+claims.getSubject());
        System.out.println("签名(生成token)的时间："+claims.getIssuedAt());
        System.out.println(claims.get("myMoney"));
        System.out.println(claims.get("mycity"));
    }
}
```

## 四、Shiro权限框架

现在系统需要实现：
超级管理员登录系统，显示所有的功能
而普通管理员登录系统，显示他对应的功能

如果没有Shiro这种权限框架的情况，创建 role_info menu_info role_menu表

登录的时候，查询后端的权限，并根据权限展示页面

但这套逻辑需要自己写，很麻烦！

### 1. Shiro的简介

公司项目中，常见的权限框架：shiro | Spring Security

Apache Shiro是一个功能强大且灵活的开源安全框架，可以清晰地处理身份验证，授权，企业会话管理和加密。

Apache Shiro 的首要目标是易于使用和理解。权限是很复杂的，甚至是痛苦的，但它没有必要这样。框架应该尽可能掩盖( 黑盒 | 空调)复杂的地方，露出一个干净而直观的 API(遥控器)，来简化开发人员在使他们的应用程序安全上的努力。

Shiro能帮系统做什么：
1、做用户的身份认证(登录)，判断用户是否系统用户（重点）
2、给系统用户`授权`，用来帮助系统实现不同的用户展示不同的功能（重点）
3、针对密码等敏感信息，进行`加密`处理（明文变成密文）（重点）
4、提供了Session管理，但是它的Session不是HttpSession，是它自己自带的
5、做授权信息的`缓存`redis管理，降低对数据库的授权访问
6、提供测试支持，因为它也是一个轻量级框架，它也可以直接针对代码进行使用Junit单元测试
7、提供Remember me的功能，可以做用户无需再次登录即可访问某些页面
8、启用单点登录（SSO）功能。

### 2. Shiro提供的10大功能

![img](https://woniuxyopenfile.oss-cn-beijing.aliyuncs.com/woniuxynote/classNoteMd/202012011021/%E5%9B%BE%E7%89%871.png)

1. Authenti`c`ation 身份`认证`/登录，验证用户是不是拥有相应的身份；
2. Authori`z`ation `授权`，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；
3. Session Management 会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；
4. Cryptography 加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；
5. Web Support：Web支持，可以非常容易的集成到Web环境；
6. Caching 缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；
7. Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；
8. Testing : 提供测试支持；
9. Run As +:可以模仿一个账户。
10. Remember Me 记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了

### 3. Shiro的架构图

接下来从Shiro内部来看下Shiro的架构，如下图所示：
![img](https://woniuxyopenfile.oss-cn-beijing.aliyuncs.com/woniuxynote/classNoteMd/202012011037/%E5%9B%BE%E7%89%871.png)

**Subject主体：**可以看到主体可以是任何可以与应用交互的“用户”；

**SecurityManager：** 相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理。

**Authenticator认证器：**负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证(登录)通过了；

**Authrizer授权器：** 或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；

**Realm域(面试常问)：** 可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm；

**SessionManager：** 如果写过Servlet就应该知道Session的概念，Session呢需要有人去管理它的生命周期，这个组件就是SessionManager；而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境；所有呢，Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据；这样的话，比如我们在Web环境用，刚开始是一台Web服务器；
接着又上了台EJB服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可
以实现自己的分布式会话（如把数据放到Memcached服务器）；

**SessionDAO：** DAO大家都用过，数据访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把Session放到Memcached中，可以实现自己的Memcached SessionDAO；另外SessionDAO中可以使用Cache进行缓存，以提高性能；

**CacheManager** 缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能

**Cryptography** 密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密的。

### 4. Shiro框架的3个核心类

首先，从外部来看Shiro，即从应用程序角度的来观察如何使用Shiro完成工作。如下图：

![image-20210429004301470](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210429004301.png)

**Subject主体：** 需要登录系统的东西，都是主体。 代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager，可以把Subject认为是一个门面；SecurityManager才是实际的执行者；

**SecurityManager安全管理器：** 即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与其他组件进行交互，相当于DispatcherServlet前端控制器；

**Realm域：** 一个用来做身份认证，以及授权的对象 Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，就是一个跟权限数据有关的数据源。

**记住一点：** Shiro不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给Shiro即可。

![image-20210430113415901](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210430113416.png)

## 五、Shiro的入门程序(极度重要)

> 只要你把这个代码敲明白，那么shiro整个学习就能明白流程！

### 1. 基于ini配置文件的shiro环境

引入依赖：

```xml
<!--     shiro的核心包：项目中不是用这个   -->
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-core</artifactId>
            <version>1.7.1</version>
        </dependency>
```

### 2. 用户认证 Authentication

登录后，账号密码，确定是否正确。这个就是用户认证。

1. 在resource中新建一个shiroConfig文件夹，新建一个文件shiro-auth.ini：

```ini
[users]
# 模拟数据库，假设ini里面就是我们数据库中的用户信息
# 用户名=密码
mayuhang=123456
mahuateng=22222
mayun=11111
```

1. 进行代码开发

```java
package com.woniuxy.shiro_ini;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.env.BasicIniEnvironment;
import org.apache.shiro.env.Environment;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;
/**
 * @Author: 马宇航
 * @Todo: 配合shiro-auth.ini文件，来进行入门的认证开发
 * @DateTime: 22/04/13/0013 下午 3:30
 * @Component: 成都蜗牛学苑
 **/
public class TestIniLoginAuthz {
    public static void main(String[] args) {
        //1.读取配置文件,生成一个shiro的环境
        Environment environment = new BasicIniEnvironment("classpath:shiroConfig/shiro-auth.ini");
        //2.通过这个环境，生成默认的SecurityManager对象
        SecurityManager securityManager = environment.getSecurityManager();
        //3.shiro的工具类需要一个SecurityManager的环境
        SecurityUtils.setSecurityManager(securityManager);
    // -----------上面的代码，在后面项目中会通过配置文件搞定，不用记，类似Spring入门的ApplicationContext------------------------------------
        //4.有环境的工具包，将能获取到一个subject对象，然后我们就能使用subject对象来进行业务开发！
        Subject subject = SecurityUtils.getSubject();
        //5.有了主体用户以后，可以直接执行login来进行登录
        subject.login(new UsernamePasswordToken("mayun","11111"));
        //此处，subject主体执行login操作，底层会自动帮我去ini配置文件中匹配，能匹配上，则登录成功
        System.out.println("当前的"+subject.getPrincipal()+"用户，登录状态："+subject.isAuthenticated());
        if (subject.isAuthenticated()){
            //如果登录成功，则继续执行后续的业务
        }
    }
}
```

### 3. 用户授权 Authorization

授权，权限的验证，首先必须先登录成功以后才能授权。不同权限就可以判断，是能放行某个controller方法。有点类似拦截器，也用到了AOP，后期还能用注解来进行权限判断。

1. 在resource中新建一个shiroConfig文件夹，新建一个文件shiro-perm.ini：

```ini
[users]
# 模拟数据库，假设ini里面就是我们数据库中的用户信息
# 用户名=密码,角色1,角色2.....
mayuhang=123456,admin,teacher
mahuateng=22222,civilian,student
mayun=11111,boss
[roles]
#模拟数据库中的角色权限表,含关联中间表
# 角色=权限1，权限2
admin=user:save,user:update,user:find,user:delete
teacher=user:save,user:find
civilian=user:find
student=user:findOne
# 权限的写法约定好即可 实体类的名称::操作
boss=everything::all,eat:person
```

1. 进行代码开发

```java
package com.woniuxy.shiro_ini;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.env.BasicIniEnvironment;
import org.apache.shiro.env.Environment;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;
/**
 * @Author: 马宇航
 * @Todo: 校验某个用户是否拥有某些角色或者权限
 * @DateTime: 22/04/13/0013 下午 4:09
 * @Component: 成都蜗牛学苑
 **/
public class TestIniPermAuthz {
    public static void main(String[] args) {
        //1.读取配置文件,生成一个shiro的环境
        Environment environment = new BasicIniEnvironment("classpath:shiroConfig/shiro-perm.ini");
        //2.通过这个环境，生成默认的SecurityManager对象
        SecurityManager securityManager = environment.getSecurityManager();
        //3.shiro的工具类需要一个SecurityManager的环境
        SecurityUtils.setSecurityManager(securityManager);
        // -----------上面的代码，在后面项目中会通过配置文件搞定，不用记，类似Spring入门的ApplicationContext------------------------------------
        //4.有环境的工具包，将能获取到一个subject对象，然后我们就能使用subject对象来进行业务开发！
        Subject subject = SecurityUtils.getSubject();
        //5.有了主体用户以后，可以直接执行login来进行登录
        subject.login(new UsernamePasswordToken("mahuateng","22222"));
        //此处，subject主体执行login操作，底层会自动帮我去ini配置文件中匹配，能匹配上，则登录成功
        System.out.println("当前的"+subject.getPrincipal()+"用户，登录状态："+subject.isAuthenticated());
        if (subject.isAuthenticated()){
            //如果登录成功，则继续执行后续的业务
            if (subject.hasRole("boss")){
                System.out.println("当前的"+subject.getPrincipal()+"用户，它能干boss的事情");
            }
        }
        //判断是否拥有吃人的权限
        if (subject.isPermitted("eat:person")){
            System.out.println("当前的"+subject.getPrincipal()+"用户，它能吃人");
        }
    }
}
```

角色判断方法：

权限判断方法：

### 4.自定义域realm

> 核心记住一个抽象类：AuthorizingRealm

![image-20220413170000410](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204131700562.png)

1. 声明ini配置文件

```ini
[main]
#声明自定义域
myRealm=com.woniuxy.shiro_ini.TestIniRealmAuth
#把自定义域注册到shiro的SecurityManager中
securityManager.realms=$myRealm
```

1. 写自定义域，先完成认证的自定义方法

```java
package com.woniuxy.shiro_ini;
import org.apache.shiro.authc.*;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
/**
 * @Author: 马宇航
 * @Todo: 自定义域 重新认证和授权的具体方法
 * @DateTime: 22/04/13/0013 下午 4:18
 * @Component: 成都蜗牛学苑
 **/
public class CustomRealm extends AuthorizingRealm {
    /**
     * 自定义授权的信息：类似ini中配置好的权限绑定关系！
     * ChangeLog : 1. 创建 (22/04/13/0013 下午 4:19 [马宇航]);
     * @param principals
     * @return org.apache.shiro.authz.AuthorizationInfo
    */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        return null;
    }
    /**
     * 登录认证的操作：具体登录后封装信息用！同时还能去数据库判断账号密码是否匹配
     * ChangeLog : 1. 创建 (22/04/13/0013 下午 4:19 [马宇航]);
     * @param token
     * @return org.apache.shiro.authc.AuthenticationInfo
    */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) token;
        String username = usernamePasswordToken.getUsername();
        //mybatis调用方法去数据库查出所有的 密码 和 用户 等信息。
        //假的模拟的数据 if就是去数据库查出的用户信息数据
        if ("mayuhang".equals(username)){
            //返回给shiro一个SimpleAuthenticationInfo，以便底层去帮你匹配信息校验登录情况。
            //这个里面的凭证信息都是来自数据库中的，都是正确的，但是你传的密码不一定正确的 123456 来自数据库
            return new SimpleAuthenticationInfo(username,"123456","CustomRealm");
        }eles{
            //说明数据库没有这个账号
            throw AuthorizationException("该账号不存在！")
        }
        return null;
    }
}
```

1. 写测试类，先判断认证是否成功

```java
package com.woniuxy.shiro_ini;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.env.BasicIniEnvironment;
import org.apache.shiro.env.Environment;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.Subject;
/**
 * @Author: 马宇航
 * @Todo: 测试我们的自定义域
 * @DateTime: 22/04/13/0013 下午 4:29
 * @Component: 成都蜗牛学苑
 **/
public class TestIniRealmAuth {
    public static void main(String[] args) {
        //1.读取配置文件,生成一个shiro的环境
        Environment environment = new BasicIniEnvironment("classpath:shiroConfig/shiro-realm.ini");
        //2.通过这个环境，生成默认的SecurityManager对象
        SecurityManager securityManager = environment.getSecurityManager();
        //3.shiro的工具类需要一个SecurityManager的环境
        SecurityUtils.setSecurityManager(securityManager);
        // -----------上面的代码，在后面项目中会通过配置文件搞定，不用记，类似Spring入门的ApplicationContext------------------------------------
        //4.有环境的工具包，将能获取到一个subject对象，然后我们就能使用subject对象来进行业务开发！
        Subject subject = SecurityUtils.getSubject();
        //5.有了主体用户以后，可以直接执行login来进行登录
        subject.login(new UsernamePasswordToken("mayuhang","123456"));
        //进行登录后的判断
        if (subject.isAuthenticated()){
            System.out.println("恭喜"+subject.getPrincipal()+"用户登录成功!");
        }
    }
}
```

1. 开发授权

```java
@Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        //登录认证成功后，从SimpleAuthenticationInfo中取出的校长的信息
        String primaryPrincipal = principals.getPrimaryPrincipal()+"";
        //模拟去数据库中，查出该用户的所有角色和权限，并封装到SimpleAuthorizationInfo中！
        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();
        //添加角色：角色和权限是从哪里来的！
        simpleAuthorizationInfo.addRole("boss");
        simpleAuthorizationInfo.addRole("teacher");
        //添加权限：
        simpleAuthorizationInfo.addStringPermission("eat::person");
        simpleAuthorizationInfo.addStringPermission("yue::ma");
        return simpleAuthorizationInfo;
    }
```

1. 授权测试：

```java
System.out.println("是否有boss的角色："+subject.hasRole("boss"));
        System.out.println("是否有eat::person的权限："+subject.isPermitted("eat::person"));
```

含授权的逻辑示意图:

![image-20220413172521730](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204131725858.png)

# day15 springboot+shiro+jwt项目

## 一、复习

![image-20220414093852565](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204140938697.png)

## 二、基于JWT实现前后端分离的权限管理

### 1. 依赖

```xml
<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
<!--   shiro的启动器     -->
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-spring-boot-starter</artifactId>
            <version>1.7.1</version>
        </dependency>
<!--    JWT java-jwt    -->
        <dependency>
            <groupId>com.auth0</groupId>
            <artifactId>java-jwt</artifactId>
            <version>3.18.2</version>
        </dependency>
<!--    mybatis    -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.2.2</version>
        </dependency>
<!--     mysql驱动   -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
<!--     分页   -->
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper-spring-boot-starter</artifactId>
            <version>1.4.1</version>
        </dependency>
    </dependencies>
```

### 2. JWT工具类(了解)

> 因为我们是前后端分离，认证模式使用的是TokenAuth，然后后续的认证，将不再使用账号密码了也就是Http Basic Auth。
>
> 那么我们就需要封装JWT工具类，用它来帮我创建Token，解析token信息，以及配置过期时间等。

```java
package com.woniuxy.utils;
import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import java.util.Date;
/**
 * @Author: 马宇航
 * @Todo: jwt工具类
 * @DateTime: 22/04/14/0014 上午 10:43
 * @Component: 成都蜗牛学苑
 **/
public class JWTUtils {
//    默认的过期时间 5分钟
    public static final long EXPERING_TIME = 5*60*1000;
    /**
     * 用来生成token字符串！
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 10:45 [马宇航]);
     * @param username 用来存入Claim自定义属性中 密码切记不要放进去，因为jwt中间的body，是明文
     * @param password  昨天配置过一个 woniuxy 签名
     * @return java.lang.String
    */
    public static String sign(String username,String password){
        //通过签名算法，增加解密难度 类似对woniuxy签名加密后 在放进去 排除woniuxy和woniu都可以解析token的情况
        Algorithm algorithm = Algorithm.HMAC256(password);
        //配置一个过期时间
        Date expering_time = new Date(System.currentTimeMillis() + EXPERING_TIME);
        String token = JWT.create().withClaim("username", username)
                .withSubject(username)
                //过期时间
                .withExpiresAt(expering_time)
                .sign(algorithm);
        return token;
    }
    /**
     * 校验你的token是否正确
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 10:55 [马宇航]);
     * @param token 前端传过来的token传
     * @param username 加密的时候用的用户名
     * @param password 加密的时候用的签名
     * @return boolean
    */
    public static boolean verify(String token,String username,String password){
        //通过签名算法，增加解密难度 类似对woniuxy签名加密后 在放进去 排除woniuxy和woniu都可以解析token的情况
        Algorithm algorithm = Algorithm.HMAC256(password);
        //重新计算加密比较来进行校验两个Token是否一样
        JWTVerifier jwtVerifier = JWT.require(algorithm)
                .withClaim("username",username)
                .withSubject(username).build();
        jwtVerifier.verify(token);
        return true;
    }
    /**
     * 从token中取出claim自定义属性 获取username
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 10:59 [马宇航]);
     * @param token
     * @return java.lang.String 用户名
    */
    public static String getUsername(String token){
        DecodedJWT decode = JWT.decode(token);
        //还可以选择使用这个来获取用户名
//        decode.getSubject();
       return decode.getClaim("username").toString();
    }
}
```

### 3. MyJsonWebToken替换UsernamePasswordToken

```java
package com.woniuxy.shiro;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.apache.shiro.authc.AuthenticationToken;
/**
 * @Author: 马宇航
 * @Todo: 替代UsernamePasswordToken，因为我们后期都是使用Token来进行校验的
 * @DateTime: 22/04/14/0014 上午 11:02
 * @Component: 成都蜗牛学苑
 **/
@Data
@NoArgsConstructor
@AllArgsConstructor
public class MyJsonWebToken implements AuthenticationToken {
    String token;
    /**
     * getPrincipal 获取校长
     * 修改这个实体类，改变数据结构，里面存放一个token属性 以后获取校长和凭证直接获取到的是token！
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:04 [马宇航]);
     *
     * @return java.lang.Object
    */
    @Override
    public Object getPrincipal() {
        return token;
    }
    /**
     * Credential这个是凭证
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:05 [马宇航]);
     *
     * @return java.lang.Object
    */
    @Override
    public Object getCredentials() {
        return token;
    }
}
```

### 4. 编写自定义域

> 晚点再补充：无授权方法！
>
> ```java
> package com.woniuxy.shiro;
> import com.woniuxy.entity.RbacManager;
> import com.woniuxy.service.RbacManagerService;
> import com.woniuxy.utils.JWTUtils;
> import org.apache.shiro.authc.AuthenticationException;
> import org.apache.shiro.authc.AuthenticationInfo;
> import org.apache.shiro.authc.AuthenticationToken;
> import org.apache.shiro.authc.SimpleAuthenticationInfo;
> import org.apache.shiro.authz.AuthorizationInfo;
> import org.apache.shiro.authz.SimpleAuthorizationInfo;
> import org.apache.shiro.realm.AuthorizingRealm;
> import org.apache.shiro.subject.PrincipalCollection;
> import org.springframework.beans.factory.annotation.Autowired;
> import org.springframework.context.annotation.Configuration;
> /**
>  * @Author: 马宇航
>  * @Todo: 自定义域: 校验token的有效性！
>  * @DateTime: 22/04/14/0014 上午 11:06
>  * @Component: 成都蜗牛学苑
>  **/
> @Configuration
> public class MyRealm extends AuthorizingRealm {
>     @Autowired
>     RbacManagerService rbacManagerService;
>     @Override
>     public boolean supports(AuthenticationToken token) {
> //        这里是shiro底层的问题，我们要手动重写底层的判断逻辑
>         return token instanceof MyJsonWebToken;
>     }
>     /**
>      * 授权
>      * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:07 [马宇航]);
>      * @param principals JWT的token
>      * @return org.apache.shiro.authz.AuthorizationInfo
>     */
>     @Override
>     protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
>         //通过下面的认证方法SimpleAuthenticationInfo对象中的凭证获取到token的值！
>         String token = principals.getPrimaryPrincipal()+"";
>         String username = JWTUtils.getUsername(token);
>         //使用username去数据库查出你的所有的角色和权限并封装到SimpleAuthorizationInfo
>         return new SimpleAuthorizationInfo();
>     }
>     /**
>      * 认证
>      * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:07 [马宇航]);
>      * @param jwtToken JWT的token 昨天传入的是UsernamePasswordToken
>      * @return org.apache.shiro.authc.AuthenticationInfo
>     */
>     @Override
>     protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken jwtToken) throws AuthenticationException {
>         //通过token获取我们自定义的MyJsonWebToken中存入的token
>         String token = jwtToken.getPrincipal()+"";
>         //从token中拿出用户名 后面篡改token的body值，来尝试，看能够获取到username，不先校验的情况
>         String username = JWTUtils.getUsername(token);
>         if ("".equals(username)){
>             throw new  AuthenticationException("用户信息不对！");
>         }
>         //调用service，查询数据库，获取用户信息
>         RbacManager user = rbacManagerService.findOne(username);
>         boolean verify = JWTUtils.verify(token, username, user.getPassword());
>         if (verify){//说明代码没有问题
>            return new SimpleAuthenticationInfo(token,token,"myRealm");
>         }
>         return null;
>     }
> }
> ```
>
> 

### 5. 过滤器

> 权限，通常都是通过过滤器来进行拦截的，权限，我们必须在进入到controller之前就要进行判断，所以，你只能在filter或者拦截器中进行处理。
>
> 不可能每个controller，写subject.isAuthenticated();来判断是否登录吧？
>
> 我们的登录请求一定要通过自定义域的 登录认证方法来进行校验。
>
> JWT过滤器，仅仅只是为了一件事情，判断请求头中有没有Authorization属性，然后获取这个属性个value值(token)；
>
> 然后执行 subject.login(new MyJsonWebToken()); —->通过自定义域的认证方法，来返回SimplerAuthenticationInfo！
>
> 开发到这里，我们的过滤器还未生效！需要`注册`到Shiro的过滤器链中！下午的，`ShiroConfig`配置文件，就来注册我们的过滤器！
>
> 同时，我们的自定义域也没有生效！
>
> ![image-20220414121004760](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204141210807.png)
>
> ![image-20220414120639381](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204141206510.png)

```java
package com.woniuxy.shiro;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;
import org.springframework.stereotype.Component;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * @Author: 马宇航
 * @Todo: 过滤器 BasicHttpAuthenticationFilter 内部底层有一堆过滤器，来处理请求的消息
 *      重点shiro的相关配置流程：
 *           1.isAccessAllowed 是否允许访问
 *           2.isLoginAttempt 校验请求头中有没有携带token
 *           3.executeLogin
 * @DateTime: 22/04/14/0014 上午 11:32
 * @Component: 成都蜗牛学苑
 **/
@Component
public class JWTFilter extends BasicHttpAuthenticationFilter {
    /**
     * Spring的拦截器:preHandle->controller->postHandler-->view --> afterHandler
     * 这个preHandle通常用来处理跨域的，全局跨域处理
     * 重要的过滤器配置：需要我们自己开发，获取请求头中的信息，然后执行subject.login(new MyJsonWebToken())
     *
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:37 [马宇航]);
     * @param request
     * @param response
     * @return boolean
    */
    @Override
    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        HttpServletResponse httpServletResponse = (HttpServletResponse) response;
        httpServletResponse.setHeader("Access-control-Allow-Origin", httpServletRequest.getHeader("Origin"));
        httpServletResponse.setHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS,PUT,DELETE");
        httpServletResponse.setHeader("Access-Control-Allow-Headers", httpServletRequest.getHeader("Access-Control-Request-Headers"));
        // 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态
//        if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) {
//            httpServletResponse.setStatus(HttpStatus.OK.value());
//            return false;
//        }
        return super.preHandle(request, response);
    }
    /**
     * 做条件判断，是否允许访问后端，也就是看你请求头有没有带上token
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:42 [马宇航]);
     * @param request
     * @param response
     * @param mappedValue
     * @return boolean
    */
    @Override
    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {
        //判断请求头有没有信息
        if (isLoginAttempt(request,response)){
            try {
                //执行登录操作
                executeLogin(request,response);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        else {
            // 如果请求头中没有token ，我们应该跳转后台的controller返回一个信息给前端，告诉他还没有登录 401 没有权限
            return false;
        }
        return true;
    }
    /**
     * 重写shiro底层过滤器流程：这个方法主要是判断请求头中有没有token信息
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:45 [马宇航]);
     * @param request
     * @param response
     * @return boolean
    */
    @Override
    protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) {
        HttpServletRequest request1 = (HttpServletRequest) request;
        //从请求头中获取token信息，Authorization 就是自定义的key！
        String token = request1.getHeader("Authorization");
        return token == null?false:true;
    }
    /**
     * 需要执行的是我们自定义的MyJsonWebToken 实体类的校验
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:50 [马宇航]);
     * @param request
     * @param response
     * @return boolean
    */
    @Override
    protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception {
        HttpServletRequest request1 = (HttpServletRequest) request;
        //从请求头中获取token信息，Authorization 就是自定义的key！
        String token = request1.getHeader("Authorization");
        Subject subject = getSubject(request, response);
        MyJsonWebToken myJsonWebToken = new MyJsonWebToken(token);
        try {
            subject.login(myJsonWebToken);
            //执行登录如果不报错，为true就放行
            return true;
        } catch (AuthenticationException e) {
            //false之前要拦截 进入到我们自定义的 controller 401中！
            return false;
        }
    }
}
```

### 6. 核心ShiroConfig

> java config：[@Bean](https://github.com/Bean)这种配置方式！

```java
package com.woniuxy.shiro;
import org.apache.shiro.spring.LifecycleBeanPostProcessor;
import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.DependsOn;
import javax.servlet.Filter;
import java.util.HashMap;
import java.util.Map;
/**
 * @Author: 马宇航
 * @Todo: Shiro的核心配置类，SecurityManager必须要有，基于web的安全管理器；
 *         过滤器的注册！
 * @DateTime: 22/04/14/0014 下午 2:02
 * @Component: 成都蜗牛学苑
 **/
@Configuration
public class ShiroConfig {
    /**
     * 基于web环境，创建一个securityManager的bean对象
     * ChangeLog : 1. 创建 (22/04/14/0014 下午 2:09 [马宇航]);
     * @param myRealm
     * @return org.apache.shiro.web.mgt.DefaultWebSecurityManager
    */
    @Bean
    public DefaultWebSecurityManager securityManager(MyRealm myRealm){
        return new DefaultWebSecurityManager(myRealm);
    }
    /**
     * 这里是配置过滤器的注册！
     * ChangeLog : 1. 创建 (22/04/14/0014 下午 2:15 [马宇航]);
     * @param securityManager 上面的@Bean DefaultWebSecurityManager对象
     * @return org.apache.shiro.spring.web.ShiroFilterFactoryBean
    */
    @Bean
    public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager securityManager){
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        //先配置安全管理器
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        //配置过滤器，自定义的jwt过滤器
        Map<String, Filter> filterMap = new HashMap<>();
        //注册一个名字叫做jwt的过滤器
        filterMap.put("jwt",new JWTFilter());
        shiroFilterFactoryBean.setFilters(filterMap);
        //配置过滤器链的生效 顺序
        Map<String,String> filterChainDefinitionMap = new HashMap<>();
        //过滤器链的过滤规则，url作为key，jwt作为值，底层会自动帮我根据jwt名字，去找到对应的过滤器
        /**
         * key：表示访问的链接，支持通配符，它是个表达式！
         * value表示 过滤器的类型名称；shiro自带了一堆过滤器！
         * 常用的有 anon ：匿名访问
         *         authc:需要认证后才能访问
        **/
        filterChainDefinitionMap.put("/login","anon");
        filterChainDefinitionMap.put("/**","jwt");
        //暂时先不写其他的规则
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }
    /**
     * 处理springboot和shiro之间的bug，引起的一个动态代理的bug
     * ChangeLog : 1. 创建 (22/04/14/0014 下午 2:42 [马宇航]);
     *
     * @return org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator
    */
    @Bean
    @DependsOn("lifecycleBeanPostProcessor")
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {
        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();
        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);
        return defaultAdvisorAutoProxyCreator;
    }
    //开启切面相关的内容
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager){
        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();
        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);
        return authorizationAttributeSourceAdvisor;
    }
    @Bean("lifecycleBeanPostProcessor")
    public LifecycleBeanPostProcessor lifecycleBeanPostProces(){
        return new LifecycleBeanPostProcessor();
    }
}
```

常见的shiro的过滤器：

![img](https://woniuxyopenfile.oss-cn-beijing.aliyuncs.com/woniuxynote/classNoteMd/202012011139/%E5%9B%BE%E7%89%871.png)

### 7. 登录方法(单独)

自定义的登录方法，该方法我们单独写，不要去用shiro的东西！

> ShiroConfig中，过滤器链配置了/login ，anon； 对login的url请求，匿名放行，所以不会走filter过滤器！

```java
package com.woniuxy.controller;
import com.woniuxy.entity.RbacManager;
import com.woniuxy.entity.ResponseEntity;
import com.woniuxy.service.RbacManagerService;
import com.woniuxy.service.impl.RbacManagerServiceImpl;
import com.woniuxy.utils.JWTUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
/**
 * @Author: 马宇航
 * @Todo: 登录用
 * @DateTime: 22/04/14/0014 下午 2:33
 * @Component: 成都蜗牛学苑
 **/
@RestController
public class LoginController {
    @Autowired
    RbacManagerService rbacManagerService;
    @RequestMapping("/login")
    public ResponseEntity login(String username,String password){
        RbacManager rbacManager = rbacManagerService.login(username, password);
        if (!StringUtils.isEmpty(rbacManager)){
            //就说明查出了用户数据
            String token =  JWTUtils.sign(username, password);
            return new ResponseEntity<>(200,"登录成功",token);
        }else {
            return ResponseEntity.FAIL;
        }
    }
    @RequestMapping("/401")
    public ResponseEntity response401(){
        return new ResponseEntity(401,"认证异常！",null);
    }
}
```

# day16 shiro前后端分离配置

## 一、基于JWT实现前后端分离的权限管理

### 1. 依赖

```xml
<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
<!--   shiro的启动器     -->
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-spring-boot-starter</artifactId>
            <version>1.7.1</version>
        </dependency>
<!--    JWT java-jwt    -->
        <dependency>
            <groupId>com.auth0</groupId>
            <artifactId>java-jwt</artifactId>
            <version>3.18.2</version>
        </dependency>
<!--    mybatis    -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.2.2</version>
        </dependency>
<!--     mysql驱动   -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
<!--     分页   -->
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper-spring-boot-starter</artifactId>
            <version>1.4.1</version>
        </dependency>
    </dependencies>
```

### 2. JWT工具类(了解)

> 因为我们是前后端分离，认证模式使用的是TokenAuth，然后后续的认证，将不再使用账号密码了也就是Http Basic Auth。
>
> 那么我们就需要封装JWT工具类，用它来帮我创建Token，解析token信息，以及配置过期时间等。

```java
package com.woniuxy.utils;
import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import java.util.Date;
/**
 * @Author: 马宇航
 * @Todo: jwt工具类
 * @DateTime: 22/04/14/0014 上午 10:43
 * @Component: 成都蜗牛学苑
 **/
public class JWTUtils {
//    默认的过期时间 5分钟
    public static final long EXPERING_TIME = 5*60*1000;
    /**
     * 用来生成token字符串！
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 10:45 [马宇航]);
     * @param username 用来存入Claim自定义属性中 密码切记不要放进去，因为jwt中间的body，是明文
     * @param password  昨天配置过一个 woniuxy 签名
     * @return java.lang.String
    */
    public static String sign(String username,String password){
        //通过签名算法，增加解密难度 类似对woniuxy签名加密后 在放进去 排除woniuxy和woniu都可以解析token的情况
        Algorithm algorithm = Algorithm.HMAC256(password);
        //配置一个过期时间
        Date expering_time = new Date(System.currentTimeMillis() + EXPERING_TIME);
        String token = JWT.create().withClaim("username", username)
                .withSubject(username)
                //过期时间
                .withExpiresAt(expering_time)
                .sign(algorithm);
        return token;
    }
    /**
     * 校验你的token是否正确
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 10:55 [马宇航]);
     * @param token 前端传过来的token传
     * @param username 加密的时候用的用户名
     * @param password 加密的时候用的签名
     * @return boolean
    */
    public static boolean verify(String token,String username,String password){
        //通过签名算法，增加解密难度 类似对woniuxy签名加密后 在放进去 排除woniuxy和woniu都可以解析token的情况
        Algorithm algorithm = Algorithm.HMAC256(password);
        //重新计算加密比较来进行校验两个Token是否一样
        JWTVerifier jwtVerifier = JWT.require(algorithm)
                .withClaim("username",username)
                .withSubject(username).build();
        jwtVerifier.verify(token);
        return true;
    }
    /**
     * 从token中取出claim自定义属性 获取username
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 10:59 [马宇航]);
     * @param token
     * @return java.lang.String 用户名
    */
    public static String getUsername(String token){
        DecodedJWT decode = JWT.decode(token);
        //还可以选择使用这个来获取用户名
//        decode.getSubject();
       return decode.getClaim("username").toString();
    }
}
```

### 3. MyJsonWebToken替换UsernamePasswordToken

```java
package com.woniuxy.shiro;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.apache.shiro.authc.AuthenticationToken;
/**
 * @Author: 马宇航
 * @Todo: 替代UsernamePasswordToken，因为我们后期都是使用Token来进行校验的
 * @DateTime: 22/04/14/0014 上午 11:02
 * @Component: 成都蜗牛学苑
 **/
@Data
@NoArgsConstructor
@AllArgsConstructor
public class MyJsonWebToken implements AuthenticationToken {
    String token;
    /**
     * getPrincipal 获取校长
     * 修改这个实体类，改变数据结构，里面存放一个token属性 以后获取校长和凭证直接获取到的是token！
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:04 [马宇航]);
     *
     * @return java.lang.Object
    */
    @Override
    public Object getPrincipal() {
        return token;
    }
    /**
     * Credential这个是凭证
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:05 [马宇航]);
     *
     * @return java.lang.Object
    */
    @Override
    public Object getCredentials() {
        return token;
    }
}
```

### 4. 编写自定义域

```java
package com.woniuxy.shiro;
import com.woniuxy.entity.RbacManager;
import com.woniuxy.service.RbacManagerService;
import com.woniuxy.service.RbacPermService;
import com.woniuxy.service.RbacRoleService;
import com.woniuxy.utils.JWTUtils;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import java.util.Set;
/**
 * @Author: 马宇航
 * @Todo: 自定义域: 校验token的有效性！
 * @DateTime: 22/04/14/0014 上午 11:06
 * @Component: 成都蜗牛学苑
 **/
@Configuration
public class MyRealm extends AuthorizingRealm {
    @Autowired
    RbacManagerService rbacManagerService;
    @Autowired
    RbacRoleService rbacRoleService;
    @Autowired
    RbacPermService rbacPermService;
    @Override
    public boolean supports(AuthenticationToken token) {
//        这里是shiro底层的问题，我们要手动重写底层的判断逻辑
        return token instanceof MyJsonWebToken;
    }
    /**
     * 授权
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:07 [马宇航]);
     * @param principals JWT的token
     * @return org.apache.shiro.authz.AuthorizationInfo
    */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        //通过下面的认证方法SimpleAuthenticationInfo对象中的凭证获取到token的值！
        String token = principals.getPrimaryPrincipal()+"";
        String username = JWTUtils.getUsername(token);
        //使用username去数据库查出你的所有的角色和权限并封装到SimpleAuthorizationInfo
        //查询当前登录的subject用户的角色
        String roleName = rbacRoleService.findByRbacManager(username);
        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();
        simpleAuthorizationInfo.addRole(roleName);
        //查询当前登录的subject的权限集合
        Set<String> perms = rbacPermService.findByUsername(username);
        simpleAuthorizationInfo.setStringPermissions(perms);
        return simpleAuthorizationInfo;
    }
    /**
     * 认证
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:07 [马宇航]);
     * @param jwtToken JWT的token 昨天传入的是UsernamePasswordToken
     * @return org.apache.shiro.authc.AuthenticationInfo
    */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken jwtToken) throws AuthenticationException {
        //通过token获取我们自定义的MyJsonWebToken中存入的token
        String token = jwtToken.getPrincipal()+"";
        //从token中拿出用户名 后面篡改token的body值，来尝试，看能够获取到username，不先校验的情况
        String username = JWTUtils.getUsername(token);
        if ("".equals(username)){
            throw new  AuthenticationException("用户信息不对！");
        }
        //调用service，查询数据库，获取用户信息
        RbacManager user = rbacManagerService.findOne(username);
        boolean verify = JWTUtils.verify(token, username, user.getPassword());
        if (verify){//说明代码没有问题
           return new SimpleAuthenticationInfo(token,token,"myRealm");
        }
        return null;
    }
}
```

### 5. 过滤器

> 权限，通常都是通过过滤器来进行拦截的，权限，我们必须在进入到controller之前就要进行判断，所以，你只能在filter或者拦截器中进行处理。
>
> 不可能每个controller，写subject.isAuthenticated();来判断是否登录吧？
>
> 我们的登录请求一定要通过自定义域的 登录认证方法来进行校验。
>
> JWT过滤器，仅仅只是为了一件事情，判断请求头中有没有Authorization属性，然后获取这个属性个value值(token)；
>
> 然后执行 subject.login(new MyJsonWebToken()); —->通过自定义域的认证方法，来返回SimplerAuthenticationInfo！
>
> 开发到这里，我们的过滤器还未生效！需要`注册`到Shiro的过滤器链中！下午的，`ShiroConfig`配置文件，就来注册我们的过滤器！
>
> 同时，我们的自定义域也没有生效！
>
> ![image-20220414121004760](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204141210807.png)
>
> ![image-20220414120639381](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204141206510.png)

```java
package com.woniuxy.shiro;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;
import org.springframework.stereotype.Component;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * @Author: 马宇航
 * @Todo: 过滤器 BasicHttpAuthenticationFilter 内部底层有一堆过滤器，来处理请求的消息
 *      重点shiro的相关配置流程：
 *           1.isAccessAllowed 是否允许访问
 *           2.isLoginAttempt 校验请求头中有没有携带token
 *           3.executeLogin
 * @DateTime: 22/04/14/0014 上午 11:32
 * @Component: 成都蜗牛学苑
 **/
@Component
public class JWTFilter extends BasicHttpAuthenticationFilter {
    /**
     * Spring的拦截器:preHandle->controller->postHandler-->view --> afterHandler
     * 这个preHandle通常用来处理跨域的，全局跨域处理
     * 重要的过滤器配置：需要我们自己开发，获取请求头中的信息，然后执行subject.login(new MyJsonWebToken())
     *
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:37 [马宇航]);
     * @param request
     * @param response
     * @return boolean
    */
    @Override
    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        HttpServletResponse httpServletResponse = (HttpServletResponse) response;
        httpServletResponse.setHeader("Access-control-Allow-Origin", httpServletRequest.getHeader("Origin"));
        httpServletResponse.setHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS,PUT,DELETE");
        httpServletResponse.setHeader("Access-Control-Allow-Headers", httpServletRequest.getHeader("Access-Control-Request-Headers"));
        // 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态
//        if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) {
//            httpServletResponse.setStatus(HttpStatus.OK.value());
//            return false;
//        }
        return super.preHandle(request, response);
    }
    /**
     * 做条件判断，是否允许访问后端，也就是看你请求头有没有带上token
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:42 [马宇航]);
     * @param request
     * @param response
     * @param mappedValue
     * @return boolean
    */
    @Override
    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {
        //判断请求头有没有信息
        if (isLoginAttempt(request,response)){
            try {
                //执行登录操作
                executeLogin(request,response);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        else {
            // 如果请求头中没有token ，我们应该跳转后台的controller返回一个信息给前端，告诉他还没有登录 401 没有权限
            return false;
        }
        return true;
    }
    /**
     * 重写shiro底层过滤器流程：这个方法主要是判断请求头中有没有token信息
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:45 [马宇航]);
     * @param request
     * @param response
     * @return boolean
    */
    @Override
    protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) {
        HttpServletRequest request1 = (HttpServletRequest) request;
        //从请求头中获取token信息，Authorization 就是自定义的key！
        String token = request1.getHeader("Authorization");
        return token == null?false:true;
    }
    /**
     * 需要执行的是我们自定义的MyJsonWebToken 实体类的校验
     * ChangeLog : 1. 创建 (22/04/14/0014 上午 11:50 [马宇航]);
     * @param request
     * @param response
     * @return boolean
    */
    @Override
    protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception {
        HttpServletRequest request1 = (HttpServletRequest) request;
        //从请求头中获取token信息，Authorization 就是自定义的key！
        String token = request1.getHeader("Authorization");
        Subject subject = getSubject(request, response);
        MyJsonWebToken myJsonWebToken = new MyJsonWebToken(token);
        try {
            subject.login(myJsonWebToken);
            //执行登录如果不报错，为true就放行
            return true;
        } catch (AuthenticationException e) {
            //false之前要拦截 进入到我们自定义的 controller 401中！
            return false;
        }
    }
}
```

### 6. 核心ShiroConfig

> java config：[@Bean](https://github.com/Bean)这种配置方式！

```java
package com.woniuxy.shiro;
import org.apache.shiro.spring.LifecycleBeanPostProcessor;
import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.DependsOn;
import javax.servlet.Filter;
import java.util.HashMap;
import java.util.Map;
/**
 * @Author: 马宇航
 * @Todo: Shiro的核心配置类，SecurityManager必须要有，基于web的安全管理器；
 *         过滤器的注册！
 * @DateTime: 22/04/14/0014 下午 2:02
 * @Component: 成都蜗牛学苑
 **/
@Configuration
public class ShiroConfig {
    /**
     * 基于web环境，创建一个securityManager的bean对象
     * ChangeLog : 1. 创建 (22/04/14/0014 下午 2:09 [马宇航]);
     * @param myRealm
     * @return org.apache.shiro.web.mgt.DefaultWebSecurityManager
    */
    @Bean
    public DefaultWebSecurityManager securityManager(MyRealm myRealm){
        return new DefaultWebSecurityManager(myRealm);
    }
    /**
     * 这里是配置过滤器的注册！
     * ChangeLog : 1. 创建 (22/04/14/0014 下午 2:15 [马宇航]);
     * @param securityManager 上面的@Bean DefaultWebSecurityManager对象
     * @return org.apache.shiro.spring.web.ShiroFilterFactoryBean
    */
    @Bean
    public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager securityManager){
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        //先配置安全管理器
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        //配置过滤器，自定义的jwt过滤器
        Map<String, Filter> filterMap = new HashMap<>();
        //注册一个名字叫做jwt的过滤器
        filterMap.put("jwt",new JWTFilter());
        shiroFilterFactoryBean.setFilters(filterMap);
        //配置过滤器链的生效 顺序
        Map<String,String> filterChainDefinitionMap = new HashMap<>();
        //过滤器链的过滤规则，url作为key，jwt作为值，底层会自动帮我根据jwt名字，去找到对应的过滤器
        /**
         * key：表示访问的链接，支持通配符，它是个表达式！
         * value表示 过滤器的类型名称；shiro自带了一堆过滤器！
         * 常用的有 anon ：匿名访问
         *         authc:需要认证后才能访问
        **/
        filterChainDefinitionMap.put("/login","anon");
        filterChainDefinitionMap.put("/**","jwt");
        //暂时先不写其他的规则
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }
    /**
     * 处理springboot和shiro之间的bug，引起的一个动态代理的bug
     * ChangeLog : 1. 创建 (22/04/14/0014 下午 2:42 [马宇航]);
     *
     * @return org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator
    */
    @Bean
    @DependsOn("lifecycleBeanPostProcessor")
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {
        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();
        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);
        return defaultAdvisorAutoProxyCreator;
    }
    //开启切面相关的内容
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager){
        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();
        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);
        return authorizationAttributeSourceAdvisor;
    }
    @Bean("lifecycleBeanPostProcessor")
    public LifecycleBeanPostProcessor lifecycleBeanPostProces(){
        return new LifecycleBeanPostProcessor();
    }
}
```

常见的shiro的过滤器：

![img](https://woniuxyopenfile.oss-cn-beijing.aliyuncs.com/woniuxynote/classNoteMd/202012011139/%E5%9B%BE%E7%89%871.png)

### 7. 登录方法(单独)

自定义的登录方法，该方法我们单独写，不要去用shiro的东西！

> ShiroConfig中，过滤器链配置了/login ，anon； 对login的url请求，匿名放行，所以不会走filter过滤器！

```java
package com.woniuxy.controller;
import com.woniuxy.entity.RbacManager;
import com.woniuxy.entity.ResponseEntity;
import com.woniuxy.service.RbacManagerService;
import com.woniuxy.service.impl.RbacManagerServiceImpl;
import com.woniuxy.utils.JWTUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
/**
 * @Author: 马宇航
 * @Todo: 登录用
 * @DateTime: 22/04/14/0014 下午 2:33
 * @Component: 成都蜗牛学苑
 **/
@RestController
public class LoginController {
    @Autowired
    RbacManagerService rbacManagerService;
    @RequestMapping("/login")
    public ResponseEntity login(String username,String password){
        RbacManager rbacManager = rbacManagerService.login(username, password);
        if (!StringUtils.isEmpty(rbacManager)){
            //就说明查出了用户数据
            String token =  JWTUtils.sign(username, password);
            return new ResponseEntity<>(200,"登录成功",token);
        }else {
            return ResponseEntity.FAIL;
        }
    }
    @RequestMapping("/401")
    public ResponseEntity response401(){
        return new ResponseEntity(401,"认证异常！",null);
    }
}
```

### 8. 全局异常

```java
package com.woniuxy.exception;
import com.woniuxy.entity.ResponseEntity;
import org.apache.shiro.ShiroException;
import org.apache.shiro.authz.UnauthorizedException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import javax.servlet.http.HttpServletRequest;
/**
 * @Author: 马宇航
 * @Todo: 全局异常类
 * @DateTime: 22/04/15/0015 上午 11:24
 * @Component: 成都蜗牛学苑
 **/
@RestControllerAdvice
public class GlobalDefaultExceptionHandler {
    // 捕捉shiro的异常
    @ResponseStatus(HttpStatus.UNAUTHORIZED)
    @ExceptionHandler(ShiroException.class)
    public ResponseEntity handle401(ShiroException e) {
        return new ResponseEntity(401, e.getMessage(), null);
    }
    // 捕捉UnauthorizedException
    @ResponseStatus(HttpStatus.UNAUTHORIZED)
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity handle401() {
        return new ResponseEntity(401, "Unauthorized", null);
    }
    // 捕捉其他所有异常
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ResponseEntity globalException(HttpServletRequest request, Throwable ex) {
        return new ResponseEntity(getStatus(request).value(), ex.getMessage(), null);
    }
    private HttpStatus getStatus(HttpServletRequest request) {
        Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
        if (statusCode == null) {
            return HttpStatus.INTERNAL_SERVER_ERROR;
        }
        return HttpStatus.valueOf(statusCode);
    }
}
```

## 二、shiro的后端流程

![image-20220415115533885](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204151155077.png)

> 先登录获取token，请求头携带上token，访问剩余业务。

## 三、前端集成

初始版本，使用的是git的现成vue项目：https://gitee.com/nmgwap/vueproject?_from=gitee_search vue-element模板

推荐可以自己研究`若依`的前端，也包含后端，微服务等项目。

### 1. 前端准备-登录

> 登录操作，包含了token的接收，并存储到浏览器的本地缓存中。

![image-20220415162406557](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204151624739.png)

### 2. 前端跨域配置

config/index.js:

![image-20220415162540870](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204151625018.png)

### 3. 请求头拼接Authorization参数

main.js配置：

![image-20220415162658726](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204151626804.png)

### 4. 基于模板修改一个页面的CRUD

步骤：

1. 赋值一个模板页面出来，修改文件名。
2. 注册route路由，router/index.js文件中
3. 配置菜单，确保菜单名字，和对应路由的url
4. 至此，浏览器登录后，就能通过菜单访问我们的页面。

完善我们完善的模板页面。

> 需要同学们完成的任务：
>
> 1.完善页面的CRUD操作，可以copy之前做过的代码
> 2.完善角色下拉框组件，角色不允许使用文本来显示，我需要下拉框来切换不同的角色，点击保存就生效
> 3.编辑操作保存后，请一定要使用动态sql来实现这个效果，不要写死！
>
> 4.前后端分离，请求头携带token，关闭后端跨域，用前端跨域。
>
> 5.优先跟上我的代码。熟练度低没关系，就是因为熟练度低，速度慢，才让同学们去写，如果很熟练了，就没有练习的必要了。

```vue
/**
 * 基础菜单 用户管理
 */
<template>
  <div>
    <!-- 面包屑导航 -->
    <el-breadcrumb separator-class="el-icon-arrow-right">
      <el-breadcrumb-item :to="{ path: '/' }">首页</el-breadcrumb-item>
      <el-breadcrumb-item>用户管理</el-breadcrumb-item>
    </el-breadcrumb>
    <!-- 搜索筛选 -->
    <el-form :inline="true" class="user-search">
      <el-form-item label="搜索：">
        <el-input size="small" v-model="formInline.account" placeholder="输入用户账号"></el-input>
      </el-form-item>
      <el-form-item label="">
        <el-input size="small" v-model="formInline.status" placeholder="输入用户状态"></el-input>
      </el-form-item>
      <el-form-item>
        <el-button size="small" type="primary" icon="el-icon-search" @click="search(true)">搜索</el-button>
        <el-button size="small" type="primary" icon="el-icon-plus" @click="handleEdit()">添加</el-button>
      </el-form-item>
    </el-form>
    <!--列表-->
    <el-table size="small" :data="listData" highlight-current-row v-loading="loading" border element-loading-text="拼命加载中" style="width: 100%;">
      <el-table-column align="center" type="selection" width="60">
      </el-table-column>
      <el-table-column sortable prop="id" label="用户id" width="100">
      </el-table-column>
      <el-table-column sortable prop="account" label="用户账号" width="200">
      </el-table-column>
      <el-table-column sortable prop="password" label="用户密码" width="200">
      </el-table-column>
      <!-- <el-table-column sortable prop="status" label="用户状态" width="200">
      </el-table-column> -->
      <el-table-column sortable label="用户状态" width="200">
        <template slot-scope="scope">
          <div>
            <oneSwitch :SwitchStatus="scope.row.status" :SwitchDisabled="true"></oneSwitch>
          </div>
        </template>
      </el-table-column>
      

      <el-table-column sortable prop="roleName" label="角色信息" width="300">
      </el-table-column>
      <el-table-column align="center" label="操作" min-width="200">
        <template slot-scope="scope">
          <el-button size="mini" @click="handleEdit(scope.$index, scope.row)">编辑</el-button>
          <el-button size="mini" type="danger" @click="deleteUser(scope.$index, scope.row)">删除</el-button>
        </template>
      </el-table-column>
    </el-table>
    <!-- 分页组件 -->
    <Pagination v-bind:child-msg="pageparm" @callFather="callFather"></Pagination>
    <!-- 编辑界面 -->
    <el-dialog :title="title" :visible.sync="editFormVisible" width="30%" @click="closeDialog">
      <el-form label-width="120px" :model="editForm" ref="editForm">
        <el-form-item label="用户账号" prop="account">
          <el-input size="small" v-model="editForm.account" auto-complete="off" placeholder="请输入用户账号"></el-input>
        </el-form-item>
        <el-form-item label="用户密码" prop="password">
          <el-input size="small" v-model="editForm.password" auto-complete="off" placeholder="请输入用户密码"></el-input>
        </el-form-item>
        <el-form-item label="用户状态" prop="status">
        <oneSwitch :SwitchStatus="editForm.status" @changeSwitch="changeSwitch"></oneSwitch>
        </el-form-item>
        <el-form-item label="角色信息" prop="roleName">
          <!-- <el-input size="small" v-model="editForm.role_id" auto-complete="off" placeholder="请输入角色信息"></el-input> -->
          <oneSelect :fuvalue="editForm.role_id" @changeSelect="changeSelect"></oneSelect>
        </el-form-item>
      </el-form>
      <div slot="footer" class="dialog-footer">
        <el-button size="small" @click="closeDialog">取消</el-button>
        <el-button size="small" type="primary" :loading="loading" class="title" @click="submitForm('editForm')">保存</el-button>
      </div>
    </el-dialog>
  </div>
</template>

<script>
import { deptList, deptSave, deptDelete } from '../../api/userMG'
import Pagination from '../../components/Pagination'
import oneSwitch from '../../components/switch.vue'
import oneSelect from '../../components/select.vue'
export default {
  data() {
    return {
      nshow: true, //switch开启
      fshow: false, //switch关闭
      loading: false, //是显示加载
      editFormVisible: false, //控制编辑页面显示与隐藏
      title: '添加',
      editForm: {
        id: '',
        account: '',
        password: '',
        status: '',
        role_id: '',
        roleName: '',
        token: localStorage.getItem('logintoken')
      },
      formInline: {
        page: 1,
        limit: 5,
        token: localStorage.getItem('logintoken'),
        account: '',
        status: ''
      },
      // 删除部门
      seletedata: {
        ids: '',
        token: localStorage.getItem('logintoken')
      },
      userparm: [], //搜索权限
      listData: [], //用户数据
      // 分页参数
      pageparm: {
        currentPage: 1,
        pageSize: 5,
        total: 10
      }
    }
  },
  // 注册组件
  components: {
    Pagination,
    oneSwitch,
    oneSelect
  },
  /**
   * 数据发生改变
   */

  /**
   * 创建完毕
   */
  created() {
    this.getdata(this.formInline)
  },
  watch: {
    $route(to, from) {
      console.log(to, from);
      if (to === '/rbacManager') {
        to.path('/rbacManager')
      }
    },
  },
  /**
   * 里面的方法只有被调用才会执行
   */
  methods: {
    // 获取列表
    getdata(parameter) {
      this.loading = true

      /***
       * 调用接口，注释上面模拟数据 取消下面注释
       */
      //deptList(parameter)
      //console.log(this.pageparm.pageSize,this.pageparm.currentPage);
      
      this.$axios.get("/api/rbacManager/manager/" + this.pageparm.pageSize + "/" + this.pageparm.currentPage)
      .then(res => {
        this.loading = false
        console.log(res);
        if (res.success == false) {
          this.$message({
            type: 'info',
            message: res.msg
          })
        } else {
          this.listData = res.data.data.list
          // 分页赋值
          this.pageparm.currentPage = this.formInline.page
          this.pageparm.pageSize = this.formInline.limit
          this.pageparm.total = res.data.data.total
        }
      })
      .catch(err => {
        this.loading = false
        this.$message.error('菜单加载失败，请稍后再试！')
      })
      
      
    },
    // 分页插件事件
    callFather(parm) {
      this.formInline.page = parm.currentPage
      this.formInline.limit = parm.pageSize
      this.pageparm.currentPage = parm.currentPage
      this.pageparm.pageSize = parm.pageSize
      if (this.formInline.account != '' || this.formInline.status != '') {
        this.search(false);
      }else{
        this.getdata(this.formInline)

      }
    },
    // 搜索事件
    search(flag) {
      //如果搜索项没有东西，就是查找所有数据
      if (this.formInline.account == '' && this.formInline.status == '') {
        this.getdata(this.formInline)
        return
      }
      
      console.log("前端传的数据",this.formInline);
      this.$axios.post("/api/rbacManager/search/",this.formInline)
      .then((res) => {
          console.log(res);
          if (res.data.code == 200) {
            if (flag) {
              this.$message({
              showClose: true,
              message: '查询成功！',
              type: 'success'
            });
            }
            
            this.listData = res.data.data.list;
            this.pageparm.total = res.data.data.total;
            this.pageparm.currentPage = this.formInline.page;
            this.pageparm.pageSize = this.formInline.limit;

          }else{
            this.$message({
              showClose: true,
              message: res.data.status,
              type: 'info'
            });
            this.listData = [];
            this.pageparm.total = 0;
          }
        }).catch(() => {
          //this.getdata(this.formInline)
        });


      
        
 
    },
    //显示编辑界面
    handleEdit: function(index, row) {
      this.editFormVisible = true
      if (row != undefined && row != 'undefined') {
        this.title = '修改'
        this.editForm.id = row.id
        this.editForm.account = row.account
        this.editForm.password = row.password
        this.editForm.status = row.status
        this.editForm.role_id = row.role_id
      } else {
        this.title = '添加'
        this.editForm.id = ''
        this.editForm.account = ''
        this.editForm.password = ''
        this.editForm.status = 'n'
        this.editForm.role_id = ''
      }
    },
    // 编辑、增加页面保存方法
    submitForm(editData) {
      if (this.editForm.account==="" || this.editForm.password==="" || this.editForm.status==="" || this.editForm.role_id==="") {
        this.$message({
              showClose: true,
              message: '内容不能为空！',
              type: 'warning'
            });
      } else {
        this.$axios.post("/api/rbacManager/manager/",this.editForm)
              .then(res => {
                this.editFormVisible = false
                this.loading = false
                if (res.data.code==200) {
                  this.getdata(this.formInline)
                  this.$message({
                    type: 'success',
                    message: '保存成功！'
                  })
                } else {
                  this.$message({
                    type: 'info',
                    message: res.msg
                  })
                }
              })
              .catch(() => {});
        this.editFormVisible=false
      }
        
    },
    // 删除用户
    deleteUser(index, row) {
      this.$confirm('确定要删除吗?', '信息', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        //点击确认
        this.$axios.delete("/api/rbacManager/manager/"+row.id)
        .then((res) => {
          if (res.data.code == 200) {
            this.$message({
              showClose: true,
              message: '删除成功！',
              type: 'success'
            });
            this.getdata(this.formInline)
          }
        })
        .catch(() => {
          this.$message({
            type: 'info',
            message: '删除失败！'
          })
        })
      })
      .catch(() => {
        //点击取消
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
        
      
    },
    // 关闭编辑、增加弹出框
    closeDialog() {
      this.editFormVisible = false
    },
    //子传父 switch开关触发事件
    changeSwitch(e){
        this.editForm.status = e
    },
    changeSelect(e){
      console.log(e);
        this.editForm.role_id = e
    }
  }
}
</script>

<style scoped>
.user-search {
  margin-top: 20px;
}
.userRole {
  width: 100%;
}
</style>

 
 
```



day17 权限菜单

# day17 权限菜单

## 1、行业解决方案

1. 前端递归，前端实现菜单的递归查询显示！

> 后端查询整个菜单表发送到前端即可。
>
> 前端自己递归渲染整个菜单的层级结构。

1. 后端递归。

> 基于Mybaits的resultMap标签来实现的sql递归查询。
>
> ```
> 不允许使用for循环内部部允许执行sql语句，递归查询子菜单这种行为也不行。
> ```

service层调用一个方法，mybaits内部，再调用自己定义的新的方法，来实现递归。

并非通过java代码实现的递归。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.woniuxy.dao.RbacMenuDao">
<!-- 使用递归来进行菜单查询 -->
    <resultMap id="rbacMenuList" type="com.woniuxy.entity.RbacMenu">
        <id column="id" property="menuid"/>
        <result column="icon" property="icon"/>
        <result column="menuname" property="menuname"/>
        <result column="url" property="url"/>
        <!-- 递归查询必然是一个 一对多的关系   -->
        <collection property="menus" select="findChildren" column="id" autoMapping="true"/>
    </resultMap>
<!-- 第一个findAll 主表数据，第一次的时候，正常查询 ：肯定是查询 一级菜单  -->
    <select id="findAll"  resultMap="rbacMenuList">
        select * from rbac_menu where fid is null
    </select>
<!--  根据resultmap的collection标签下的select属性，来决定该方法的执行。内部会持续递归下去！  -->
    <select id="findChildren" resultMap="rbacMenuList">
        select * from rbac_menu where fid = #{id}
    </select>
</mapper>
```

![image-20220418141526313](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204181415429.png)

不仅仅是菜单，未来开发的任何的`下拉框`(多层级)，都可以使用这个方案来处理。

只要数据库是这样设计的，都可以使用这套方案来处理。

![image-20220418142002903](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204181420956.png)

## 2、前端菜单组件化

> 目的：
>
> 因为要`复用`！很多地方都会有这个菜单的下拉列表，比如，菜单管理界面，角色绑定菜单设置页面。
>
> 未来开发，同学们也必须考虑复用问题。

具体前后端代码，参考day17的git提交记录。

后台代码：

![image-20220418175740776](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204181757889.png)

day19 linux与redis主从哨兵

# day19 linux

## 一、复习

![image-20220420093013191](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204200930275.png)

## 二、Linux介绍

Linux操作系统是基于UNIX操作系统(UNIX ，是一个强大的多用户、多任务操作系统，支持多种处理器架构)发展而来的一种克隆系统，它诞生于1991 年的 [Linux桌面] 10 月5 日（这是第一次正式向外公布的时间）。以后借助于Internet网络，并通过全世界各地计算机爱好者的共同努力，已成为今天世界上使用最多的一种`UNIX 类操作系统`，并且使用人数还在迅猛增长。

linux发音五花八门，根据linux的创始人林纳斯·托瓦兹的说法，Linux的发音和“Minix”是押韵的。“Li”中“i”的发音类似于“Minix”中“i”的发音，而“nux”中“u”的发音类似于英文单词“profess”中“o”的发音。依照国际音标应该是/‘linэks/——类似于“里讷克斯”。但是，由于林纳斯·托瓦兹本人是芬兰人，所以他的Linux读音不是/‘linэks/，而是/‘liniks/.。

## 三、Linux目录结构

`/`:根目录，所有的目录、文件、设备都在/目录之下，这个/就是Linux系统的组织者，也是最上级的领导。

`/bin`：bin是二进制binary单词的缩写。在一般的系统当中，都可以在这个目录下找到`linux常用的命令`。系统所需要的命令都在这个文件夹下。

`/boot`：Linux内核及引导系统程序所需要的文件目录。

`/dev`：dev是设备device英文缩写。这个目录对于用户来说非常重要，里面包含了Linux系统中使用到的外部设备，但是里面不是放外部设备驱动程序。它实际上是访问这些外部设备的端口，可以很方便地访问外部设备。比如：打印机，音频，网络。

`/etc`：etc也是linux操作系统的重要目录之一。这个目录下，存放了系统管理时要用到的配置文件和子目录。比如网络配置文件、文件系统配置、x系统配置文件，设备的配置信息，设备用户信息等都存在这里。

`/home`：如果创建一个用户，这个用户名字就会以文件夹存在于home目录下，用来存放用户私有的信息：比如图片，视频等，类似window电脑中C盘的C:\Users文件夹。

`/lib`：lib是库library的缩写。这个目录用来存放系统的动态连接共享库。几乎所有的应用程序都会用到这个目录下的共享库。所以，不能再这里执行rm -rf，删库跑路的动作！

`/media`：有的linux的发行版，会使用这个目录来挂载哪些USB接口的移动硬盘、CD/DVD驱动器等。

`/mnt`：这个目录一般是用于存放挂载存储设备的挂载目录。

`/opt`：option，存放可选的程序。

`/proc`：这个目录获取系统信息，这些信息是在内存中，由操作系统自己产生的。

`/root`：Linux超级管理员用户的主目录，类似普通用户的目录文件夹。

`/run`：内部存放了很多pid的配置文件，启动run软件的时候配置pid信息的目录。

`/sbin`：这个目录是用来存放系统管理员的系统管理程序。大多涉及到系统管理的命令的存放，是超级管理员root的可执行命令存放地，普通用户无权限执行这个里面的命令。

`/srv`：服务启动后，所需要访问的数据目录，www服务启动读取了网页数据，就会存储在srv/www目录下。

`/sys`：Linux内核中合计比较新的一种虚拟的基于内存的文件系统，它的作用和proc有些但是，但是除了proc中的系统内部参数信息外，还有一个Linux统一的设备模型作为管理之用。

`/tmp`：临时文件目录，用来存放不同程序执行到时候产生的临时文件。

`/usr`：Linux系统中占用硬盘空间最大的目录，用户很多的应用程序和文件都存放在这个目录下。在这个目录下，可以找到那些在/bin和/etc目录下额外的工具。

`/usr/local`：主要是存放手动安装的软件。自定义的脚本也会放入到这个目录下。

`/usr/share`：系统公用的东西存放位置，比如/usr/share/fonts 是字体目录，/doc和/man都是帮助文件。

`/var`：这个目录的内容是经常会变动的，var是vary的缩写。var目录下有log存放系统的日志文件。/var/www定义Apache服务站点存放的数据。/var/lib存放库文件，比如mysql数据库存放的位置。

> 最常用的还是usr目录。

## 四、Linux常用命令

### 1.文件和目录操作

#### 1.1 pwd

含义：print working directory 打印工作目录

![image-20220420141512201](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201415934.png)

#### 1.2 ls

含义：列出目录下的内容，包括文件夹和文件的名称。

更多的用法：ls —help查看

常用的用法：ll 或者 ls -l 显示详细信息

**参　　数：**只列出常用参数

-1 每列仅显示一个文件或目录名称。

-a或—all 下所有文件和目录。

-A或—almost-all 显示所有文件和目录，但不显示现行目录和上层目录。

-c 以更改时间排序，显示文件和目录。

-d或—directory 显示目录名称而非其内容。

-F或—classify 在执行文件，目录，Socket，符号连接，管道名称后面，各自加上”*”,”/“,”=”,”@”,”|”号。

**举 例：**

![image-20210817144252372](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210817144252.png)

![image-20210817144259252](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210817144259.png)

![image-20210817144305260](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210817144305.png)

#### 1.3 cd

含 义：切换目录

**语　　法：**cd [目的目录]

**补充说明：**cd指令可让用户在不同的目录间切换，但该用户必须拥有足够的权限进入目的目录。

**举 例：**

![image-20210817144358843](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210817144358.png)

#### 1.4 mkdir

含义：创建目录；

**语　　法：**mkdir [-p] [-m <目录属性>] [目录名称]

**补充说明：**mkdir可建立目录并同时设置目录的权限。

**参　　数：**

-m<目录属性>或—mode<目录属性> 建立目录时同时设置目录的权限。

-p或—parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录。

![image-20220420141903000](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201419058.png)

#### 1.5 touch

功能说明：`改变文件或目录时间`，也可以`创建一个空文件`。

**语　　法：**touch [-a] [-d <日期时间>] [-r <参考文件或目录>] [-t <日期时间>] [文件或目录]

**补充说明：**使用touch指令可更改文件或目录的日期时间，包括存取时间和更改时间。

**参　　数：**常用参数

　-a只更改存取时间。

　-d<时间日期> 　使用指定的日期时间，而非现在的时间。

　-r<参考文件或目录> 　把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同。

　-t<日期时间> 　使用指定的日期时间，而非现在的时间。

#### 1.6 rmdir

功能说明：删除空目录

**补充说明：**当有空目录要删除时，可使用rmdir指令。

**参　　数：** -p或—parents 删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除。

![image-20220420142250825](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201422880.png)

#### 1.7 mv

move：移动或更名现有的文件或者目录

**语　　法：**mv [-bfi] [源文件或目录] [目标文件或目录]

**补充说明：**mv 可移动文件或目录，或是更改文件或目录的名称。

**参　　数：**

　-b或—backup 　若需覆盖文件，则覆盖前先行备份。

　-f或—force 　若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文　件或目录。

　-i或—interactive 　覆盖前先行询问用户。

**举 例：**

修改文件名，如下图，把testbak.txt 文件修改为testbak

![image-20220420142734964](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201427099.png)

#### 1.8 cp

作 用：复制copy

**语　　法：**cp [-bfipPrR] [源文件或目录] [目的目录]

**补充说明：**cp指令用在`复制文件或目录`，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，而最后的目的地并非是一个已存在的目录，则会出现错误信息。

**参　　数：**

　-b或—backup 　删除，覆盖目标文件之前的备份，备份文件会在字尾加上一个备份字符串。

　-f或—force 　强行复制文件或目录，不论目标文件或目录是否已存在。

　-i或—interactive 　覆盖既有文件之前先询问用户。

　-p或—preserve 　保留源文件或目录的属性。

　-P或—parents 　保留源文件或目录的路径。

　-r 　递归处理，将指定目录下的文件与子目录一并处理。

![image-20220420143351716](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201433778.png)

#### 1.9 rm

remove：删除

**语　　法：**rm [-firv] [文件或目录…]

**补充说明：**执行rm指令可删除文件或目录，如欲删除目录必须加上参数”-r”，否则预设仅会删除文件。

**参　　数：**

　-f或—force 　强制删除文件或目录。

　-i或—interactive 　删除既有文件或目录之前先询问用户。

　-r或-R或—recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。

　-v或—verbose 　显示指令执行过程。

![image-20220420143757256](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201437376.png)

### 2. vi文件编辑

> vim 是我们常用的命令！vim能够看见格式，而不是普通文本显示。

作用：编辑文本！

#### 2.1 vi（非常重要）

> vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。
>
> 由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。

#### 2.2 vi的基本概念

基本上vi可以分为三种状态，分别是`命令模式（command mode）、插入模式（Insert mode）和底行/末行模式（last line mode）`，各模式的功能区分如下：

```
1) `命令行模式`(command mode） 
```

　　控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insertmode下，或者到 last line mode。

> 命令行模式常用操作：i 开启插入模式，o开启插入并换一行，
>
> yw：将光标所在之处到字尾的字符复制到缓冲区中。
>
> yw：复制#个字到缓冲区
>
> yy：复制光标所在行到缓冲区。
>
> nyy：例如，「
>
> 6yy」表示拷贝从光标所在的该行“往下数”6 行文字。
>
> p：将缓冲区内的字符贴到光标所在位置。注意：所有与“
>
> y”有关的复制命
>
> 令都必须与“
>
> p”配合才能完成复制与粘贴功能。
>
> u：将缓冲取消操作

```
2) `插入模式`（Insert mode） 
```

　　只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。

```
3) `底行/末行模式`（last line mode） 
```

　　将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。

 底行/末行模式： 比如：:wq 保存并退出！ :q! 强制退出不保存。:set nu 打开行号显示 :1 表示跳转到第一行 /xxx表示搜索xxx内容，在光标命令行模式 使用n可以查询下一个搜索的内容。

> 不过一般我们在使用时把vi简化成两个模式，就是将底行/末行模式（last linemode）也算入命令行模式command mode）。

#### 2.3 vi基本操作

 a) 进入 vi

　　在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面：

```
vi myfile
```

不过有一点要特别注意， 就是您进入 vi 之后， 是处于「命令行模式（command mode）」， 您要切换到「插入模式（Insert mode）」 才能够输入文字。 初次使用 vi 的人都会想先用上下左右键移动光标， 结果电脑一直哔哔叫， 把自己气个半死，所以进入 vi 后， 先不要乱动， 转换到 「插入模式（Insert mode）」 再说吧！

 b) 切换至插入模式（Insert mode） 编辑文件

在「命令行模式（command mode）」 下按一下字母「i」 就可以进入「插入模式（Insert mode）」， 这时候你就可以开始输入文字了。 如下图

![image-20210817151632964](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210817151633.png)

 c) Insert 的切换
您目前处于「插入模式（Insert mode）」， 就能输入文字了， 然后想要保存，就要先按一下「`ESC`」 键转到「命令行模式（command mode）」
​ d) 退出 vi 及保存文件
在「命令行模式（command mode）」 下， 按一下「： 」 冒号键进入「Last line mode」， 例如：

> : w filename （输入 「w filename」 将文章以指定的文件名 filename 保存）
> : wq (输入「wq」， 存盘并退出 vi)
> : q! (输入 q!， 不存盘强制退出 vi)

![image-20210817151742001](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210817151742.png)

#### 2.4 进入vi的命令

vi filename：打开或新建文件，并将光标置于上次打开的行

vi +n filename：打开文件，并将光标置于第n行首

![image-20210817153333207](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210817153333.png)

![image-20210817153337342](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210817153337.png)

vi + filename： 打开文件， 并将光标置于最后一行首
vi +/pattern filename： 打开文件， 并将光标置于第一个与 pattern 匹配的串处

![image-20210817153351673](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210817153351.png)

![image-20210817153358245](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210817153358.png)

#### 2.5 移动光标类【只列出常用】

命令行模式下： (一般在linux查看日志文件，这些命令用的较多)

h ： 光标左移一个字符
l ： 光标右移一个字符
k 或 Ctrl+p： 光标上移一行
j 或 Ctrl+n ： 光标下移一行
space： 光标右移一个字符
Backspace： 光标左移一个字符
Enter ： 光标下移一行
w 或 W ： 光标右移一个字至字首
b 或 B ： 光标左移一个字至字首
e 或 E ： 光标右移一个字至字尾
nG： 光标移至第 n 行首

n+： 光标下移 n 行
n-： 光标上移 n 行
n$： 光标移至第 n 行尾（ 光标要开始在首行）

H ： 光标移至屏幕顶行
M ： 光标移至屏幕中间行
L ： 光标移至屏幕最后行
0： （ 注意是数字零） 光标移至当前行首
$： 光标移至当前行尾

## 五、redis安装

### 1.redis下载和解压

下载：

```
wget https://download.redis.io/releases/redis-6.2.6.tar.gz
```

解压：

```
tar xzf redis-6.2.6.tar.gz
```

安装gcc编译器：

```
yum -y install gcc gcc-c++ kernel-develyum install centos-release-scl scl-utils-buildyum install -y devtoolset-8-toolchainscl enable devtoolset-8 bash
```

如果出现下图所示的错误

![image-20211018171641105](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/xiangwei/20211018171641.png)

可能是系统自动升级正在运行，yum在锁定状态中，可以通过输入以下命令强制关闭yum

rm -f /var/run/yum.pid

然后在执行yum -y install gcc gcc-c++ kernel-devel指令安装gcc

最后一步，进入redis解压后的目录中，使用

```
make MALLOC=libc
```

上面的命令执行编译操作；

```
make install
```

出现下图所示的界面，这样就能够成功安装完成！

![image-20220420155221066](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201552181.png)

### 2.配置环境

因为有了第一步操作，我们全局都能够直接使用redis-cli 或者redis-server启动；

#### 2.1 配置redis.conf

从/usr/local/redis-6.2.6/复制redis.conf 到根目录的/config-redis/目录下，重命名为redis-6379.conf

```
cp /usr/local/redis-6.2.6/redis.conf /config-redis/redis-6379.conf
```

编辑配置文件：

```
vim /config-redis/redis-6379.conf
75 #bind 127.0.0.1 -::1   #注释掉这一行94 protected-mode no    #允许系统外部访问98 port 6379 289 pidfile /var/run/redis_6379.pid #启动的进程pid编号901 requirepass 123456  #设置密码
```

关闭防火墙：开启防火墙后，很多端口是无法直接访问服务器的！关闭防火墙的行为不好！

```
systemctl stop firewalld
```

> 推荐指定开启对应的端口号，不被防火墙拦截！同时，推荐在服务器中，不要redis的port是6379！
>
> ```
> /sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT
> ```

在windows中，在win中的redis文件夹下，启动cmd

```
redis-cli.exe -h linux-ip -p linux-redis-port#连接成功后auth 123456
```

## 六、主从复制

### 6.1 什么是主从复制(容灾)

![image-20211019171458006](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/xiangwei/20211019171458.png)

主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave),数据的复制是`单向`的，只能由主节点到从节点。

默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。

> 主机master：用于写数据！
>
> 从机slave：用于读数据！

### 6.2 主从复制的作用

- 数据冗余 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
- 故障恢复 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
- 负载均衡 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
- 读写分离 可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；
- 高可用基石(容灾) 除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。(核心是哨兵: 多台从机，都是哨兵，会监视主master机，如果主机挂掉了，就会顶一个上去，当新的主机。)

### 6.3常见主从结构

- 一主一从：用于主节点故障转移从节点，当主节点的“写”命令并发高且需要持久化，可以只在从节点开启AOF（主节点不需要），这样即保证了数据的安全性，也避免持久化对主节点的影响

![image-20211019171600775](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/xiangwei/20211019171600.png)

- 一主多从：针对“读”较多的场景，“读”由多个从节点来分担，但节点越多，主节点同步到多节点的次数也越多，影响带宽，也加重主节点的稳定

![image-20211019171612581](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/xiangwei/20211019171612.png)

- 树状主从：`一主多从的缺点`（主节点推送次数多压力大）可用些方案解决，主节点只推送一次数据到从节点B，再由从节点B推送到C和D，减轻主节点推送的压力。

![image-20211019171627037](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/xiangwei/20211019171627.png)

### 6.4 实例演示

在一台电脑上，一个linux服务器中，配置3个redis的服务！

一主：6379端口是主机

两从：6380端口和6381端口是从机，都关联主机。

> 一般配置主从：只配置从机，主机就按正常配置即可，不用修改！

#### 1. 复制redis的配置文件3份

统一复制到/config-redis/目录，名称分别是：redis-6379.conf、redis-6380.conf、redis-6381.conf

第一个redis-6379.conf的配置：

```
75 #bind 127.0.0.1 -::1   #注释掉这一行94 protected-mode no    #允许系统外部访问98 port 6379 289 pidfile /var/run/redis_6379.pid #启动的进程pid编号901 requirepass 123456  #设置密码
```

一旦有从机连接上，主机上打印info就能查看到：

![image-20220420165405607](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201654699.png)

第二个redis-6380.conf的配置：

```
75 #bind 127.0.0.1 -::1   #注释掉这一行94 protected-mode no    #允许系统外部访问98 port 6380 289 pidfile /var/run/redis_6380.pid #启动的进程pid编号477 replicaof 192.168.8.124 6379  #在从机配置主机的host和port486 masterauth 123456 #如果不配置这个，从机将会提示权限问题，无法连接主机901 requirepass 123456  #设置可选的密码
```

修改完成后，在windows中，启动redis-cli，可以通过info命令，查看到主从信息：

![image-20220420165257538](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201652612.png)

第三个redis-6381.conf的配置：

```
75 #bind 127.0.0.1 -::1   #注释掉这一行94 protected-mode no    #允许系统外部访问98 port 6380 289 pidfile /var/run/redis_6380.pid #启动的进程pid编号477 replicaof 192.168.8.124 6379  #在从机配置主机的host和port486 masterauth 123456 901 requirepass 123456  #设置可选的密码
```

![image-20220420165814977](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201658050.png)

如上配置完成后，最终主机的信息会显示如下图：

![image-20220420165849943](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201658033.png)

至此，一主两从的配置完成：

测试，主机set数据，从机get数据！

![image-20220420170034394](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201700467.png)

> 从机在连上主机的时候，第一次会直接全量复制！

#### 2. 问题

如果主机没了~

从机会一直尝试去连接主机，每秒！

从机的信息：但是从机还是依然可以取出原本的数据。

![image-20220420170454471](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201704594.png)

> 主机挂掉后，目前是没有任何服务器可以新增数据！
>
> 重新推选一个新主机，从机中推选一个！

#### 3. 主从复制原理

![image-20211019172013563](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201709802.png)

## 七、哨兵模式

### 7.1 哨兵模式

当主机在停机期间怎么实现功能能正常使用呢？使用哨兵机制（哨兵模式）

主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。

### 7.2 哨兵模式概述

哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。

![image-20211019172038879](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/xiangwei/20211019172038.png)

这里的哨兵有两个作用

- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。
- 当哨兵监测到master宕机，会自动将slave切换成master，然后通过`发布订阅`模式通知其他的从服务器，修改配置文件，让它们切换主机。

然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了`多哨兵模式`。

![image-20211019172058582](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/xiangwei/20211019172058.png)

用文字描述一下**故障切换**（failover）的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。这样对于客户端而言，一切都是透明的。

### 7.3 多哨兵模式

找到哨兵的配置文件：

![image-20220420173045318](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201730389.png)

复制3份到/config-redis/文件夹中

![image-20220420173214072](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201732134.png)

vim修改第一个sentinel-26379.conf配置文件：

```
16 protected-mode no20 port 2637930 pidfile /var/run/redis-sentinel-26379.pid83 sentinel monitor mymaster 192.168.8.124 6379 2 #2是指2个哨兵发现主机挂掉，则需要推选新的主机85 sentinel auth-pass mymaster 123456
```

启动命令：

```
redis-sentinel sentinel-26379.conf
```

![image-20220420173850498](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201738622.png)

vim修改第二个sentinel-26379.conf配置文件：

```
16 protected-mode no20 port 2638030 pidfile /var/run/redis-sentinel-26380.pid83 sentinel monitor mymaster 192.168.8.124 6379 2 #2是指2个哨兵发现主机挂掉，则需要推选新的主机85 sentinel auth-pass mymaster 123456
```

启动命令

```
redis-sentinel sentinel-26380.conf
```

vim修改第三个sentinel-26379.conf配置文件：

```
16 protected-mode no20 port 2638130 pidfile /var/run/redis-sentinel-26381.pid83 sentinel monitor mymaster 192.168.8.124 6379 2 #2是指2个哨兵发现主机挂掉，则需要推选新的主机85 sentinel auth-pass mymaster 123456
```

启动命令

```
redis-sentinel sentinel-26381.conf
```

最终关闭6379后：6381成功被推选为新的主机：



![image-20220420180444781](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204201804855.png)

day20 Nginx

# day20 Nginx

## 一、复习

![image-20220421093653245](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204210936351.png)

## 二、redis常见面试题

### 1. 缓存穿透

> 产生原因：
>
> 比如，shiro的自定义域中，开启缓存，缓存了用户信息，角色信息，权限信息。
>
> 如果，我们登录认证的时候，能够命中缓存的数据，那就直接从redis中获取即可。
>
> 但是，如果缓存中，通过key去获取的值是null，则回去DB中查询，查询完成后，再次设置到redis中。

![image-20211019172511807](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204211033641.png)

按这种做法，那查询一个一定`不存在的数据值`，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据`每次请求都要到数据库去查询`，造成`缓存穿透`。

解决办法

- 最好对于每一个`缓存key都有一定的规范约束`，这样在程序中对不符合parttern的key 的请求可以拒绝。（但一般key都是通过程序自动生成的）
- 将可能出现的缓存key的组合方式的所有数值以hash形式存储在一个很大的bitmap中<`布隆过滤器`>（需要考虑如何将这个可能出现的数据的hash值之后同步到bitmap中，后端每次新增一个可能的组合就同步一次，或者穷举），一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力
- 常用：如果对应在数据库中的数据都不存在，我们将此key对应的value设置为一个默认的值，比如“NULL”，并设置一个缓存的失效时间。当然这个key的时效比正常的时效要小的多

### 2. 缓存雪崩

> 产生原因：指大量的缓存，在集中的一个`段时间内失效`，发生了大量的缓存穿透，所有的查询都落到DB，造成了缓存雪崩。

正常情况

![image-20211019172550805](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204211041932.png)

当大量数据失效或者redis宕机

![image-20211019172601397](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204211041586.png)

#### 解决办法

- 这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布，设置不同的`过期时间`。缓存的过期时间用`随机值`，尽量让不同的key的过期时间不同（例如：定时任务新建大批量key，设置的过期时间相同）
- 可以把缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务。利用sentinel或cluster实现。`防止redis整体宕机！`
- 采用多级缓存，本地进程作为一级缓存，redis作为二级缓存，不同级别的缓存设置的超时时间不同，即使某级缓存过期了，也有其他级别缓存兜底。`尽量减少直接访问数据库！`

### 3. 缓存击穿

> 产生原因：
>
> 热点key，不停扛着高并发的访问，在这个key失效的一瞬间，会有大量的请求，穿过缓存，直接请求数据库，瞬间访问压力增大。
>
> 缓存击穿这里强调的是并发，造成缓存击穿的原因有以下两个：
>
> - 该数据没有人查询过 ，第一次就大并发的访问。（冷门数据）
> - 添加到了缓存，reids有设置数据失效的时间 ，这条数据刚好失效，大并发访问（热点数据）

对于缓存击穿的解决方案就是加锁，具体实现的原理图如下：

![image-20211019172643238](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204211051439.png)

当用户出现大并发访问的时候，在`查询缓存的时候和查询数据库的过程加锁`，只能第一个进来的请求进行执行，当第一个请求把该数据放进缓存中，接下来的访问就会直接集中缓存，防止了缓存击穿。

业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。

#### 解决办法

- 与缓存雪崩的解决方法类似： 用加锁或者队列的方式保证缓存的单线程（进程）写，在加锁方法内先从缓存中再获取一次，没有再查DB写入缓存。

  还有一种比较好用的（针对缓存雪崩与缓存击穿）：

- 物理上的缓存是不设置超时时间的（或者超时时间比较长），但是在缓存的对象上增加一个属性来标识超时时间（此时间相对小）。当获取到数据后，校验数据内部的标记时间，判定是否快超时了，如果是，异步发起一个线程（控制好并发）去主动更新该缓存。

  这种方式会导致一定时间内，有些请求获取缓存会拿到过期的值，看业务是否能接受而定。

### 4. 淘汰策略

#### 热点数据

在现今的电商平台中都有会有些大卖的商品，我们称之为爆品。这些商品会有个特点，就是访问量(查询)特别大。我们专业上面可以称之为热点数据，在处理这些热点商品时，系统需要做一些特殊的处理。我们常见的处理方式就是将这些数据放到redis缓存中去，但是redis是一种内存数据库，而内存的容量又是有限的。随着业务量的增长，我们放在Redis里面的数据越来越多了，导致内存严重不足，这个时候就需要我们将Redis缓存中一些不是那么常用的数据移除掉，为了更好的利用内存，使Redis存储的都是缓存的热点数据，Redis设计了相应的`内存淘汰机制`（也可以叫做缓存淘汰机制）。

#### 开启淘汰机制

修改redis缓存大小，单位是字节

![image-20220421160847593](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204211608722.png)

内存淘汰的过程

- 首先，客户端发起了需要申请更多内存的命令（如set）。
- 然后，Redis检查内存使用情况，如果已使用的内存大于maxmemory则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存。
- 最后，如果上面都没问题，则这个命令执行成功。

提示：maxmemory为0的时候表示我们对Redis的内存使用没有限制。

##### 淘汰策略

![image-20220421160935859](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204211609958.png)

LRU（Least Recently Used）

| 策略            | 解释                                                         |
| --------------- | ------------------------------------------------------------ |
| volatile-lru    | 从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。注意：redis并不是保证取得所有数据集中最近最少使用的键值对，而只是随机挑选的几个键值对中的， 当内存达到限制的时候无法写入非过期时间的数据集。 |
| volatile-ttl    | 从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。注意：redis 并不是保证取得所有数据集中最近将要过期的键值对，而只是随机挑选的几个键值对中的， 当内存达到限制的时候无法写入非过期时间的数据集。 |
| volatile-random | 从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。当内存达到限制的时候无法写入非过期时间的数据集。 |
| allkeys-lru     | 从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰。当内存达到限制的时候，对所有数据集挑选最近最少使用的数据淘汰，可写入新的数据集。 |
| allkeys-random  | 从数据集（server.db[i].dict）中任意选择数据淘汰，当内存达到限制的时候，对所有数据集挑选随机淘汰，可写入新的数据集。 |
| no-enviction    | 当内存达到限制的时候，不淘汰任何数据，不可写入任何数据集，所有引起申请内存的命令会报错。 |

##### 淘汰策略选择

根据使用经验, 一般来说回收策略可以这样来配置:

- allkeys-lru：如果期望用户请求呈现幂律分布(power-law distribution)，也就是，期望一部分子集元素被访问得远比其他元素多时，可以使用allkeys-lru策略。在你不确定时这是一个好的选择。
- allkeys-random：如果期望是循环周期的访问，所有的键被连续扫描，或者期望请求符合平均分布(每个元素以相同的概率被访问)，可以使用allkeys-random策略。
- volatile-ttl：如果你期望能让 Redis 通过使用你创建缓存对象的时候设置的TTL值，确定哪些对象应该是较好的清除候选项，可以使用volatile-ttl策略。

另外值得注意的是，为键设置过期时间需要消耗内存，所以使用像allkeys-lru这样的策略会更高效，因为在内存压力下没有必要为键的回收设置过期时间。

##### 淘汰个数

![image-20220421161030953](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204211610032.png)

### 5. 删除策略

数据删除策略有三种

- 被动删除：只有key被操作时(如GET)，Redis才会被动检查该key是否过期，如果过期则删除之并且返回NIL。
- 主动删除：定期删除过期的数据

![image-20220421161056523](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204211610598.png)

默认是10，表示serverCron每秒执行10次

注意：hz调大将会提高Redis主动淘汰的频率，如果Redis存储中包含很多冷数据占用内存过大的话，可以考虑将这个值调大，但Redis作者建议这个值不要超过100。

- 当前已用内存超过maxmemory限定时，触发数据淘汰策略

#### 被动删除特点

- 这种删除策略对CPU是友好的，删除操作只有在不得不的情况下才会进行，不会其他的expire key上浪费无谓的CPU时间。
- 但是这种策略对内存不友好，一个key已经过期，但是在它被操作之前不会被删除，仍然占据内存空间。如果有大量的过期键存在但是又很少被访问到，那会造成大量的内存空间浪费。

## 三、Nginx

### 1. 简介

Nginx是一款轻量级的Web服务器、反向代理服务器及电子邮件代理服务器，还可以是静态资源服务器。

用途：反向代理、负载均衡、动静分离。

### 2. 正向代理

用户 A 向代理服务器发送一个请求并指定目标(服务器 B)，然后由代理服务器向服务器 B 转交请求并将获得的内容返回给客户端。

用户A向代理服务器B发送一个请求，想要访问的是服务器C，然后由代理服务器B向服务器C转交请求，并将获得的数据内容返回给用户A.

我用户A是明确知道我要访问的是服务器C(某个网站)上的资源！类似你翻墙，你是`明确知道你要去什么网站！`

![image-20211209141425049](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202112091414155.png)

### 3. 反向代理

是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将 从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个 服务器。

代理服务器B来接收用户A的请求，然后将请求转发到内部网络的服务器C上，并将服务器的资源数据返回给用户A，此时，用户感知不到还有服务器C的存在！

我们只知道代理服务的网址，无法感知到它具体代理的是哪个服务器。参考10086，这个号码就是代理服务器，接线员就是目标服务器！

![image-20211209141808506](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202112091418615.png)

### 4. 负载均衡

> Load Balance: 是指建立在现有网络结构之上，并提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、 增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。其原理就是`数据流量分摊` 到多个服务器上执行，减轻每台服务器的压力，多台服务器共同完成工作任务，从而提高了数据的吞吐量。

Nginx是`服务器级别`的负载均衡！和4阶段的负载均衡做一个区别：ribbon！

> 均衡策略：
>
> 默认(缺省)策略：轮巡策略：每个请求，按照时间顺序，逐一分配到不同的服务器上。
>
> 如果某台服务器宕机了，Nginx会自动剔除该服务器。

### 5. 动静分离

静态资源： 当用户多次访问这个资源，资源的源代码永远不会改变的资源。

动态资源：当用户多次访问这个资源，资源的源代码可能会发生改变。

动静分离简单的概括是：动态文件与静态文件的分离。

## 四、Nginx六中负载均衡策略

### 4.1 Default：轮训策略

每个请求会按时间顺序逐一分配到不同的后端服务器。

在轮询中，如果服务器 down 掉了，会自动剔除该服务器。

缺省配置就是轮询策略。

### 4.2 Weighted：权重策略

权重方式，在轮询策略的基础上指定轮询的几率

weight 参数用于指定轮询几率

server localhost:8001 weight=3

### 4.3 Least connected：最小连接

least_conn;

把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn 这种方式就可以达到更好的负载均衡效果。

### 4.4 IP Hash ：IP 绑定策略

ip_hash;

指定负载均衡器按照基于客户端 IP 的分配方式，这个方法确保了相同的客户端的请求一直发送到 相同的服务器，以保证session会话。这样每个访客都固定访问一个后端服务器，可以解决session 不能跨服务器的问题。

### 4.5 Fair ：按响应时间(第三方)

第三方的负载均衡策略的实现需要安装第三方插件。

fair，按照服务器端的响应时间来分配请求，响应时间短的优先分配。

server localhost:8001 weight=5 max_fails=2 fail_timeout=3s;

### 4.6 url_hash ：按 url 分配策略（第三方）

按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，要配合缓存命中来使 用。同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。而使用 url_hash，可以使得同一个 url（也就是同一个资源请 求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取。

## 五、Nginx常用配置

### 5.1 配置服务器池

```ini
#服务器池 
upstream myserver{
server localhost:8001;
server localhost:8002;
server localhost:8003;
server localhost:8004;
}
server{
listen 80;
#使用 myserver 服务器池进行后端的处理 
location /{
proxy_pass http://myserver;
proxy_set_header Host $host;#把原 http 请求的 Header 中的 Host 字段也放到转发的请求里
#把真实客户端 IP 和反向代理 IP 通过逗号分隔，添加到请求头中；
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
}
```

### 5.2 配置输出日志

```ini
log_format main '$remote_addr - $remote_user [$time_local] "$request" ' 
'$status $body_bytes_sent "$http_referer" ' 
'"$http_user_agent" "$http_x_forwarded_for"' 
'$upstream_addr "$upstream_status" ${upstream_response_time}'; 
access_log logs/access.log main;
```

### 5.3 Least connected：最小连接配置

```ini
upstream myserver{ 
least_conn; 
server 192.168.31.21:8001; 
server 192.168.31.21:8002; 
server 192.168.31.21:8003; 
server 192.168.31.21:8004; 
}
```

### 5.4 IP_HASH：IP 绑定策略配置

```
upstream myserver{ 
ip_hash; 
server 192.168.31.21:8001; 
server 192.168.31.21:8002; 
server 192.168.31.21:8003; 
server 192.168.31.21:8004; 
}
```

### 5.5 Weight：权重策略的配置

```
upstream myserver{ 
server 192.168.31.21:8001 weight=5; 
server 192.168.31.21:8002 weight=1; 
server 192.168.31.21:8003 weight=2; 
server 192.168.31.21:8004 weight=3; 
}
```

### 5.6 实现负载均衡配置(反向代理的效果)

```
#user  nobody;
worker_processes  1;
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
#pid        logs/nginx.pid;
events {
    worker_connections  1024;
}
#服务池
http {
    include       mime.types;
    default_type  application/octet-stream;
    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';
    #access_log  logs/access.log  main;
    sendfile        on;
    #tcp_nopush     on;
    #keepalive_timeout  0;
    keepalive_timeout  65;
    #gzip  on;
    # 有权重的轮训  也就是说我们的NGINX所反向代理的这几个服务器！
    upstream myserver{
        server localhost:1234 weight=3;
        server localhost:1111 weight=1;
        server localhost:2222 weight=2;
    }
    server {
        listen       80;
        server_name  localhost;
        #charset koi8-r;
        #access_log  logs/host.access.log  main;
       # location / {
       #     root   html;
       #     index  index.html index.htm;
       # }
        location / {
            proxy_pass http://myserver/index; #代理的上面写的 
            #proxy_set_header Host $host; #把原本的http请求的header中的HOST字段转发进去
        }
        #error_page  404              /404.html;
        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
     location ~ ^/(chapter23-server)/ {
        proxy_pass http://127.0.0.1:8080; 
        index /;
    }
    location ~ ^/(chapter23-app1)/ {
        proxy_pass http://127.0.0.1:9080; 
        index /;
    }
    location ~ ^/(chapter23-app2)/ {
        proxy_pass http://127.0.0.1:10080; 
        index /;
    }
        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}
        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}
        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }
    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;
    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}
    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;
    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;
    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;
    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;
    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}
}
```

更多配置请查看：

https://app.yinxiang.com/fx/68b0a083-3883-4995-a8c0-d71259f15aa8

### 5.7 静态资源

```
#user  nobody;
worker_processes  1;
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
#pid        logs/nginx.pid;
events {
    worker_connections  1024;
}
#服务池
http {
    include       mime.types;
    default_type  application/octet-stream;
    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';
    #access_log  logs/access.log  main;
    sendfile        on;
    #tcp_nopush     on;
    #keepalive_timeout  0;
    keepalive_timeout  65;
    #gzip  on;
    # 有权重的轮训  也就是说我们的NGINX所反向代理的这几个服务器！
    upstream myserver{
        server localhost:1234 weight=3;
        server localhost:1111 weight=1;
        server localhost:2222 weight=2;
    }
    server {
        listen       8088;
        server_name  localhost;
        #charset koi8-r;
        #access_log  logs/host.access.log  main;
       # location / {
       #     root   html;
       #     index  index.html index.htm;
       # }
        location / {
            proxy_pass http://myserver/index;
            #proxy_set_header Host $host; #把原本的http请求的header中的HOST字段转发进去
        }
        # 访问的本地资源路径其实是：C:/Users/ASUS/Desktop/mdfile/ 下的资源！
        # 请求的url ：  localhost:8088/mdfile/
        location /mdfile/ {
            root C:/Users/ASUS/Desktop/;
            autoindex on;
        }
        #error_page  404              /404.html;
        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
     location ~ ^/(chapter23-server)/ {
        proxy_pass http://127.0.0.1:8080; 
        index /;
    }
    location ~ ^/(chapter23-app1)/ {
        proxy_pass http://127.0.0.1:9080; 
        index /;
    }
    location ~ ^/(chapter23-app2)/ {
        proxy_pass http://127.0.0.1:10080; 
        index /;
    }
        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}
        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}
        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }
    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;
    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}
    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;
    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;
    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;
    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;
    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}
}
```

### 5.8 Nginx 资源压缩

利用浏览器支持的 GZip 压缩，通过 nginx 将 js、css 等静态资源进行打包压缩。

```
#开启 Nginx 的 Gzip 压缩 
gzip on; 
gzip_min_length 1k; 
gzip_types text/plain text/css application/javascript text/xml application/xml; 
gzip_buffers 4 16k; 
gzip_comp_level 5; #设置压缩的级别，1-9 压缩比越高，占用的 CPU 资源越大;
```

day21 git

# day21 git

## 复习

![image-20220422094014199](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204220940285.png)

## 一、Git历史

同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。

到 2005 年的时候，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统订了若干目标：

• 速度

• 简单的设计

• 对非线性开发模式的强力支持（允许上千个并行开发的分支）

• 完全分布式

• 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）

![img](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510001544.jpg)

## 二、Git与SVN对比

### 2.1 Svn

SVN是`集中式`版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就郁闷了。

下图就是标准的集中式版本控制工具管理方式：

![img](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510001540.png)

集中管理方式在一定程度上看到其他开发人员在干什么，而管理员也可以很轻松掌握每个人的开发权限。

但是相较于其优点而言，集中式版本控制工具缺点很明显：

l 服务器单点故障

l 容错性差

### 2.2 Git

Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。

下图就是分布式版本控制工具管理方式：

![img](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510001725.jpg)

## 三、git工作流程

一般工作流程如下：

1．从远程仓库中克隆 Git 资源作为本地仓库。

2．从本地仓库中checkout代码然后进行代码修改

3．在提交前先将代码提交到暂存区。add

4．提交commit修改。提交到本地仓库。本地仓库中保存修改的各个`历史版本`。

5．在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库。

下图展示了 Git 的工作流程：

![img](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510001714.jpg)

## 四、使用git管理文件版本

### 4.1 创建版本库

什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。由于git是分布式版本管理工具，所以git在不需要联网的情况下也具有完整的版本管理能力。

创建一个版本库非常简单，可以使用git bash也可以使用tortoiseGit。首先，选择一个合适的地方，创建一个空目录。

##### 4.1.1 使用GitBash

右键点击 git bash here 菜单

然后 输入git init

##### 4.1.2 使用TortoiseGit

右键里面选择 在这里创建版本库

## 五、演示过程

### 5.1 添加文件

#### 完成add与commit

add: 相当于 把普通的文件, 添加到我们的git管理当中。

commit 提交： 相当于 把已经add的文件， 添加到本地git的版本管理当中，让这个文件有了版本的概念。如果该文件被删除，可以通过还原找回。

然后可以在日志里面，查看到，本地commit提交的所有版本，然后可以点击下方文件， 右键还原到这个版本的代码。

![image-20210510114212187](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510114212.png)

### 5.2 工作区和暂存区

Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。

什么是工作区（Working Directory）？

工作区就是你在电脑里能看到的目录，比如我的reporstory文件夹就是一个工作区。

有的同学可能会说repository不是版本库吗怎么是工作区了？其实repository目录是工作区，在这个目录中的“.git”隐藏文件夹才是版本库。这回概念清晰了吧。

Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。

如下图所示：

![img](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510002900.png)

分支和HEAD的概念我们稍后再讲。前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：

第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；

第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。

因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。

你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。

### 5.3 操作文件

#### 5.3.1 提交修改

被版本库管理的文件不可避免的要发生修改，此时只需要直接对文件修改即可。修改完毕后需要将文件的修改提交到版本库。

在mytest.txt文件上点击右键，然后选择“提交”

#### 5.3.2 查看修改历史

右键中有logger

#### 5.3.3 差异比较

右键中有diff

#### 5.3.4 还原修改

先进入日志菜单, 然后点击之前的版本, 再再文件处 点击还原到当前版本.

#### 5.3.5 删除文件

右键 git菜单中,点击删除.不是win的删除! 记得删除后点击提交commit~!

#### 5.3.6 恢复文件

右键中有还原

## 六、简单版通用git使用方式!

### 步骤:

### 1.打开gitee官网.登录

![image-20210510142335960](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510142336.png)

### 2.新建仓库

![image-20210510142535714](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510142535.png)

### 3.先添加仓库成员

不添加成员的话, 小组成员只能下载 ,不能提交代码!

在项目首页, 点击管理!

![image-20210510142754214](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510142754.png)

![image-20210510142912951](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510142913.png)

### 4.可以拉项目下来

首先 现在网页上 点击克隆

![image-20210510143216609](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510143216.png)

右键点击 git 克隆菜单, 弹入这个框:

![image-20210510143151220](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510143151.png)

### 5.修改拉下来的代码 提交上去

提交, 使用push(推送)按钮

### 6.需要注意

每次push之前, 必须pull 拉取代码, 如果有冲突, 就需要解决冲突(要么以云端的代码为主, 要么以自己的代码为主), 或者合并冲突(自己手动 合并两套代码)

### 7.简单版名词定义

pull 拉取云端最新代码(别人已经推送成功的代码)

拉取下来后, **解决冲突!**

**合并好**的代码后, 先commit提交, 再push到云端上!

## 七、远程仓库(进阶版)

建库 ssh

### 7.1 生成/添加SSH公钥

[SSH Key](https://gitee.com/help/labels/19) [SSH 公钥](https://gitee.com/help/labels/29)

Gitee 提供了基于SSH协议的Git服务，在使用SSH协议访问仓库仓库之前，需要先配置好账户/仓库的SSH公钥。

解决了一个, 每次提交需要输入账号密码的情况!

你可以按如下命令来生成 sshkey:

```
ssh-keygen -t rsa -C "xxxxx@xxxxx.com"  # Generating public/private rsa key pair...
```

> 注意：这里的 `xxxxx@xxxxx.com` 只是生成的 sshkey 的名称，并不约束或要求具体命名为某个邮箱。
> 现网的大部分教程均讲解的使用邮箱生成，其一开始的初衷仅仅是为了便于辨识所以使用了邮箱。

按照提示完成三次回车，即可生成 ssh key。

(linux这么玩)通过查看 `~/.ssh/id_rsa.pub` 文件内容，获取到你的 public key

```
cat ~/.ssh/id_rsa.pub# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....
```

![image-20210510172810189](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510172810.png)

复制生成后的 ssh key，通过仓库主页 **「管理」->「部署公钥管理」->「添加部署公钥」**

添加后，在终端（Terminal）中输入

```
ssh -T git@gitee.com
```

首次使用需要确认并添加主机到本机SSH可信列表。若返回 `Hi XXX! You've successfully authenticated, but Gitee.com does not provide shell access.` 内容，则证明添加成功。

![img](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/20210510172820.png)

添加成功后，就可以使用SSH协议对仓库进行操作了。

### 7.2仓库公钥和可部署公钥

为了便于用户在多个项目仓库下使用一套公钥，免于重复部署和管理的繁琐，Gitee 推出了「可部署公钥」功能，支持在一个仓库空间下使用当前账户名下/参与的另一个仓库空间的部署公钥，实现公钥共用。

演示了只有

## 八、远程创建项目

演示

## 九、本地莫名其妙文件直接推送git方案(错误解决办法)

出现该错误的原因主要是因为远程库有README这个文件，而本地库没有该文件。

出现fatal: refusing to merge unrelated histories这个错误时，

运行： git pull origin master –allow-unrelated-histories

再次错误：fatal: Couldn’t find remote ref –allow-unrelated-histories

则运行：git pull —rebase origin master

然后再运行：git push origin master

## 十、分支管理

面试题: 如何把dev分支的代码合并到云上的master分支中?

Fetch（获取） 和 Pull （拉取）有什么区别？

就是获取~ 然后 需要用户 自己手动合并代码（）

pull 是 获取 加merge（合并）

目前是本地 mydev分支 提交到 云上的dev分支 , 但是代码有冲突 被拒绝提交!

先pull拉一下云上dev分支到我本地的mydev分支上。

### 10.1 本地分支管理

![image-20220422105639672](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221056739.png)

> 暂存区的文件，是不属于任何分支的！

![image-20220422110447041](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221104110.png)

#### ①如何让dev分支的代码和master分支的代码不一样？

> commit后，分支之间才会有区别。因commit默认只能commit到当前切换的分支。
>
> commit到dev后，分支图。
>
> ![image-20220422110809977](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221108037.png)

#### ②如何让master分支和dev分支，分叉！

![image-20220422110958716](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221109781.png)

![image-20220422111323234](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221113297.png)

![image-20220422111502688](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221115783.png)

#### ③如何让dev和master分支，又回到同一个版本上

> 我想要让，，显示如下：
>
> ![image-20220422111553244](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221115294.png)

分支合并：merge，后会出现下列提示：

![image-20220422113032882](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221130928.png)

![image-20220422111705309](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221117354.png)

此时查看文件，会出现下列提示：有冲突的地方都会有这个提示！不推荐直接在这里改！

![image-20220422111939833](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221119910.png)

忽略合并冲突的页面：

合并完成后，必须再次commit，出现下图：

![image-20220422113639690](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221136770.png)

这个提示只是一个消息message中#后面内容的提示，可以不用管。通常，还是要注意一下，除非你确定我真的已经冲突解决了。

把master代码合并到dev以后，出现下图的分支图：

![image-20220422113933225](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221139280.png)

此时，为了让master和dev代码一致，我们需要切换到master：

![image-20220422114032454](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221140516.png)

此时，需要再次把dev分支合并到master！

不过，本次合并，不会出现冲突了！此时，分支图如下：

![image-20220422114327745](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221143792.png)

那次，此时，我们的日志信息会变成什么样子？

![image-20220422114629300](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221146373.png)

### 10.2 远端分支管理

> 其实就 只是把你本地分支的档案，上传到云端。实际操作和本地一致！

基于idea来进行远端分支管理的演示。

基本页面截图：

![image-20220422150925409](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221509576.png)

拉取云端的代码，然后出现冲突的解决办法：

![image-20220422144607501](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221446589.png)

![image-20220422144755996](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221447160.png)

![image-20220422145822153](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221458241.png)

#### ①本地分支代码如何合并到云端？

主分支 master：最终上线的分支！如果，其他分支的代码，未经测试，是不允许合并到master分支上。

开发分支dev：我们日常开发的代码，都是在dev分支上。一般测试的代码，都是dev中的代码。

个人分支：根据企业的不同会有所不同，有的企业，会在远端开放个人分支权限。有的企业，远端是没有个人分支，只有本地才会有个人分支用于开发个人的业务需求。

某某业务分支：单独提出的一个业务线，比如，在抖音里面开启直播功能。

> 分支这么多，必然涉及到如何合并分支的问题。

企业两个方案：

目前有master分支、dev分支、mayuhang分支，需求，mayuhang分支上的代码，合并到dev分支中。

1. 本地合并后推送

   操作：把mayuhang分支的代码，合并到本地的dev分支，然后推送本地dev到远端的dev。

   1. 在mayuhang分支开发好具体业务，一定要commit！暂存区的代码，才会存入mayuhang分支中。

   2. 切换到本地的dev分支中

   3. merge mayuhang into dev

      ![image-20220422154403367](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221544424.png)

   4. 本地合并后，如果有冲突解决冲突。如果没有冲突，就不用再dev中commit 了，直接push！

      ![image-20220422154548264](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202204221545372.png)

1. 远端申请合并(正规)

   通常是企业领导已经配置好了，你只需要根据公司的问题，在gitee中提交pull request流程，即可申请把你的代码合并到目标分支。

   其次，可以对分支设置权限，每次的合并操作，都会自动生成一个pull request流程。

   day24 敏捷开发

   # day24 敏捷开发

   ## 1、明日任务

   第一步：做xmind`思维导图`

   第二步：`分工`后评估工作量

   > 进行模块分解，写到xmind中，直到不能分解为止！我们专业名词叫做工作包！这个工作包就是无法分解的模块，我们需要对这个工作包进行工时评估，1人/时 来评估；所有用时评估都不考虑数据库设计耗时!
   >
   > 评估方法：后端用时，前端用时，前后端联调时间(前端用时*2)，测试时间，修改bug的时间。

   第三步：时间节点控制： 第一个`测试版本(并非全部做完的版本)`出来的时间！第一周周六之前！周一周二设计数据库，周三写后端，周四周五写前端，周六测试联调，代码整合！ 项目冲刺(1~2周)，冲刺期间定好的需求，是不允许修改的！

   第四步：`数据库的设计`！预计要2天！

   第五步：确定第一周冲刺的内容，第二周冲刺的内容！

   ## 2、敏捷开发

   ### 2.1 硬性规范

   > 硬性规定(在未来的2周项目期间必须做的事情)：
   >
   > 1. 每天早上9点30到9点45之间进行，`站例会`：讲我昨天做了什么，遇到什么问题(不在站会讨论这个问题怎么解决)，今天我的任务是什么！ 切记一点：站例会，不要讨论需求！！！！！
   >
   >    组长需要记录每日站会的信息，比如某个人做了什么事情，遇到什么问题，以及今日任务的安排！然后提交到gitee中的项目readme中！
   >
   >    ![image-20211210165652310](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202112101656393.png)
   >
   > 2. 2个冲刺周，每个冲刺周需要提交一个经过测试的版本！在第一个周，就需要完成一些功能！
   >
   > 3. 组长还需要在gitee中，有一个叫issue的地方，设置看板！
   >
   >    ![image-20211210170056570](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/mayuhang/202112101700686.png)

   ### 2.2 敏捷

   敏捷开发：并不快速开发的意思！ `拥抱需求变化`！`价值`！`站会`！`看板`！`冲刺`!`用户故事`！

   > 分冲刺周期，考虑价值点，逐步迭代升级，完成的一个项目！
   >
   > 冲刺：在冲刺周的时间点内，即使有需求发生变化，我们也不会在本次冲刺中加入！ 另外一个重点，每次冲刺结束，我们的项目就可以直接使用！
   >
   > 价值点：最有价值的功能！我们简单考虑就是，这个功能是不是我的主线业务必须的功能，如果没有这个功能，影不影响我的主线业务！如果不影响，则价值低可以先不做！
   >
   > 站会：每日讨论昨天失败的原因，每日总结，讨论解决方案由谁去处理，尽快解决问题！
   >
   > 看板：不解释，kanban！就是用来让领导能够快速发现问题，能够快速知道进度的地方！

