1.Java介绍
	Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，
	因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，
	允许程序员以优雅的思维方式进行复杂的编程
	
	Java平台：
		J2ME（Java2 Micro Edition，Java2平台的微型版），应用于移动、无线及有限资源的环境
		J2SE（Java 2 Standard Edition，Java 2平台的标准版），应用于桌面环境，第一阶段内容，就是Java基础语法
		*J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应用于基于Java的应用服务器，是13种技术的统称
		
2.常见的快捷键
	Ctrl + A：全选
	Ctrl + S：保存
	Ctrl + Z：撤销
	Ctrl + X：剪切
	Ctrl + C：复制
	Ctrl + V：粘贴
	Windows + E：打开我的电脑
	Windows + D：显示到桌面
	Windows + R：打开运行窗口
	Windows + L：锁屏
	
3.Java语言的跨平台
	什么是Java语言的跨平台？
		就是指通过Java语言写好的程序，可以在任何操作系统上运行
		
	注意： Java语言之所以能够跨平台是依赖于Java虚拟机(JVM)的，Java虚拟机本身也是不可以跨平台的，但是针对
	不同的操作系统有不同的版本的Java虚拟机
	
4.常见的DOS命令(今明两天掌握，后面可以忘记)
	怎么打开DOS窗口？
		1. Windows + R + cmd
		2. Windows + X + A(win10)
		3. 按照shift键，点击鼠标右键选择在此处打开powershell
	
	常见的DOS命令有哪些？
		dir + 回车：显示当前文件夹下所有子文件或者子文件夹的一些信息的
		cd.. + 回车：回退到上一层
		cd/(cd\) + 回车：回退到根目录
		c:(d:) + 回车：切换盘符
		cd + 指定目录：进入到指定目录
		cls + 回车：清屏
		exit + 回车：退出dos窗口(装逼)
		
5.JDK,JRE和JVM？
	什么是JDK？
		Java的开发环境，软件，里面包含了开发工具包和JRE
	
	什么是JRE？
		Java的运行环境，里面包含了JVM和核心类库
	
	什么是JVM？
		Java虚拟机
		
	三者之间的包含关系？
		JDK > JRE > JVM
		
6.HelloWorld小案例
	步骤：
		1.创建一个文本文件，将后缀名改为.java
		2.打开该文件，在文件中写以下内容：
			class HelloWorld {
				public static void main(String[] args) {
					System.out.println("yuema");
				}
			}
			
			注意：
				1.什么地方用空格，什么地方用.
				2.什么地方大写，什么地方小写
				3.什么地方用{}，什么地方用()，什么地方用[]
		
		3.将文件放入到jdk中的bin文件夹中
		4.编译
			编译：要用到jdk中的javac.exe
			
			编译格式:javac HelloWorld.java，写在dos窗口中
			
			注意：编译成功之后会生成一个新的文件，叫做HelloWorld.class
			
		5.运行
			运行：要用到jdk中的java.exe
			
			运行格式：java HelloWorld
	
	
	1.环境变量的配置
	为什么要配置环境变量？
		目的是为了在任意目录下可以使用javac.exe(编译)和java.exe(运行)
	
	怎么配置环境变量？
		方式一：
			1.此电脑，属性，找到高级系统设置
			2.找到环境变量，打开
			3.在系统变量中，找到path变量
			4.将javac和java所在的目录(D:\develop\jdk1.8\jdk1.8.0_241\bin)添加到path变量中
				path = D:\develop\jdk1.8\jdk1.8.0_241\bin
		
		方式二：
			1.此电脑，属性，找到高级系统设置
			2.找到环境变量，打开
			3.在系统变量中，新建一个变量，名字叫做JAVA_HOME,值为javac和java所在目录，并且去掉bin
				JAVA_HOME = D:\develop\jdk1.8\jdk1.8.0_241
			4.将JAVA_HOME添加到path变量中
				path = %JAVA_HOME%\bin
				
			注意：
				1.%%之间存放的是系统变量名
				2.值与值之间用分号隔开
				
	
	如何验证是否配置成功呢？
		打开dos窗口，在任意目录下输入javac和java测试
	
2.注释
	什么是注释？
		用来解释说明的，给我们程序员看的
		
	注释的分类？
		*1.单行注释
			//注释的内容
			
		*2.多行注释
			/*注释的内容*/
		
		3.文档注释
			/**注释的内容*/
			
	注释的作用？
		1.用来解释说明的，提高了代码的阅读性
		2.可以帮我们找到一些简单的错误bug
		
	注释的注意事项？
		单行注释可以嵌套
			// //约吗
			
		多行注释不可以嵌套
			/*
				约吗
				/*
					滚犊子
				*/
			*/
			
3.关键字
	什么是关键字？
		关键字就是Java语言给我们提供好的一些单词，
		每个单词都具有他自己的意义
		
	关键字的注意事项？
		1.关键字的每个字母都是小写的
		2.main不是关键字
		
4.标识符
	什么是标识符？
		标识符就是我们自己起的名字
		
	标识符的组成规则？
		由26个大小写英文字母，数字，美元符号$和下划线_组成
		汉字...
		
	标识符的注意事项？
		1.数字不能开头
		2.标识符不能和关键字同名
		
5.常量
	什么是常量？
		永恒不变的量，就是常量
		
	常量的分类？
		字面值常量：
			整数常量：
				1,2,3,100,200.....
			
			小数常量：
				3.14, 1.2, 1.3....
			
			字符常量：
				'a', 'b', '约', '#', '1', ' '
				
				'约吗', ''
				
				注意：
					1.字符常量必须由单引号括起来
					2.字符常量里面有且只能有一个字符
			
			字符串常量：
				"a", "ab", "约吗", "123", "#4$", ""
			
				注意：
					字符串常量必须由双引号括起来
			
			布尔常量：
				只有两个常量值
				true
				false
				
			空常量：
				只有一个常量值
				null
			
		自定义常量(以后学)
		
6.进制
	生活中使用的是十进制
	计算机中使用的是二进制
	
	Java的进制分类？
		十进制：逢十进一,正常写
			10
			56
		
		二进制：逢二进一, 0b
			10010
			01001
			
			0b10010
			0b01001
		
		八进制：逢八进一, 0
			10
			
			032
		
		十六进制：逢十六进一, 0x
			0~9
			10：A
			11：B
			12：C
			13：D
			14：E
			15：F
			
			0x10
			0x43BC
			
	在计算机中，所有的数据最终都会转变成二进制，也就是1和0组成，每一个1或者0都称为1个位(bit),8个bit组成1个byte
	计算机对数据进行存储和运算的最小单位是字节(byte)，不是bit
	
		8bit = 1byte
		1KB = 1024byte
		1MB = 1024KB
		1GB = 1024MB
		1TB = 1024GB
	
	进制的转换？
		8421码进制转换法
	
		详情参考图片
		
7.原码，反码和补码
	计算机对数据进行运算的原理：
		3 + 2 = 5
		
		计算机底层会将3这个十进制转变成二进制的原码形式，然后变成反码形式，最后变成补码形式
					将2这个十进制转变成二进制的原码形式，然后变成反码形式，最后变成补码形式
					将3的补码和2的补码相加，得到一个补码，
					将这个结果的补码变成反码，再变成原码，最终转换成十进制，就是5
			
		正数：原码反码补码转换
			原码，反码和补码是一样的
		
		负数：原码反码补码转换
			原码 -> 反码：除去符号位，其余1变0,0变1
			反码 -> 补码：+1
			
		符号位：最左边的那一位就是符号位，正数的符号位是0，负数的符号位是1
		
8.变量
	什么是变量？
		在一定范围内，可以变化的量
		
	变量的定义格式？
		格式一：数据类型 变量名 = 数据;(直接定义)
				  int      i    =   12;
		
		格式二：数据类型 变量名;
				 变量名 = 数据;(间接定义)
				 
				 int  a;
				 a = 13;
				 
	说明：当我们运行这句话(int i = 12)的时候，在内存中会开辟一块内存空间，该空间的名字就是我们自己起的i，
	该空间中存储的数据的数据类型就是我们自己定义的int类型，该空间中存储的数据就是我们给的12。
	
9.数据类型
	Java中数据类型的分类？
		2大类4小类8小种
		
		基本数据类型：
			4小类8小种
			整型：
				byte(1个字节)
				short(2个字节)
				int(4个字节)
				long(8个字节)
				
			浮点型：
				float(4个字节)
				double(8个字节)
				
			字符型：
				char(2个字节)
			
			布尔型：
				boolean(1个字节)
			
		引用数据类型(以后学)
		
	
	
		
		
		
		
		
		
		1.变量
	什么是变量？
		在一定范围内，可以变化的量
		
	变量的定义格式？
		格式一：数据类型 变量名 = 数据;(直接定义)
				  int      i    =   12;
		
		格式二：数据类型 变量名;
				 变量名 = 数据;(间接定义)
				 
				 int  a;
				 a = 13;
				 
	说明：当我们运行这句话(int i = 12)的时候，在内存中会开辟一块内存空间，该空间的名字就是我们自己起的i，
	该空间中存储的数据的数据类型就是我们自己定义的int类型，该空间中存储的数据就是我们给的12。
	
	在我们使用变量的时候需要注意哪些问题？
		1.当我们想要给float类型变量赋值的时候，要在值的后面加上F或者f
		2.当我们想要给long类型变量赋值的时候，要在值的后面加上L或者l
		3.当我们想要使用某个变量的时候，一定要先赋值，再使用，要不然会报错
		4.当我们想要给某个变量赋值的时候，一定要考虑该变量的数据类型的范围，再赋值
		5.在同一对花括号内不能定义同名变量
			例子：
				public static void main(String[] args) {
					int i = 12;
					int i = 13;
				}
				
				-----------------------------------------
				public static void main(String[] args) {
					int i = 12;
					i = 13;
				}
	
2.数据类型
	Java中数据类型的分类？
		2大类4小类8小种
		
		基本数据类型：
			4小类8小种
			整型：
				byte(1个字节)
				short(2个字节)
				int(4个字节)
				long(8个字节)
				
				默认的数据类型是int
				
			浮点型：
				float(4个字节)
				double(8个字节)
				
				默认的数据类型是double
				
			字符型：
				char(2个字节)
			
			布尔型：
				boolean(1个字节)
			
		引用数据类型(以后学)
		
3.数据类型的转换
	隐式类型转换？
		什么是隐式类型转换？
			是指小的数据类型会自动提升为大的数据类型
			
		举例子：
			byte b = 1;
			short s = 2;
			int i = 3;
			long l = 4;
			float f = 5.5F;
			double d = 6.6;
			double dd = b + s + i + l + f + d;
			System.out.println(dd);
			
			注意：当有多个数据类型参与运算的时候，小的数据类型会提升为大的数据类型
			
		常见的考试题？
			考一：
				byte b1 = 1;
				byte b2 = 2;
				byte b3 = b1 + b2;
				System.out.println(b3);//编译报错
				
				---------------------------------
				
				short s1 = 1;
				short s2 = 2;
				short s3 = s1 + s2;
				System.out.println(s3);//编译报错
				
				---------------------------------
				
				int i1 = 1;
				int i2 = 2;
				int i3 = i1 + i2;
				System.out.println(i3);//3
				
			考二：
				byte b1 = 1;
				byte b2 = b1 + 2;
				System.out.println(b2);//编译报错
				
			考三：
				byte b = 126 + 1;
				System.out.println(b);//127
				
			考四：
				byte b = 127 + 1;
				System.out.println(b);//编译报错
	
	强制类型转换？
		什么是强制类型转换？
			是指大的数据类型强制转换为小的数据类型
			
		强制类型转换的格式？
			小的数据类型 小的数据类型变量名 = (小的数据类型)大的数据类型变量名
			
			例子：
				int i = 12;
				byte b = i;
				System.out.println(b); //错误写法
				
				---------------------------------
				
				int i = 12;
				byte b = (byte)i;
				System.out.println(b);
				
		注意事项？
			我们能不使用强转尽量不要使用强转
			
			int i = 130;
			byte b = (byte)i;
			System.out.println(b);//-126

	注意：boolean类型是不可以和其他的数据类型相互转换的

4.ASCII编码表
	'a' -> 97
	'A' -> 65
	'0' -> 48
	
5.运算符
	算术运算符：
		+：
			三个含义：
				1.四则运算的+号
				2.正负的正号
				*3.连接符
					任何数据类型的数据与字符串相加，加号都作为连接符
		-
		*
		/：
			整数除以整数，得到的结果也是整数
			
		%：模，取余
			
		++：
			单独使用：
				int i = 1;
				i++; // i = i + 1
				System.out.println(i);//2
				
				-----------------------------
				
				int i = 1;
				++i;
				System.out.println(i);//2
				
				注意：++不管在前，还是在后，对结果来说都没有影响
			
			参与运算：
				++在前：先自身加1，然后再参与运算
					int i = 1;
					System.out.println(++i);
					
					---------------------------
					
					int i = 1;
					int j = ++i;
					System.out.println(i);
					System.out.println(j);
				
				++在后：先参与运算，然后再自身加1
					int i = 1;
					System.out.println(i++);
					
					---------------------------
					
					int i = 1;
					int j = i++;
					System.out.println(i);
					System.out.println(j);
				
			面试题：
				byte b = 1;
				b = b + 1;
				System.out.println(b);//编译报错
				
				----------------------
				
				byte b = 1;
				b++; // b = (byte)(b + 1)
				System.out.println(b);//2
				
				自带强制类型转换
		
		--：
			单独使用：
				int i = 2;
				i--;// i = i - 1
				System.out.println(i);
				
				------------------------
				
				int i = 2;
				--i;// i = i - 1;
				System.out.println(i);
				
				注意：--不管在前，还是在后，对结果来说都没有影响
			
			参与运算：
				--在前：先自身减1，然后再参与运算
					int i = 2;
					System.out.println(--i);
					
					---------------------------
					
					int i = 2;
					int j = --i;
					System.out.println(i);
					System.out.println(j);
				
				--在后：先参与运算，然后再自身减1
					int i = 2;
					System.out.println(i--);
					
					---------------------------
					
					int i = 2;
					int j = i--;
					System.out.println(i);
					System.out.println(j);
					
		练习题：
			int i = 5;
			int j = i++ + ++i + --i + i--;
			System.out.println(j);//24 
	
	赋值运算符：
		=：
			int i = 5;
			
		+=：
			int i = 1;
			i += 1;//i = i + 1
			System.out.println(i);
			
			--------------------------
			
			int i = 1;
			i += 2;// i = i + 2
			System.out.println(i);
		
		-=
		*=
		/=
		%=
		
		注意：自带强制类型转换
	
	关系运算符(条件运算符)： 
		关系运算符的结果一定是boolean类型的数据，要么是true，要么是false
		
		>
		<
		>=
		<=
		!=
		==
	
	逻辑运算符：
		逻辑运算符的两边都只能是boolean类型的数据，得到的结果也必须是boolean类型的数据
		
		&(单与)：
			System.out.println(true & true);//true
			System.out.println(true & false);//false
			System.out.println(false & true);//false
			System.out.println(false & false);//false
			
			*结论：只有两边都为true，结果才为true
		
		|(单或)：
			System.out.println(true | true);//true
			System.out.println(true | false);//true
			System.out.println(false | true);//true
			System.out.println(false | false);//false
			
			*结论：两边只要有一个为true，结果就为true
			
		^(异或)：
			System.out.println(true ^ true);//false
			System.out.println(true ^ false);//true
			System.out.println(false ^ true);//true
			System.out.println(false ^ false);//false
			
			结论：两边相同，为false，两边不同，为true
		
		!(非)：
			System.out.println(true);//true
			System.out.println(!true);//false
			System.out.println(!!true);//true
			System.out.println(!!!true);//false
		
		&&(双与)：
			System.out.println(true && true);//true
			System.out.println(true && false);//false
			System.out.println(false && true);//false
			System.out.println(false && false);//false
			
			*结论：只有两边都为true，结果才为true
		
		||(双或)：
			System.out.println(true || true);//true
			System.out.println(true || false);//true
			System.out.println(false || true);//true
			System.out.println(false || false);//false
			
			*结论：两边只要有一个为true，结果就为true
			
		面试题？
			&和&&的区别？
				&：如果左边为false，右边依然要继续执行，结果一定为false
				&&：如果左边为false，右边就不再执行，结果一定为false
			
			|和||的区别？
				|：如果左边为true，右边依然要继续执行，结果一定为true
				||：如果左边为true，右边就不再执行，结果一定为true
				
			推荐使用&&和||，提高了效率
	
	位运算符：
		位运算符的两边都只能是数值，得到的结果也必须是数值
		
		&(与位运算)：
			3 & 2 = 2
		
		|(或位运算)：
			3 | 2 = 3
			
		^(异或位运算)：
			3 ^ 2 = 1
			
			练习题？
				已知：int i = 1, int j = 2，通过某些方式来实现两个变量的数据的交换？
					方式一：
						使用第三个变量
						
						int i = 1;
						int j = 2;
						int a = i;
						i = j;
						j = a;
						System.out.println(i + "..." + j);
					
					方式二：
						使用异或位运算
						
						int i = 1;
						int j = 2;
						i = i ^ j;
						j = i ^ j;
						i = i ^ j;
						System.out.println(i + "..." + j);
						
		~(按位取反)：
			System.out.println(~3);
			
			注意：符号位也要取反
		
		>>(右移)：
			3 >> 2 = 0
			
			公式： A >> B --> A / 2^B
			
			面试题？
				如何实现最快速的得到4/2=2的结果？
				
				4/2 = 2
				4 >> 1 = 2 效率快，因为这种写法直接操作的是二进制
		
		<<(左移)：
			3 << 2 = 12
			
			公式：A << B --> A * 2^B
		
		>>>(无符号右移)：
			不管符号位是1还是0，右移之后，一律都补0
	
	三元运算符：
















	1.运算符
	三元运算符(三目运算符)：
		格式：
			条件表达式 ? 表达式1 : 表达式2;
			
		执行流程：
			会先判断条件表达式的结果，如果结果为true，会执行表达式1，不会执行表达式2
									  如果结果为false，会执行表达式2，不会执行表达式1
			
		例子：
			int a = true ? 1 : 2;
			System.out.println(a);
			
			---------------------
			
			需求：判断两个数的大小，将大的数打印出来
				int a = 12;
				int b = 13;
				
				int max = a > b ? a : b;
				System.out.println(max);
				
		注意事项？
			1.三元运算符既然是一个运算符，就一定会得到一个结果，所以呢，我们要么将该结果赋值给一个变量，
			要么将该结果在输出语句中输出
				int a = 1 > 3 ? 1 : 3;
				System.out.println(a);
				
				-------------------------------------
				
				System.out.println(1 > 3 ? 1 : 3);
				
			2.当我们将三元运算符的结果赋值给一个变量的时候，变量的数据类型一定要和结果的类型匹配
			
2.键盘录入
	实现键盘录入的步骤？
		第一步：导包
			import java.util.Scanner;
			
			放在class的上面
		
		第二步：创建对象
			Scanner sc = new Scanner(System.in);
		
		第三步：调用方法
			int num = sc.nextInt();
			System.out.println(num);
		
			String s = sc.next();
			System.out.println(s);
			
3.if语句
	格式一：
		if(条件表达式) {
			语句体内容;
		}
	
		执行流程：
			当程序执行到if语句时候，会先看条件表达式的结果是true还是false，
			如果为true，则进入到if语句体中，执行语句体内容
			如果为false，则不会进入到if语句体中，就不会执行到语句体内容
		
		例子：
			if(3 > 2) {
				System.out.println("约吗");
			}
			
			System.out.println("滚犊子");
			
		常见的考试题：
			考一：
				boolean b = true;
				if(b == false) {
					System.out.println("在吗");
				}
				System.out.println("约吗");
				
			考二：
				boolean b = true;
				if(b = false) {
					System.out.println("在吗");
				}
				System.out.println("约吗");
			
			考三：
				boolean b = true;
				if(b);{
					System.out.println("在吗");
				}
				System.out.println("约吗");
				
			考四：
				boolean b = false;
				if(b)
					System.out.println("在吗");
				System.out.println("约吗");
				
				注意：当if语句中的有效语句只有一条的时候，或者没有的时候，花括号可以省略不写
				
			考五：
				boolean b = false;
				if(b)
					int i = 1;
				System.out.println("约吗");//运行报错，int i=1在底层是两条语句
		
	格式二：
		if(条件表达式) {
			语句体内容;
		} else {
			语句体内容;
		}
		
		执行流程：
			当程序执行到if语句的时候，会先看if语句中的条件表达式的结果，
			如果为true，就会进入到if语句中，执行if中的语句体内容，不会执行else中的语句体内容
			如果为false，就不会进入到if语句中执行语句体内容，会进入到else中执行语句体内容
	
		例子：
			if(3 > 2) {
				System.out.println("哈哈");
			} else {
				System.out.println("嘻嘻");
			}
	
		注意：
			if语句的第二种格式是可以和三元运算符互换使用的
			
			if语句写法麻烦一些，但是可读性高一些
			三元运算符写法简单一些，但是可读性差一些
			
	格式三：
		if(条件表达式) {
			语句体内容;
		} else if(条件表达式) {
			语句体内容;
		} else if(条件表达式) {
			语句体内容;
		} ... ...
		else {
			语句体内容;
		}
		
		执行流程：
			当程序执行到if语句的时候，会先看if里的条件表达式是true还是false，
			如果为true，直接进入到if中，执行里面的语句体内容
			如果为false，程序继续向下执行，会看elseif中条件表达式是true还是false,
			如果为true，进入到elseif中执行里面的语句体内容，
			如果为false，程序继续向下执行
			如果if和所有的elseif中的条件表达式都为false，就会进入到else中，执行里面的语句体内容
			
		例子：
			int i = 4;
			if(i > 4) {
				System.out.println("哈哈");
			} else if(i > 3) {
				System.out.println("呵呵");
			} else if(i > 2) {
				System.out.println("嘻嘻");
			} else {
				System.out.println("嘿嘿");
			}
			
		注意：
			当else中没有语句体内容的时候，else是可以省略不写的
			int i = 4;
			if(i > 4) {
				System.out.println("哈哈");
			} else if(i > 3) {
				System.out.println("呵呵");
			} else if(i > 2) {
				System.out.println("嘻嘻");
			} else {
				
			}
			--------------------------------------
			int i = 4;
			if(i > 4) {
				System.out.println("哈哈");
			} else if(i > 3) {
				System.out.println("呵呵");
			} else if(i > 2) {
				System.out.println("嘻嘻");
			}
		
		考试题？
			int a;
			int i = 4;
			if(i > 5) {
				a = 1;
			} else if(i > 4) {
				a = 2;
			} else if(i > 3) {
				a = 3;
			} else if(i > 2) {
				a = 4;
			}
			System.out.println(a);//编译报错
		
4.switch语句
	格式：
		switch(表达式) {
			case 取值1:
				语句体内容;
				break;
			caes 取值2:
				语句体内容;
				break;
			... ...
			default:
				语句体内容;
				break;
		}
		
	执行流程：
		当程序执行到switch语句的时候，就会拿表达式去和第一个case进行匹配，如果匹配成功，就会进入到case中，
		执行里面的语句体内容和break，switch语句结束，如果没有匹配，就继续向下执行，和其他的case继续匹配，
		如果所有的case都不匹配，最后会执行defautl中的语句体内容和break
		
	例子：
		int a = 3;
		switch(a) {
			case 1:
				System.out.println("哈哈");
				break;
			case 2:
				System.out.println("呵呵");
				break;
			case 3:
				System.out.println("嘻嘻");
				break;
			case 4:
				System.out.println("嘿嘿");
				break;
			default:
				System.out.println("嘤嘤");
				break;
		}
	
	我们在使用switch语句需要注意哪些问题？
		1.switch语句中的表达式数据的数据类型可以有哪些？
			byte
			short
			int
			char
			String
			枚举
			
		2.default可以放在任何一行，但是不管放到哪一行，都会优先去找case匹配，如果所有的case都不匹配，才会
		去找defautl
		  default中如果没有内容，default是可以省略不写的，但是建议写上
		  
		3.break关键字可以省略不写，但是如果不写break的话会造成switch穿透
			当匹配完一次case或者执行完一次default之后就不会再进行二次匹配了，但是内容该执行还是要执行的
		
		4.switch语句的结束标记？
			a.break
			b.}
			
	什么时候用switch，什么时候用if？
		如果判断的是某个区间范围，建议使用if
		如果判断的是某几个数据，建议使用switch
		
5.局部代码块
	什么是代码块？
		由一对花括号括起来的就称为代码块
		
		{
			
		}
	
	什么是局部代码块？
		写在main(程序执行的入口)里面的代码块，就称为局部代码块
	
	局部代码块有什么用？
		可以让变量更早的在内存中消失，节省内存空间
		
6.for循环
	需求：在控制台上输出10个1？
		System.out.println(1);
		System.out.println(1);
		System.out.println(1);
		System.out.println(1);
		System.out.println(1);
		System.out.println(1);
		System.out.println(1);
		System.out.println(1);
		System.out.println(1);
		System.out.println(1);
		
	格式：
		for(初始化条件; 判断条件; 控制条件) {
			语句体内容;
		}
		
		初始化条件：一般写变量的定义， int i = 1
		判断条件：关系运算符，结果一定是boolean类型的数据
		控制条件：变量的自增，i++，i+=1
		语句体内容：需要重复执行的代码
		
	执行流程：
		初始化条件 --> 判断条件 --> 语句体内容 --> 控制条件
				   --> 判断条件 --> 语句体内容 --> 控制条件
				   --> 判断条件 --> 语句体内容 --> 控制条件
				   ... ...
				   直到判断条件不满足的，循环结束
				   
	练习：
		需求1：在控制台上输出10个1？
			for(int i = 1; i <= 10; i++) {
				System.out.println(1);
			}
			
		需求2：在控制台上打印出1-10的数字？
			for(int i = 1; i <= 10; i++) {
				System.out.println(i);
			}
			
		需求3：在控制台上打印出1-10的和？(累加和思想)
			int sum = 0; 
			for(int i = 1; i <= 10; i++) {
				sum = sum + i;
			}
			System.out.println(sum);
		
		需求4：在控制台上打印出1-100之间的所有偶数？
			方式一：
				for(int i = 1; i <= 100; i++) {
					//判断i是否为偶数
					if(i % 2 == 0) {
						System.out.println(i);
					}
				}
				
			方式二：
				for(int i = 1; i <= 100; i++) {
					//判断i是否为偶数
					if(i % 2 != 1) {
						System.out.println(i);
					}
				}
				
			方式三：
				for(int i = 2; i <= 100; i+=2) {
					System.out.println(i);
				}
		
		需求5：在控制台上打印出1-10之间的奇数的个数？(统计思想)
			int count = 0; //计数器
			for(int i = 1; i <= 10; i++) {
				//判断i是否为奇数
				if(i % 2 == 1) {
					count++;
				}
			}
			System.out.println(count);
		
7.while循环
	格式：
		初始化条件;
		while(判断条件) {
			语句体内容;
			控制条件;
		}
	
	执行流程：
		初始化条件 --> 判断条件 --> 语句体内容 --> 控制条件
				   --> 判断条件 --> 语句体内容 --> 控制条件
				   --> 判断条件 --> 语句体内容 --> 控制条件
				   ... ...
				   直到判断条件不满足的，循环结束
	
	练习：
		需求1：在控制台上输出10个1？
			int i = 1;
			while(i <= 10) {
				System.out.println(1);
				i++;
			}
			
		需求2：在控制台上打印出1-10的数字？
			int i = 1;
			while(i <= 10) {
				System.out.println(i);
				i++;
			}
			
		需求3：在控制台上打印出1-10的和？(累加和思想)
			int sum = 0;
			int i = 1;
			while(i <= 10) {
				sum += i;
				i++;
			}
			System.out.println(sum);
		
		需求4：在控制台上打印出1-100之间的所有偶数？
			int i = 1;
			while(i <= 100) {
				if(i % 2 == 0) {
					System.out.println(i);
				}
				i++;
			}
		
		需求5：在控制台上打印出1-10之间的奇数的个数？(统计思想)
			int count = 0;
			int i = 1;
			while(i <= 10) {
				if(i % 2 == 1) {
					count++;
				}
				i++;
			}
			System.out.println(count);
		
		
			
			1.do...while循环
	格式：
		初始化条件
		do {
			语句体内容;
			控制条件
		} while(判断条件);
	
	执行流程：
		初始化条件 --> 语句体内容 --> 控制条件 --> 判断条件
					   语句体内容 --> 控制条件 --> 判断条件
					   语句体内容 --> 控制条件 --> 判断条件
					   ... ...
					   语句体内容 --> 控制条件 --> 判断条件不满足的时候，循环结束
	
	练习：
		需求：在控制台上打印出1-10的数字？
			int i = 1;
			do {
				System.out.println(i);
				i++;
			} while(i <= 10);
			
2.三个循环的区别
	*for
	*while
	do...while
	
	for,while和do...while？
		对于for,while来说，语句体内容和控制条件可以一次都不执行，判断条件永远都比控制条件和语句体内容多执行一次
		对于do...while来说，语句体内容和控制条件至少会执行一次，判断条件和语句体内容和控制条件执行的次数一样多
		
	for和while？
		对于for来说，初始化条件出了for循环就在内存中消失了
			for(int i = 1; i <= 10; i++) {

			}
			
			System.out.println(i);//编译报错，因为找不到i变量
			
			变形写法：
			int i;
			for(i = 1; i <= 10; i++) {
			
			}
			System.out.println(i);
		
		对于while来说，初始化条件和while结构体本身就没有关系，出了while训话，照样可以使用
			int i = 1;
			while(i <= 10) {
				i++;
			}
			
			System.out.println(i);
			
		什么时候使用for什么时候使用while？
			明确循环次数建议使用for
			不明确循环次数建议使用while
			
3.break和continue关键字
	*break关键字：
		1.用来switch语句中，作为switch语句结束标记
		2.用来循环中，作为循环的结束标记(结束整个循环)
		
	continue关键字：
		1.用来循环中，作为循环的结束标记(结束本次循环，还会继续下一次循环的)
	
	注意事项？
		for(int i = 1; i <= 10; i++) {
			if(i == 3) {
				break;
				System.out.println(i);
			}
			
			System.out.println(i);
		}
		
		---------------------------------
		
		for(int i = 1; i <= 10; i++) {
			if(i == 3) {
				continue;
				System.out.println(i);
			}
			
			System.out.println(i);
		}
		
		在同一对花括号内，break和continue下面不能有任何语句，因为永远都执行不到
		
4.死循环
	永远出不来的循环
		
	for的死循环：
		for(;;) {
		
		} 
	
	*while的死循环：
		while(true) {
		
		}
		
5.循环的嵌套
	什么是循环的嵌套？
		循环中还有循环
		
	需求：在控制台上打印出由*组成的矩形？
		*****
		*****
		*****
		*****
		
		方式一：
			public class Demo05 {
				public static void main(String[] args) {
					System.out.println("*****");
					System.out.println("*****");
					System.out.println("*****");
					System.out.println("*****");
				}
			}
		
		方式二：
			public class Demo05 {
				public static void main(String[] args) {
					for(int i = 1; i <= 4; i++) {
						System.out.println("*****");
					}
				}
			}
			
		方式三：
			for(int i = 1; i <= 4; i++) {
				for(int j = 1; j <= 5; j++) {
					System.out.print("*");
				}
				System.out.println();//换行
			}
		
		结论：外层循环控制的行数，内层循环控制列数
		
	需求：在控制台上打印出由*组成的直角三角形？
		*
		**
		***
		****
		*****
		
		方式一：
			public class Demo06 {
				public static void main(String[] args) {
					System.out.println("*");
					System.out.println("**");
					System.out.println("***");
					System.out.println("****");
					System.out.println("*****");
				}
			}
			
		方式二：
			for(int i = 1; i <= 5; i++) {
				//外层循环第一次，内层循环1次
				//外层循环第二次，内层循环2次
				for(int j = 1; j <= i; j++) {
					System.out.print("*");
				}
				System.out.println();//换行
			}
		
6.数组
	什么是数组？
		就是一个容器
	
	数组的作用是什么？
		装东西，装数据，方便对数据进行管理和操作的
		
	数组容器的特点是什么？
		1.数组容器一旦初始化，长度就固定了，不可以再改变
		2.数组容器里面既可以存储基本数据类型，也可以存储引用数据类型
		3.一个数组容器中存储的所有的数据的数据类型必须一致
		
	数组的定义格式？
		格式一：
			数据类型[] 数组名 = new 数据类型[数组的长度];
			
			  int[]	    arr   = new int[3];
			  int		arr[] = new int[3];
		
		格式二：
			数据类型[] 数组名 = new 数据类型[]{元素1,元素2, ......};
			
			   int[]    arr   = new int[]{12,13,14};
		
		格式三：
			数据类型[] 数组名 = {元素1,元素2, ......};
			   int[]    arr   = {12,13,14};
			   
	数组容器的使用？
		1.创建数组容器
			int[] arr = new int[3];
		
		2.向数组容器中装东西
			格式：数组名[索引] = 东西;
			
			索引：编号的意思，编号是从0开始
			
			arr[0] = 12;
			arr[1] = 13;
			arr[2] = 14;
		
		3.从数组容器中取东西
			格式：数组名[索引]
			
			int a = arr[0];
			int b = arr[1];
			int c = arr[2];
			System.out.println(a);
			System.out.println(b);
			System.out.println(c);
			
			-------------------------
			
			System.out.println(arr[0]);
			System.out.println(arr[1]);
			System.out.println(arr[2]);
			
	数组的内存图？
		Java中内存有几块？
			*栈
			*堆
			*方法区
			本地方法栈
			寄存器
			
		1.一个数组的内存图？
			int[] arr = new int[3];
			
			System.out.println(arr);
			System.out.println(arr[0]);
			System.out.println(arr[1]);
			System.out.println(arr[2]);
			
			arr[0] = 12;
			arr[1] = 13;
			
			System.out.println(arr[0]);
			System.out.println(arr[1]);
			System.out.println(arr[2]);
			
			详情参考画图
			
		2.二个数组的内存图？
			int[] arr1 = new int[]{12,13,14};
			
			System.out.println(arr1);
			System.out.println(arr1[0]);
			System.out.println(arr1[1]);
			System.out.println(arr1[2]);
			
			arr1[2] = 15;
			
			System.out.println(arr1[0]);
			System.out.println(arr1[1]);
			System.out.println(arr1[2]);
			
			int[] arr2 = {3,4};
			
			System.out.println(arr2);
			System.out.println(arr2[0]);
			System.out.println(arr2[1]);
			
			arr2[1] = 5;
			
			System.out.println(arr2[0]);
			System.out.println(arr2[1]);
		
			详情参考画图
			
		3.一个变量(引用)指向两个数组容器的内存图？
			int[] arr = new int[2];
			
			System.out.println(arr);
			System.out.println(arr[0]);
			System.out.println(arr[1]);

			arr[1] = 12;
			
			System.out.println(arr[0]);
			System.out.println(arr[1]);
			
			arr = new int[3];
			
			System.out.println(arr);
			System.out.println(arr[0]);
			System.out.println(arr[1]);
			
			arr[0] = 13;
			
			System.out.println(arr[0]);
			System.out.println(arr[1]);
			System.out.println(arr[2]);
		
			详情参考画图
			
		4.两个变量(引用)指向了一个数组容器？
			int[] arr1 = new int[2];
			
			System.out.println(arr1);
			System.out.println(arr1[0]);
			System.out.println(arr1[1]);
			
			arr1[0] = 12;
			arr1[1] = 13;
		
			int[] arr2 = arr1;
			
			System.out.println(arr2);
			System.out.println(arr2[0]);
			System.out.println(arr2[1]);
			
			arr2[0] = 15;
			arr2[1] = 16;
			
			System.out.println(arr2[0]);
			System.out.println(arr2[1]);
			
			System.out.println(arr1[0]);
			System.out.println(arr1[1]);
			
			详情参考画图
			
	我们在使用数组的时候遇到最常见的两个异常？
		1.数组索引越界异常(ArrayIndexOutOfBoundsException)
		
			int[] arr = new int[3];
			
			System.out.println(arr);
			System.out.println(arr[0]);
			System.out.println(arr[1]);
			System.out.println(arr[2]);
			System.out.println(arr[3]);//报错
			
		2.空指针异常(NullPointerException)
			int[] arr = {1,2};
			
			System.out.println(arr);
			System.out.println(arr[0]);
			System.out.println(arr[1]);
			
			arr = null;
			
			System.out.println(arr);
			System.out.println(arr[0]);
			System.out.println(arr[1]);
			
			注意：null空常量只能给引用数据类型的变量赋值
				int[] arr = null;
				String s = null;
				
	数组的常见操作？
		1.遍历
			什么是遍历？
				就是将数组容器中的数据挨个获取到
				
			int[] arr = {1,2,3,4,5};
			
			System.out.println(arr[0]);
			System.out.println(arr[1]);
			System.out.println(arr[2]);
			System.out.println(arr[3]);
			System.out.println(arr[4]);
			
			-----------------------------
			
			for(int i = 0; i <= 4; i++) {
				System.out.println(arr[i]);
			}
			
			-----------------------------
			
			获取数组容器的长度：数组名.length
			  arr.length
								  
			数组的最小索引：0
			数组的最大索引：arr.length - 1
			
			/*for(int i = 0; i < arr.length; i++) {
				System.out.println(arr[i]);
			}*/
			
			for(int i = 0; i <= arr.length - 1; i++) {
				System.out.println(arr[i]);
			}
		
		2.获取最值
			最大值，最小值
			
			需求：已知有一个数组，获取数组容器元素最大的值？
				int[] arr = {1,4,3,6,2,5};
				
				方式一：
					int[] arr = {1,4,3,6,2,5};
		
					int max = arr[0];
					
					for(int i = 1; i <= arr.length - 1; i++) {
						if(max < arr[i]) {
							max = arr[i];
						}
					}
					
					System.out.println(max);
					
				方式二：
					int max = 0;
		
					for(int i = 1; i < arr.length; i++) {
						if(arr[max] < arr[i]) {
							max = i;
						}
					}
					
					System.out.println(arr[max]);
		
		3.基本查找
			需求：已知有一个数组容器，我们键盘录入一个数，判断该数在容器中是否存在，存在打印对应的元素索引，
			不存在打印-1？
			
				//创建容器
				int[] arr = {1,2,3,4,5,6,7,8,9,10};
				
				//创建对象
				Scanner sc = new Scanner(System.in);
				System.out.println("请输入一个要查找数字：");
				//调用方法
				int num = sc.nextInt();
				
				//定义一个索引变量
				int index = -1;
				
				//遍历容器
				for (int i = 0; i < arr.length; i++) {
					if(arr[i] == num) {
						index = i;
						break;
					}
				}
				
				System.out.println(index);
			
		4.反转
		5.排序
		
		
		
		
		
		
		1.数组
	数组的常见操作？
		4.反转
			反转前：arr -> {1,2,3,4,5}
			反转后：arr -> {5,4,3,2,1}
			
			方式一：
				//创建数组容器
				int[] arr = {1,2,3,4,5};
				
				//遍历
				for (int i = 0; i < arr.length; i++) {
					System.out.print(arr[i] + " ");
				}
				System.out.println();//换行
				
				//反转
				for(int i = 0; i < arr.length / 2; i++) {
					int temp = arr[i];
					arr[i] = arr[arr.length - 1 - i];
					arr[arr.length - 1 - i] = temp;
				}
				
				//遍历
				for (int i = 0; i < arr.length; i++) {
					System.out.print(arr[i] + " ");
				}
				System.out.println();//换行
			
			方式二：
				//创建数组容器
				int[] arr = {1,2,3,4,5};
				
				//遍历
				for (int i = 0; i < arr.length; i++) {
					System.out.print(arr[i] + " ");
				}
				System.out.println();//换行
				
				//反转
				for(int i = 0,j = arr.length - 1; i < arr.length / 2; i++, j--) {
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
				
				//遍历
				for (int i = 0; i < arr.length; i++) {
					System.out.print(arr[i] + " ");
				}
				System.out.println();//换行
			
		5.排序
			排序前：arr -> {3,5,1,4,2}
			排序后：arr -> {1,2,3,4,5}
			
			方式一：选择排序
				int[] arr = {3,5,1,4,2};
		
				//遍历
				for (int i = 0; i < arr.length; i++) {
					System.out.print(arr[i] + " ");
				}
				System.out.println();//换行
				
				//排序
				for(int i = 0; i < arr.length - 1; i++) {
					for(int j = i + 1; j < arr.length; j++) {
						if(arr[i] > arr[j]) {
							int temp = arr[i];
							arr[i] = arr[j];
							arr[j] = temp;
						}
					}
				}
				
				//遍历
				for (int i = 0; i < arr.length; i++) {
					System.out.print(arr[i] + " ");
				}
				System.out.println();//换行
			
			*方式二：冒泡排序
				int[] arr = {3,5,1,4,2};
		
				//遍历
				for (int i = 0; i < arr.length; i++) {
					System.out.print(arr[i] + " ");
				}
				System.out.println();//换行
				
				//排序
				for(int i = 0; i < arr.length - 1; i++) {
					for(int j = 0; j < arr.length - 1 - i; j++) {
						if(arr[j] > arr[j + 1]) {
							int temp = arr[j];
							arr[j] = arr[j + 1];
							arr[j + 1] = temp;
						}
					}
				}
				
				//遍历
				for (int i = 0; i < arr.length; i++) {
					System.out.print(arr[i] + " ");
				}
				System.out.println();//换行
			
2.二维数组
	什么是二维数组？
		元素是一维数组的数组
		
	二维数组的定义格式？
		格式一：
			数据类型[][] 数组的名字 = new 数据类型[二维数组的长度][一维数组的长度];
			
			    int[][]      arr    = new    int[3][2];
				
				3是什么意思？
					arr中存放了3个一维数组
				2是什么意思？
					每一个一维数组中存放了2个元素
		
		格式二：
			数据类型[][] 数组的名字 = new 数据类型[二维数组的长度][];
			
				int[][]     arr     = new    int[3][];
		
				3是什么意思？
					arr中存放了3个一维数组
					
				每个一维数组中有几个元素呢？
					不确定
		
		格式三：
			数据类型[][] 数组的名字 = {{元素1,元素2,......},{元素1,元素2,......},... ...};
				
				int[][]     arr     = {{1,2}, {3,4,5}, {6}};
				
				二维数组中有几个一维数组？
					3个
		
				每个一维数组中有几个元素？
					2
					3
					1
		
	二维数组的使用？
		1.创建容器
			int[][] arr = new int[3][2];
		
		2.存数据
			arr[0][0] = 1;
			arr[0][1] = 2;
			arr[1][0] = 3;
			arr[1][1] = 4;
			arr[2][0] = 5;
			arr[2][1] = 6;
		
		3.取数据
			System.out.println(arr[0][0]);
			System.out.println(arr[0][1]);
			System.out.println(arr[1][0]);
			System.out.println(arr[1][1]);
			System.out.println(arr[2][0]);
			System.out.println(arr[2][1]);
		
	二维数组的遍历？
		int[][] arr = {{1,2},{3,4,5},{6,7,8,9}};

		for(int i = 0; i < arr.length; i++) {
			for(int j = 0; j < arr[i].length; j++) {
				System.out.print(arr[i][j] + " ");
			}
			System.out.println();
		}
		
2.方法(函数)
	什么是方法？
		具有(特定功能)一段独立的小程序(代码块)
		
	方法的作用？
		1.提高了代码的复用性
		2.提高了代码的维护性
	
	方法的定义格式？
		修饰符 返回值类型 方法名字(数据类型 变量名, 数据类型 变量名, ... ...) {
			语句体内容;
			return 返回值;
		}
		
	怎么写一个方法？
		修饰符：目前为止，固定格式：public static
		
		返回值类型：???
		
		方法名字：标识符，我们自己起的
		
		参数列表：???
		
		语句体内容：实现功能的代码
		
		return 返回值：???
		
		两个明确：
			1.明确参数列表
			2.明确返回值类型
			
		例子：
			需求：定义一个方法，该方法的功能是获取两个整数和？
				public static int getSum(int i, int j) {
					int sum = i + j;
					return sum;
				}
				
	方法的使用？
		方法只有被调用才会执行，不调用是不会执行的
		
		怎么调用？
			1.单独调用
				方法名(参数);
				
				注意：如果方法有返回值，使用单独调用是没有意义的
					  如果方法没有返回值，使用单独调用就有意义了
			
			2.输出调用
				System.out.println(方法名(参数));
				
				注意：如果方法没有返回值，就不能使用输出调用
			
			3.赋值调用
				数据类型 变量名 = 方法名(参数);
				
				注意：如果方法没有返回值，就不能使用赋值调用
				
	
	我们能遇到哪些返回值类型的方法？
		基本数据类型：4类8种
			public static byte aaa() {
				return 1;
			}
			
			public static short bbb() {
				return 1;
			}
			
			public static int ccc() {
				return 1;
			}
			
			public static long ddd() {
				return 1;
			}
			
			public static float eee() {
				return 1.2;
			}
			
			public static double fff() {
				return 1.2;
			}
			
			public static char ggg() {
				return 'a';
			}
			
			public static boolean hhh() {
				return true;
			}
	
		引用数据类型：String、、数组、、类类型(返回值为对象)
			public static String iii() {
				return "约吗";
			}
			
			public static int[] jjj() {
				int[] arr = {1,2,3};
				return arr;
			}
			public static 类名 kkk() {
				int[] arr = {1,2,3};
				return arr;
			}
			
		特别的返回值类型：void
			public static void kkk() {
				return;
			}
	
	方法的注意事项？
		1.方法与方法之间是平级关系，不能嵌套定义
			public static void aaa() {
				public static void bbb() {
				
				}
			}
			
		2.方法的返回值类型和返回值匹配
			public static int aaa() {
				return true;
			}
			
			public static int aaa() {
				return 1.2;
			}
			
			public static String aaa() {
				return 1;
			}
			
			以上三种写法是错误的
		
			public static double aaa() {
				return 1;
			}
			
			public static int aaa() {
				return 'a';
			}
	
			public static char aaa() {
				return 1;
			}
			
			以上三种写法是正确的
	
		3.如果方法没有返回值的时候，返回值类型要写void
			void：是一个关键字，不是一个数据类型，它只能写在返回值类型的位置，代表没有返回值的意思
	
			注意：
				1.当方法的返回值类型为void的时候，只能使用单独调用
				2.当方法的返回值类型为void的时候，return;可以省略不写
					return关键字有什么用？
						1.可以返回一个数据，哪里调用返回到哪里
						2.作为方法的结束标记
							public static int getSum() {
								return 1;
								System.out.println("约吗");
							}
							
							在同一对花括号内，return下面不能有任何语句，因为永远都执行不到
			
							-----------------------------------------
							
							public static int getSum() {
								if(3 > 2) {
									return 1;
								}
								
								System.out.println("约吗");
							}
							
							如果不进入到if，就没有return了
	
							
	
	
	
	
	
	
	1.方法(函数)
	基本数据类型值传递问题和引用数据类型值传递问题？
		基本数据类型值传递问题：
			class Demo {
				public static void main(String[] args) {
					int a = 1;
					int b = 2;
					
					System.out.println(a + "..." + b);
					
					aaa(a, b);
					
					System.out.println(a + "..." + b);
				}
				
				public static void aaa(int a, int b) {
					a = a + 1;
					b = a + 2;
					System.out.println(a + "..." + b);
				}
			}
			
		引用数据类型值传递问题：
			class Demo {
				public static void main(String[] args) {
					int[] arr = {12,13,14};
					
					System.out.println(arr[0]);
					System.out.println(arr[1]);
					System.out.println(arr[2]);
					
					aaa(arr);
					
					System.out.println(arr[0]);
					System.out.println(arr[1]);
					System.out.println(arr[2]);
				}
				
				public static void aaa(int[] arr) {
					System.out.println(arr[0]);
					System.out.println(arr[1]);
					System.out.println(arr[2]);
					
					arr[0] = 1;
					arr[1] = 2;
					arr[2] = 3;
					
					System.out.println(arr[0]);
					System.out.println(arr[1]);
					System.out.println(arr[2]);
				}
			}
			
	形式参数和实际参数？
		什么是形式参数？
			形式参数，也称为形参，是指在定义方法的时候，括号中的参数就是形式参数
			
			public static void aaa(int i, int j) {
			
			}
			
		什么是实际参数？
			实际参数，也称为实参，是指在调用方法的时候，括号中的参数就是实际参数
			
			aaa(1, 2);
			
			----------
			int i = 1;
			int j = 2;
			aaa(i, j);
			
	方法的重载(Overload)？
		什么是方法的重载？
			在一个类中，出现了方法名相同，参数列表不同(参数的个数不同，参数的数据类型不同，对应的顺序位置不同)
			的多个方法，就称为方法的重载
			
		例子：
			public static void aaa() {
			
			}
			
			public static void aaa() {//有错误
			
			}
			
			public static void aaa(int i) {
			
			}
		
			public static void aaa(double i) {
			
			}
			
			public static void aaa(int a, double b) {
			
			}
			
			public static void aaa(double b, int a) {
			
			}
			
			public static void aaa(int x, double y) {//有错误
			
			}
			
			public static int aaa(int x, double y) {//有错误
			
			}
			
		注意：
			方法的重载和返回值类型无关

2.面向对象和面向过程(了解)
	Java语言是一门面向对象的语言
	C语言是一门面向过程的语言
	
	什么是面向对象思想？
		重点强调的是对象
		
	什么是面向过程思想？
		重点强调的是过程
		
	举例子：
		做家务：
			面向过程思想：你要自己去做饭，洗碗，洗衣服，拖地，打扫各种卫生
			面向对象思想：你不用干，你找一个女朋友(对象)，让她去做这些所有的家务事
			
		旅游：
			面向过程思想：我们要自己做好攻略,ppt，选好酒店订票，选好交通工具，准备各种物品，衣服，药品，护肤品
			....
			
			面向对象思想：我们找一个私人订制旅行社(对象)，任何事情全部让旅行社来做
		
	面向过程和面向对象的关系？
		面向对象是基于面向过程的，是建立在面向过程基础之上的
		
	面向对象的好处是什么(我们为什么要学习面向对象呢)？
		1.面向对象是一种更符合我们人类思考习惯的思想
		2.面向对象可以将复杂的事情简单化
		3.面向对象可以将我们程序员从执行者变成指挥者
		
3.类和对象
	什么是类？
		官方：类是事物的属性(外在特征)和行为(具备的功能)的集合
		
		我们想要知道Java中类是什么，就要先知道我们现实生活中的类是什么，因为Java源于现实生活。
		生活中的类是什么？
			很多相似事物的综合，比如说"人类"，我们为什么称为"人类"，因为我们人类的很多地方都是一样的，我们
			都有鼻子嘴巴耳朵眼睛等。我们都有吃喝拉撒睡等功能，因为有很多行为和外在特征都是一样的，所以我们
			聚在一起就称为了"人类"
		
	什么是对象？
		官方：对象是类的具体的存在，体现，实例
		
		比如拿"人类"为例的话，对象就是指人类中的你，我，他，每一个活生生的个体，实体，实例
			
	怎么写一个类？
		定义类要用关键字class
		
		格式：
			class 类名 {
				//属性：外在特征
				//行为：具备的功能
			}
			
		练习：
			需求：写一个描述类：人类
				步骤：
					1.明确我们要描述的是什么事物
					2.去看这个事物有哪些外在特征
					3.去看这个事物有哪些具备的行为功能
					4.去编写代码
					
				class Person {
					//属性：外在特征，成员变量
					String name;
					int age;
					String sex;
					String xingzuo;
					String xuexing;
					
					//行为：具备的功能，成员方法
					public void eat() {
						System.out.println("吃肉");
					}
					
					public void drink() {
						System.out.println("喝水");
					}
					
					public void la() {
						System.out.println("拉");
					}
					
					public void sa() {
						System.out.println("撒");
					}
					
					public void sleep() {
						System.out.println("睡");
					}
				}
			
	怎么使用一个类？
		我们不能说使用一个类，我们真正使用的是类的对象
		
		怎么使用对象呢？
			我要去创建对象，使用对象的属性和行为
			
		创建对象的格式？
			类名 对象名 = new 类名();
			Person p = new Person();
		
		使用属性的格式？
			对象名.属性名
			p.name = "tom";
			p.age = 18;
			p.sex = "男";
			p.xingzuo = "处女座";
			p.xuexing = "AB型";
			
			System.out.println(p.name);
			System.out.println(p.age);
			System.out.println(p.sex);
			System.out.println(p.xingzuo);
			System.out.println(p.xuexing);
		
		使用行为的格式？
			对象名.行为名
			p.eat();
			p.drink();
			p.la();
			p.sa();
			p.sleep();
			
4.成员变量和局部变量
	什么是成员变量？（加载在堆中，与对象有关）
		定义在类中，方法外的变量就是成员变量
		
		class Demo {
			int i;
			
			public void aaa() {
			
			}
		}
	
	什么是局部变量？（加载在栈中，与方法有关）
		定义在方法中，或者方法的声明上的变量就是局部变量
		
		class Demo {
			public void aaa() {
				int i = 1;
			}
			
			public void bbb(int i, int j) {
			
			}
		}
		
	成员变量和局部变量有什么区别呢？
		1.定义位置不同
			成员变量：定义在类中，方法外
			局部变量：定义在方法中，或者方法的声明上
			
		2.存储位置不同
			成员变量：存储到堆中的对象中
			局部变量：存储在栈中的方法中
		
		3.初始化值不同
			成员变量：有默认初始化值
				byte,short,int,long -> 0
				float,double -> 0.0
				boolean -> false
				char -> '\u0000'
				String,其他的引用数据类型 -> null
			
			局部变量：没有默认初始化值，我们必须手动赋值才可以使用的
		
		4.生命周期不同
			成员变量：因为是存储在对象中，所以是随着对象的存在而存在，随着对象的消失而消失
			局部变量：因为是存储在方法中，所以是随着方法的存在而存在，随着方法的消失而消失
		
		5.作用域范围不同
			成员变量：在整个类中都可以使用
			局部变量：在它所在的方法中可以使用，出了方法就用不了了
			
			
			
			
			
			
			
			
			
			1.匿名对象
	什么是匿名对象？
		没有名字的对象就是匿名对象
		
	匿名对象的格式？
		new 类名();
		
		new Person();
		new Dog();
		
	匿名对象调用属性和方法的格式？
		new 类名().属性名
		new 类名().方法名()
		
	匿名对象的特点？
		一次性
		
		匿名对象只能使用一次
		
	匿名对象有什么用？
		匿名对象作为实际参数传递来使用
		
		aaa(new Person());
		
2.封装
	什么是封装？
		封装是指隐藏对象的属性和实现细节，仅对外提供的访问方式
		
	怎么隐藏对象的属性和实现细节？
		只需要在属性的前面加上一个关键字private即可
	
	怎么提供公共的访问方式？
		在类中提供两个方法，一个是setXXX()，一个是getXXX()
	
3.private关键字
	什么是private关键字？
		它是一个修饰符，代表私有的意思，可以修饰成员变量，成员方法和构造方法
		
	private关键字的特点？
		被private关键字所修饰的成员，只能在本类中使用，不能在其他类中使用，从而达到了隐藏的效果
		
	加上private关键字之后的标准代码怎么写？
		class Person {
			private String name;
			private int age;
			
			public void setName(String n) {
				name = n;
			}
			
			public String getName() {
				return name;
			}
			
			public void setAge(int a) {
				age = a;
			}
			
			public int getAge() {
				return age;
			}
		}
	
4.this关键字
	什么是this关键字？
		它代表对象的引用，哪个对象调用this所在的方法，this就代表谁
		
	this关键字有什么用？
		1.解决了同名的局部变量隐藏了成员变量的问题
		2.this可以调用本类成员变量和成员方法
	
	加上this关键字之后的标准代码怎么写？
		class Person {
			private String name;
			private int age;
			
			public void setName(String name) {
				this.name = name;
			}
			
			public String getName() {
				return name;
			}
			
			public void setAge(int age) {
				this.age = age;
			}
			
			public int getAge() {
				return age;
			}
		}
	
5.构造方法
	什么是构造方法？
		方法的名字和类名相同，格式和普通方法的格式不一样的特殊的方法，就称为构造方法
		
	构造方法的格式？
		修饰符 方法名(形式参数) {
		
		}
		
		public Person() {
			
		}
		
	构造方法有什么用？
		1.用来创建对象的
		2.可以给成员变量初始化
	
	构造方法的特点？
		1.构造方法没有返回值类型
		2.构造方法没有返回值
			构造方法有return吗？
				有
		3.构造方法的名字要和类名一样
			普通方法的名字可以和类名一样吗？
				可以
				
	构造方法的注意事项？
		1.我们没有手动给构造方法的时候，系统会默认提供一个空参构造，当我们手动给个构造方法的时候，系统
		默认带的空参构造就消失了
		
		2.构造方法也是方法，既然是方法，也可实现方法的重载，一个类中可以有多个构造方法
		
			通过有参构造给成员变量赋值，和通过setXXX()给成员变量赋值有什么区别？
				通过构造给成员变量赋值是天生的(一次)
				通过setXXX()给成员变量赋值是后天的(N多次)
				
	加上构造方法之后的标准代码怎么写？
		class Person {
			private String name;
			private int age;
			
			public Person() {}
			
			public Person(String name, int age) {
				this.name = name;
				this.age= age;
			}
			
			public void setName(String name) {
				this.name = name;
			}
			
			public String getName() {
				return name;
			}
			
			public void setAge(int age) {
				this.age = age;
			}
			
			public int getAge() {
				return age;
			}
		}
		
	成员变量的初始化过程？
		class Person {
			String name = "tom";
			int age = 18;
			
			public Person() {
				this.name = "jerry";
				this.age = 19;
			}
			
			public void show() {
				System.out.println(name + "..." + age);
			}
		}
		
		class Demo {
			public static void main(String[] args) {
				Person p = new Person();
				p.show();
			}
		}
		
		1.默认初始化	null	 0
		2.显示初始化	tom	18
		3.构造方法初始化	jerry	19
		
6.static关键字
	什么是static关键字？
		它是一个修饰符，代表静态的意思，它可以修饰成员变量和成员方法，不可以修饰构造方法
		
	static关键字特点？
		1.被它所修饰的成员是随着字节码文件对象的加载而加载，是优先于对象存在于内存中的
		2.被它所修饰的成员可以被该类下所有对象所共享
		3.被它所修饰的成员可以通过类名直接调用
		
	static关键字注意事项？
		1.静态方法中不能有this关键字(static修饰的方法可以通过类名调用，所以可以不创建对象，有可能出现没有创建对象直接
					通过类名调用的情况，而this需要创建对象，所以不能共存)
		2.静态方法中只能调用静态的成员变量和成员方法，不能调用非静态的成员变量和成员方法
		  非静态的成员方法中既可以调用非静态的成员，也可以调用静态的成员
		
		
		
		
		1.五子棋
	画棋盘
	
	JavaFX
	
2.继承
	什么是继承？
		一个类的对象可以使用另一个类的对象中的成员，这种关系就称为继承
		
	继承的格式？
		class A {
		
		}
		
		class B extends A {
		
		}
		
		类A：父类，超类，基类
		类B：子类，派生类
	
	继承的好处？
		1.提高了代码的复用性
		2.因为继承使两个类之间产生的关系，这种关系是构成多态的前提条件
		
	继承的弊端？
		提高了代码的耦合性
		
		开发原则：高内聚低耦合
		高内聚：一个人的自身能力越强越好
		低耦合：一个人的关系越少越好
		
	继承的特点？
		Java中类只支持单继承，不可以多继承，可以多层继承，不可以循环继承
		
		单继承：
			class A {
			
			}
			
			class B extends A {
			
			}
		
		多继承：
			class A {
			
			}
			
			class B {
			
			}
			
			class C extends A, B {
			
			}
			
			类不支持多继承
		
		多层继承：
			class A {
			
			}
			
			class B extends A {
			
			}
			
			class C extends B {
			
			}
		
		循环继承：
			class A extends B {
			
			}
			
			class B extends A {
			
			}
		
			类不支持循环继承
		
	继承的注意事项？
		1.子类不能继承父类中被private所修饰的成员变量和成员方法
			class Fu {
				private int i = 2;
				private void eat() {
					System.out.println("吃肉");
				}
			}
			
			class Zi extends Fu {
					
			}
			
			class Demo {
				public static void main(String[] args) {
					Zi zi = new Zi();
					zi.eat();
					System.out.println(zi.i);
				}
			}
			
		2.子类不能继承父类中的构造方法（类名不同）
		
	我们什么时候使用继承呢？
		当两个类之间存在"is a"的关系的时候，就可以使用继承
		
		举例子：
			人类
			学生类
			老师类
			狗类
			动物类
		
			分析：
				人 是(is a) 学生 吗？不一定
				人 是 老师 吗？不一定
				人 是 狗 吗？不是
				人 是 动物 吗？不是
				
				学生 是 人 吗？是
				学生 是 老师 吗？不一定
				学生 是 狗 吗？不是
				学生 是 动物 吗？不是
				
				老师 是 人 吗？是
				老师 是 学生 吗？不一定
				老师 是 狗 吗？不是
				老师 是 动物 吗？不是
				
				class Person {
				
				}
				
				class Student extends Person {
				
				}
				
				class Teacher extends Person {
				
				}
				
				class Animal {
				
				}
				
				class Dog extends Animal {
				
				}
				
		注意：我们不能单单为了获取某个功能而去瞎继承某个类
			class Bird {
				public void fly() {
				
				}
			}
			
			class Person extends Bird {
			
			}
			
	子父类继承之间成员变量之间的关系？
		已知父类中有一个成员变量，子类中有一个成员变量，子类的成员方法中有一个局部变量
		
		a.如果这三个变量的名字都不同的话
			class Fu {
				int i = 1;
			}
			
			class Zi extends Fu {
				int j = 2;
				
				public void print() {
					int a = 3;
					
					System.out.println(a);//3
					System.out.println(j);//2
					System.out.println(i);//1
				}
			}
			
			class Demo {
				public static void main(String[] args) {
					Zi zi = new Zi();
					zi.print();
				}
			}
		
		b.如果这三个变量的名字都相同的话
			class Fu {
				int i = 1;
			}
			
			class Zi extends Fu {
				int i = 2;
				
				public void print() {
					int i = 3;
					
					System.out.println(i);//3
					System.out.println(i);//3
					System.out.println(i);//3
				}
			}
			
			class Demo {
				public static void main(String[] args) {
					Zi zi = new Zi();
					zi.print();
				}
			}
		
		c.如果期望在三个变量名字都相同的情况下依然分别打印不同变量的值？
			class Fu {
				int i = 1;
			}
			
			class Zi extends Fu {
				int i = 2;
				
				public void print() {
					int i = 3;
					
					System.out.println(i);//3
					System.out.println(this.i);//2
					System.out.println(super.i);//1
				}
			}
			
			class Demo {
				public static void main(String[] args) {
					Zi zi = new Zi();
					zi.print();
				}
			}		
	
	子父类继承之间构造方法之间的关系？
		1.子类中每一个构造方法中的第一行默认都有一个super();
			class Fu {
			
			}
			
			class Zi extends Fu {
				public Zi() {
					super();
				}
				
				public Zi(String name) {
					super();
				}
				
				public Zi(int age) {
					super();
				}
				
				public Zi(String name, int age) {
					super();
				}
			}
		
		2.子类中的构造方法中的第一行如果是this(参数)，那默认带的super()也就消失了，也就是说this(参数)和
		super(参数)不能共存
			class Fu {
			
			}
			
			class Zi extends Fu {
				public Zi() {
					this("aaa");
				}
				
				public Zi(String name) {
					//super();
				}
			}
		
		3.子类中所有的构造方法中至少有一个构造方法的第一行是super(参数)，才能初始化父类的变量。
			class Fu {
				public Fu(String name) {
				
				}
			}
			
			class Zi extends Fu {
				public Zi() {
					this("tom");
				}
				
				public Zi(String name) {
					this(18);
				}
				
				public Zi(int age) {
					this("tom", 18);
				}
				
				public Zi(String name, int age) {
					super("tom");
				}
			}
	
	子父类继承之间成员方法之间的关系？
		已知父类中有一个成员方法，子类中有一个成员方法
		
		a.如果这两个方法的名字都不相同的话
			class Fu {
				public void printFu() {
					System.out.println("fu...");
				}
			}
			
			class Zi extends Fu {
				public void printZi() {
					System.out.println("zi...");
				}
			}
			
			class Demo {
				public static void main(String[] arsg) {
					Zi zi = new Zi();
					zi.printZi();
					zi.printFu();
				}
			}
			
		b.如果这两个方法的名字都相同的话
			class Fu {
				public void print() {
					System.out.println("fu...");
				}
			}
			
			class Zi extends Fu {
				public void print() {
					System.out.println("zi...");
				}
			}
			
			class Demo {
				public static void main(String[] arsg) {
					Zi zi = new Zi();
					zi.print();
					zi.print();
				}
			}
			
			这里面涉及到了一个知识点：方法的重写
			
			什么是方法的重写(覆盖)(Override)？
				在子父类继承中，子类中出现了与父类方法声明完全一致的方法，就称为方法的重写(并不完全正确，其中声明的修饰符和返回值在一定情况下可以不同)
				
			方法的重写(Override)和重载(Overload)有什么区别？
				方法重写：在子父类继承中，子类中出现了与父类方法声明完全一致的方法，
						  就称为方法的重写(并不完全正确，其中声明的修饰符和返回值在一定情况下可以不同)
						  
				方法重载：在同一类中，出现了多个方法的名字相同，参数列表不同的方法，就称为方法的重载
				
			重写的注意事项？
				1.子类不能重写父类中被私有的方法
					class Fu {
						private void aaa() {}
					}
					
					class Zi extends Fu {
						@Override
						public void aaa() {
						
						}
					}
					
				2.子类重写父类的方法，要求子类方法修饰符的访问权要大于等于父类方法的修饰符的访问权限
					访问权限修饰符：public > protected > 默认(啥都不写) > private
				
				3.子类重写父类方法，子类方法的返回值类型可以和父类方法的返回值类型不一致，但是是有条件的，
				父亲的方法的返回值类型必须是子类方法的返回值类型的父类型
				
				4.静态方法只能重写静态方法(静态不存在重写)
	
3.super关键字
	什么是super关键字？
		super关键字是父类内存空间的标记，在用法上可以当做父类对象的引用去使用，但是不能说super就是父类对象的
		引用。
		
	super关键字和this关键字有什么用？
		调用成员变量？
			super.变量名
			this.变量名
			
		调用成员方法？
			super.方法名()
			this.方法名()
			
		调用构造方法？
			super(参数);
			this(参数);
			
4.多态
	什么是多态？
		多种形态
		
		是指对象在不同的时刻，表现出来的不同状态
		
		例子：
			水滴
			固态 液态 气态
			
	多态的前提条件？
		1.要有继承
		2.要有方法的重写(没有方法重写也能够构成多态的)
		3.要有父类引用指向子类对象
		
	多态的代码体现？
		class Fu {
			public void print() {}
		}
		
		class Zi extends Fu {//1.要有继承
			public void print() {}//2.要有方法的重写
		}
		
		class Demo {
			public static void main(String[] args) {
				Fu fu = new Zi();//3.要有父类引用指向子类对象
			}
		}
	
	多态间子父类继承间成员变量的关系？
		已知父类中有一个成员变量，子类中有一个成员变量
		
		a.如果这两个变量的名字都不同的话
			class Fu {
				int i = 2;
			}
			
			class Zi extends Fu {
				int j = 1;
			}
			
			class Demo {
				public static void main(String[] args) {
					Fu fu = new Zi();
					System.out.println(fu.i);//2
					System.out.println(fu.j);//编译报错
				}
			}
			
		b.如果这两个变量的名字相同的话
			class Fu {
				int i = 2;
			}
			
			class Zi extends Fu {
				int i = 1;
			}
			
			class Demo {
				public static void main(String[] args) {
					Fu fu = new Zi();
					System.out.println(fu.i);//2
					System.out.println(fu.i);//2
				}
			}
			
		通过结果，我们分析出来父类引用不能使用子类的成员变量
		
		口诀：多态调用成员变量，编译看左边，运行看左边
	
	多态间子父类继承间成员方法的关系？
		已知父类中有一个成员方法，子类中有一个成员方法
		
		a.如果这两个变量的名字都不同的话
			class Fu {
				public void printFu() {
					System.out.println("fu...");
				}
			}
			
			class Zi extends Fu {
				public void printZi() {
					System.out.println("zi....");
				}
			}
			
			class Demo {
				public static void main(String[] args) {
					Fu fu = new Zi();
					fu.printFu();//fu...
					fu.printZi();//编译报错
				}
			}
	
		b.如果这两个方法的名字相同的话
			class Fu {
				public void print() {
					System.out.println("fu...");
				}
			}
			
			class Zi extends Fu {
				public void print() {
					System.out.println("zi....");
				}
			}
			
			class Demo {
				public static void main(String[] args) {
					Fu fu = new Zi();
					fu.print();//zi...
					fu.print();//zi...
				}
			}
		
		通过结果，我们分析出来父类引用不能使用子类的特有成员方法，但是可以使用子类重写的方法
		
		口诀：多态调用成员方法，编译看左边，运行看右边
		
	多态间子父类继承间静态成员方法和静态成员变量的关系？
		class Fu {
			public static void print() {
				System.out.println("fu...");
			}
		}
		
		class Zi extends Fu {
			public static void print() {
				System.out.println("zi....");
			}
		}
		
		class Demo {
			public static void main(String[] args) {
				Fu fu = new Zi();
				fu.print();
			}
		}
		
		-------------------------------------------
		class Fu {
			static int i = 1;
		}
		
		class Zi extends Fu {
			static int i = 2;
		}
		
		class Demo {
			public static void main(String[] args) {
				Fu fu = new Zi();
				System.out.println(fu.i);//1
			}
		}
		
		口诀：多态调用静态成员变量或者静态成员方法，编译看左边，运行看左边
		
	多态的好处是什么？
		提高了代码的扩展性
		
		父类引用作为形式参数，子类对象作为实际参数
		
		public class Demo03 {
			public static void main(String[] args) {
				Dog dog = new Dog();
				AnimalTools.show(dog);
				
				Cat cat = new Cat();
				AnimalTools.show(cat);
				
				Pig pig = new Pig();
				AnimalTools.show(pig);
				
				Tiger tiger = new Tiger();
				AnimalTools.show(tiger);
				
				Bird bird = new Bird();
				AnimalTools.show(bird);
			}
		}

		class Animal {
			public void eat() {
				System.out.println("吃");
			}
		}

		class Dog extends Animal {
			public void eat() {
				System.out.println("吃骨头");
			}
		}

		class Cat extends Animal {
			public void eat() {
				System.out.println("吃鱼");
			}
		}

		class Pig extends Animal {
			public void eat() {
				System.out.println("吃白菜");
			}
		}

		class Tiger extends Animal {
			public void eat() {
				System.out.println("吃肉");
			}
		}

		class Bird extends Animal {
			public void eat() {
				System.out.println("吃虫子");
			}
		}

		class AnimalTools {
			public static void show(Animal animal) {//Animal animal = new Pig();
				animal.eat();
			}
			
			/*public static void show(Dog dog) {
				dog.eat();
			}
			
			public static void show(Cat cat) {
				cat.eat();
			}
			
			public static void show(Pig pig) {
				pig.eat();
			}
			
			public static void show(Tiger tiger) {
				tiger.eat();
			}*/
		}
		
		
		
		
		
	1.多态
	多态好处？
		提高了扩展性
		
	多态的弊端？
		父类引用不能使用子类特有的成员变量和成员方法
		
		怎么解决？
			向下转型可以解决
			
			向上转换：Fu fu = new Zi();
			向下转换：Zi zi = (Zi)fu;
			
		注意事项？
			向下转型转不好容易报异常：ClassCastException 类型转换异常
			
			Animal an = new Dog();
			Pig pig = (Pig)an;
			
	
2.final关键字
	什么是final关键字？
		它是一个修饰符，代表最终的意思，它可以修饰类，修饰变量，修饰方法
		
	final关键字的特点？
		1.被final修饰的变量是常量
			Java中常量的分类？
				1.字面值常量
					整数常量
					小数常量
					字符常量
					字符串常量
					布尔常量
					空常量
					
				2.自定义常量
					被final修饰的变量就变成了自定义常量
		
		2.被final所修饰的成员方法不可以被重写
		
		3.被final所修饰类不可以被继承
		
	注意事项？
		如果一个类的成员变量被final修饰，并且没有赋值的话，会编译报错的
		
		怎么解决？
			1.定义变量的时候直接赋值
			2.构造方法给变量赋值
			
2.代码块
	什么是代码块？
		由一对花括号{}组成的，就称为代码块
		
	代码块的分类？
		局部代码块
		构造代码块
		静态代码块
		同步代码块(以后学)
		
	局部代码块？
		什么是局部代码块？
			定义在方法中的代码块就是局部代码块
		
		局部代码块有什么用？
			尽可能早的让局部变量在内存中消失，节省内存空间
			
			public void show() {
				{
					int i = 1;
				}
				
				/*
					一万行代码
				*/
			}
			
	构造代码块？
		什么是构造代码块？
			定义在类中方法外的代码块就是构造代码块
			
			class Demo {
				{
				
				}
				
				public Demo() {
				
				}
			
				public void show() {
				
				}
			}
		
		构造代码块有什么用？
			构造代码块是在构造方法调用的时候执行，并且优先于构造方法先执行
		
			我们可以将一个类中所有的构造方法中的共性内容抽取出来，放到构造代码块中
		
	静态代码块？
		什么是静态代码块？
			就是在构造代码块之前加上一个关键字static
			
			class A {
				static {
				
				}
			}
		
		静态代码块的作用？
			静态代码块是在字节码文件加载到内存中的时候调用的，所以不管创建该类多少次对象，静态代码块
			只会执行一次
			
			静态代码块可以对数据进行初始化，当数据的初始化只需要加载一次的时候就可以选择使用静态代码块
		
3.抽象类
	什么是抽象类？
		有抽象方法的类就是抽象类
		被abstract修饰的类就是抽象类
		
	什么是抽象方法？
		没有方法体的方法就是抽象方法
	
	抽象类的特点？
		1.抽象类和抽象方法都要被abstract关键字所修饰
			abstract class Fu {
				public abstract void eat();
			}
			
		2.抽象类中可以没有抽象方法，但是有抽象方法的类一定是抽象类
		
		3.抽象类不能创建对象
		
		4.如果一个类继承了抽象类，要么该类也是一个抽象类，就可以不用重写抽象方法，但是如果该类是一个普通类，
		那就必须重写抽象类中的所有的抽象方法
		
	抽象类的成员特点？
		1.成员变量：
			可以有普通的成员变量
				int i;

			可以有静态的成员变量
				static int i;
				
			可以有自定义常量
				final int i = 1;
		
		2.成员方法：
			可以有非抽象的成员方法
			可以有抽象方法
		
		3.构造方法：
			有构造方法，但是不能创建对象（因为没有方法体，创建对象不能调用方法？但是里面可以有正常的成员方法啊）
			
			抽象类的构造方法是为了让子类去调用，给属性初始化的
		
	abstract关键字不能和哪些关键字共存？
		private关键字：被private所修饰的方法不能被重写，被abstract所修饰的方法是需要子类重写的，他们冲突
		
		final关键字：被final所修饰的方法不能被重写，被abstract所修饰的方法是需要子类重写的，他们冲突
		
		static关键字：如果抽象方法上面有static关键字的话，那就说明可以使用类名直接调用，但是类名直接调用
					  一个没有方法体的方法是没有意义的
		
4.接口
	什么是接口？
		比抽象类更加抽象的表现形式，就是接口
		
	接口的定义格式？
		接口不是类
		
		interface 接口名 {
		
		}
	
	接口的使用格式？
		interface Inter {
		
		}
		
		class InterImpl implements Inter {
		
		}
		
	接口的特点？
		1.接口不能创建对象
		2.如果一个类想要实现接口，要么该类是一个普通类，就需要重写接口中的所有的抽象方法。
		  要么该类是一个抽象类，可以不用重写所有的抽象方法
		  
	接口中的成员特点？
		1.成员变量：接口中所有的变量全部都是自定义常量，默认修饰符：public static final
			
		2.成员方法：接口中所有的方法都是抽象方法(这句话是有问题的)，默认修饰符：public abstract
		
		3.构造方法：接口中没有构造方法
		
	类与类，类与接口，接口与接口之间的关系？
		类与类之间的关系：继承关系
			Java中类只支持单继承，不可以多继承，可以多层继承，不可以循环继承
			
		类与接口之间的关系：实现关系
			可以单实现，有可以多实现，有可在继承一个类的同时实现多个接口
		
		接口与接口之间的关系：继承关系
			可以单继承，也可以多继承
		
	接口和抽象类有什么用？
		抽象类：其实就是普通的父类，只不过因为里面有了抽象方法，所以才变成的抽象类
		接口：接口是额外扩展的功能，本身该类不具备这个功能，想要拥有这个功能，就要去实现这个接口即可
		
		例子：
			public class Demo04 {
				 public static void main(String[] args) {
					
				}
			}

			abstract class Animal {
				public abstract void eat();
				
				public void drink() {
					System.out.println("喝水");
				}
			}

			class Dog extends Animal implements Aircraft {
				@Override
				public void eat() {
					System.out.println("吃骨头");
				}
				
				public void run() {
					System.out.println("小跑");
				}
				
				public void fly() {
					System.out.println("上小飞");
				}
			}

			class Cat extends Animal {
				@Override
				public void eat() {
					System.out.println("吃鱼");
				}
				
				public void jump() {
					System.out.println("小跳");
				}
			}

			class Pig extends Animal implements Aircraft, Swim {
				@Override
				public void eat() {
					System.out.println("吃肉");
				}
				
				public void gong() {
					System.out.println("小拱");
				}
				
				public void fly() {
					System.out.println("左右飞");
				}
				
				public void swimming() {
					System.out.println("猪刨");
				}
			}

			//飞行器接口
			interface Aircraft {
				public abstract void fly();
			}

			//游泳接口
			interface Swim {
				public abstract void swimming();
			}
			
			继承：is a
			实现：like a
		
5.包
	什么是包？
		包的本质就是文件夹
	
	怎么创建包？
		文件夹与文件夹之间要用.隔开
		aaa.bbb
		
	包的命名规则？
		包名都是小写的
		
		一般都是公司的域名倒过来，去掉www
		
		www.woniuxy.com
		
		com.woniuxy.xxx
		com.woniuxy.yyy
	
	导包？
		如果两个类不在同一个包下，类A想要使用类B，就需要导包
		
		格式：import 包名.类名

		-java
			-util
				--Scanner.java
		-javafx
			-...
		-com
			-aaa
				--A.java
			-bbb
				--B.java
					package com.bbb;
					
					import com.aaa.A;
					
					class B extends A {
					
					}
					
6.访问权限修饰符
	4个
	public(公共) > protected(受保护) > 默认 > private(私有)
	
				同类中		 同包不同类有继承关系			同包不同类无继承关系			不同包有继承关系			不同包无继承关系
	public			 true			 true					true				  true				  true
	protected			 true			 true					true				  true				  false
	默认的			 true			 true					true				  false				  false
	private			 true			 false					false				  false				  false
	
	一个类的各个组成部分都用什么访问权限修饰符：
		类 public
		成员变量 private
		成员方法 public
		构造方法 public

		
		
		
		1.内部类
	什么是内部类？
		一个类定义在另一个类的里面，里面的类就称为内部类
		
	内部类的特点？
		内部类可以直接使用外部类的成员变量和成员方法，包括私有的成员变量和成员方法。
		外部类不可以直接使用内部类的成员变量和成员方法，但是我们可以间接的使用
		
		class Outer {
			private int i = 1;
			
			private void show() {
				System.out.println("约吗");
			}
			
			class Inner {
				public void print() {
					System.out.println(i);
					show();
				}
			}
		}
		
	内部类的分类？
		1.成员内部类
			什么是成员内部类？
				定义在类中方法外的内部类
			
			不同的修饰符所修饰成员内部类该如何使用？
				class Outer {
					修饰符 class Inner {
					
					}
				}	
				Outer.Inner oi=new Outer().new Inner();
				a.public/protected/默认
					class Outer {
						class Inner {
							int i = 1;
							
							public void print() {
								System.out.println("健康一身轻，跑步去北京");
							}
						}
					}
					
					class Demo {
						public static void main(String[] args) {
							//创建内部类对象
							Outer.Inner oi = new Outer().new Inner();
							System.out.println(oi.i);
							oi.print();
						}
					}
				Outer.Inner oi=new Outer.Inner();
				b.static
					class Outer {
						static class Inner {
							int i = 1;
							
							public void print() {
								System.out.println("健康一身轻，跑步去北京");
							}
						}
					}
					
					import com.inner.Outer.Inner;
					class Demo {
						public static void main(String[] args) {
							//创建内部类对象
							/*Outer.Inner oi = new Outer.Inner();
							System.out.println(oi.i);
							oi.print();*/
							
							Inner inner = new Inner();
							System.out.println(inner.i);
							inner.print();
							
						}
					}
				
				c.private
					class Outer {
						private class Inner {
							int i = 1;
							
							public void print() {
								System.out.println("健康一身轻，跑步去北京");
							}
						}
						
						public void show() {
							Inner inner = new Inner();
							System.out.println(inner.i);
							inner.print();
						}
					}
			
					class Demo {
						public static void main(String[] args) {
							Outer outer = new Outer();
							outer.show();
						}
					}
		
		2.局部内部类
			什么是局部内部类？
				定义在方法中的内部类
				
			局部内部类的使用？
				class Outer {
					public void show() {
						class Inner {
							int i = 2;
							
							public void print() {
								System.out.println("一天一苹果，医生远离我");
							}
						}
						
						Inner inner = new Inner();
						System.out.println(inner.i);
						inner.print();
					}
				}
				
				class Demo {
					public static void main(String[] args) {
						Outer outer = new Outer();
						outer.show();
					}
				}
		
2.匿名内部类
	什么是匿名内部类？（本质是对象）
		没有名字的局部内部类
		*匿名子类对象
		
	匿名内部类的格式？
		new 类名/接口名() {
			可以写重写的方法
			可以写自定义的方法
		};
		
		new Person() {
		
		};

	练习：
		一：
			class Demo {
				public static void main(String[] args) {
					//需求：不全代码，要求能够调用到show方法和print方法，在控制台打印出"约吗"
					new Fu() {
						public void show(Inter inter) {
							inter.print();
						}
					}.show(new Inter() {
						public void print() {
							System.out.println("约吗");
						}
					});
				}
			}

			abstract class Fu {
				public abstract void show(Inter inter);
			}
			
			interface Inter {
				public abstract void print();
			}

		二：
			class Demo {
				public static void main(String[] args) {
					Tools.getInstance.print();
				}
			}
			
			interface Inter {
				public abstract void print();
			}

			//不全代码，在控制台上打印出"约吗"

3.五子棋的落子功能
	画棋盘
	落子
	
	
	
	
	
	
	
	
	
	1.Object类
	什么是Object类？
		类 Object 是类层次结构的根类。
		每个类都使用 Object 作为超类。
		所有对象（包括数组）都实现这个类的方法

	常用的构造方法？
		public Object()
		
	常用的方法有哪些？
		public String toString()：返回该对象的字符串表示，建议所有子类都重写此方法。 
		
			java.lang.Object             @         7852e922
			this.getClass().getName() + '@' + Integer.toHexString(this.hashCode())
			类名		           at 标记符“@”    对象哈希码的无符号十六进制表示

		
			注意：当我们打印对象名的时候，其实默认是调用了对象的toString()
		
		public boolean equals(Object obj):指示其他某个对象是否与此对象“相等”。 
			
			 public boolean equals(Object obj) {
				return (this == obj);
				/*
					==号是什么意思？
						如果==比较的是数值的，就比较数值是否相等
						如果==比较的是引用数据类型的数据的话，就比较是地址值是否相等
				*/
			 }
			 
			 注意：一般我们会重写equals()，来比较两个对象的属性是否完全相同的

2.对象数组
	什么是对象数组？
		就是数组的元素是对象
		
	对象数组的使用？
				
		
3.五子棋
	画棋盘
	落子
	判断胜负
	1.String
	什么是String类？
		String 类代表字符串。Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。
		字符串是一个常量，同时也是一个对象，比如："abc"
		字符串既然是一个常量，它的值是不可以改变的，所以字符串是一个长度不可以改变的字符序列。
		
	常见的构造方法？
		1.public String()：初始化一个新创建的 String 对象，使其表示一个空字符序列
		2.public String(byte[] bytes)：将字节数组转换成字符串
		3.public String(byte[] bytes,int offset,int length)：将字节数组转换成字符串(从指定索引开始，转换几个)
		4.public String(char[] value)：将字符数组转换成字符串
		5.public String(char[] value,int offset,int count)：将字符数组转换成字符串(从指定索引开始，转换几个)
		6.public String(String original)：初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列
		7.String s = "abc"	
		
		常见的面试题？
			考题一：
				通过new出来的字符串对象和通过直接赋值方式创建出来的对象有什么区别？
					new出来的方式在内存中有2个对象（一个对象是指向堆中的地址，另外一个是字符串常量池中的地址）
					直接赋值方式在内存中只有1个对象（指向字符串常量池的地址）
					
			考题二：
				String s1 = "abc";
				String s2 = "abc";
				String s3 = new String("abc");
				System.out.println(s1 == s2);//true
				System.out.println(s1 == s3);//false
				
			考题三：
				String s1 = "abc";
				String s2 = "ab";
				String s3 = s2 + "c";
				System.out.println(s1 == s3);//false
				
			考题四：
				String s1 = "abc";
				String s2 = "ab" + "c";
				System.out.println(s1 == s2);//true				
	
	常见的成员方法？
		1.public char charAt(int index)：返回指定索引处的 char 值
		2.public int compareTo(String anotherString)：按字典顺序比较两个字符串
		3.public String concat(String str)：将指定字符串连接到此字符串的结尾
		4.public boolean contains(String s)：当且仅当此字符串包含指定的 char 值序列时，返回 true
		5.public boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始
		6.public boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束
		7.public boolean equals(Object anObject)：将此字符串与指定的对象比较
		8.public boolean equalsIgnoreCase(String anotherString)：将此 String 与另一个 String 
								比较，不考虑大小写
		9.public byte[] getBytes()：将字符串转换为字节数组
		10.public int indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引
		11.public int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引
		12.public int lastIndexOf(int ch)：返回指定字符在此字符串中最后一次出现处的索引
		13.public int length()：返回此字符串的长度
		14.public String replace(char oldChar,char newChar)：返回一个新的字符串，它是通过用 newChar 
							替换此字符串中出现的所有 oldChar 得到的
		15.public String replace(String target,String replacement)：返回一个新的字符串，
							将新的字符串替换老的字符串
		16.public String substring(int beginIndex)：返回一个新的字符串，它是此字符串的一个子字符串。
						该子字符串从指定索引处的字符开始，直到此字符串末尾
		17.public String substring(int beginIndex,int endIndex)：截取，从哪里截取到哪里，包头不包尾
		18.public char[] toCharArray()：将此字符串转换为一个新的字符数组
		19.public String toLowerCase()：将大写字母变成小写字母
		20.public String toUpperCase()：将小写字母变成大写字母
		21.public String trim()：返回字符串的副本，忽略前导空白和尾部空白
		22.public String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串，切割
	
	练习题？
		1.字符串的遍历
			已知有一个字符串String s = "abcde",要求把每一个字符给遍历出来？
				方式一：
					String s = "abcde";
		
					for(int i = 0; i < s.length(); i++) {
						char ch = s.charAt(i);
						System.out.println(ch);
					}
					
				方式二：
					String s = "abcde";
					
					char[] chs = s.toCharArray();
					for (int i = 0; i < chs.length; i++) {
						System.out.println(chs[i]);
					}
				
				方式三：
					String s = "abcde";
		
					String[] strs = s.split("");
					for (int i = 0; i < strs.length; i++) {
						System.out.println(strs[i]);
					}
				
		2.已知有一个字符串String s = "afdsASFSDasdfjASFDskdfjsdaASFAD"，要求把首字母变大写，其余字母变小写？
			System.out.println(s.substring(0, 1).toUpperCase().concat(s.substring(1).toLowerCase()));
		
2.StringBuilder
	什么是StringBuilder类？
		一个长度可变的字符序列
		
		字符串缓冲区，我们可以把它当成一个容器来使用
		
	StringBuilder缓冲区容器的特点？
		它可以存储任何数据类型的数据，但是一旦存储进去以后，全部变成字符串，最终容器里面会一个完整的字符串
		
	常见的构造方法？
		1.public StringBuilder()：构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符
		2.public StringBuilder(String str)：构造一个字符串生成器，并初始化为指定的字符串内容。
					该字符串生成器的初始容量为 16 加上字符串参数的长度

	常见的成员方法？
		1.public StringBuilder append(Object obj)：追加 Object 参数的字符串表示形式
		2.public int capacity()：返回当前容量
		3.public int length()：返回长度（字符数）。 
		4.public StringBuilder reverse()：将此字符序列用其反转形式取代
		5.public String toString()：将字符串缓冲区转换为字符串类型数据
		
	String和StringBuilder的相互转换？
		String -> StringBuilder
			public StringBuilder(String str)
			
		StringBuilder -> String
			public String toString()
	
	练习题？
		需求：已知有一个字符串String s = "abcde"，要求将字符串中的内容进行反转，然后再遍历字符串打印出来？
			String s = "abcde";
		
			//将字符串转换成字符串缓冲区
			StringBuilder sb = new StringBuilder(s);
			
			//反转
			sb.reverse();
			
			//将字符串缓冲区转换成字符串
			s = sb.toString();
			
			System.out.println(s);
			
	StringBuilder和StringBuffer？
		它们是亲兄弟
		
		StringBuilder中具备的方法StringBuffer也有
		
		它们的区别？
			先不讲(多线程的时候才能讲)

3.Math
	什么是Math类？
		Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数
		Math就是一个数学工具类
			构造方法私有了
			成员方法都是静态的
			
	常见的成员方法？
		1.public static int abs(int a)：返回 int 值的绝对值
		2.public static double ceil(double a)：返回最小的（最接近负无穷大）double 值，该值大于等于参数，
											 并等于某个整数
		3.public static double floor(double a)：返回最大的（最接近正无穷大）double 值，该值小于等于参数，
										     并等于某个整数
		4.public static int max(int a,int b)：返回两个 int 值中较大的一个
		5.public static int min(int a,int b)：返回两个 int 值中较小的一个
		6.public static double pow(double a, double b)：返回第一个参数的第二个参数次幂的值
		7.public static int round(float a)：返回最接近参数的 int
		8.public static double random()：返回带正号的 double 值，该值大于等于 0.0 且小于 1.0
										[0.0, 1.0)
			练习题？
				获取1-100之间的随机正整数？
					(int)(Math.random() * 100 + 1) 
						Math.random() -> [0.0, 1.0)
						Math.random() * 100 -> [0.0, 100.0)
						Math.random() * 100 + 1 -> [1.0, 101.0)
						(int)(Math.random() * 100 + 1) -> [1, 100]
					
					(int)(Math.random() * 100) + 1;
						Math.random() -> [0.0, 1.0)
						Math.random() * 100 -> [0.0, 100.0)
						(int)(Math.random() * 100) -> [0, 99]
						(int)(Math.random() * 100) + 1 -> [1, 100]
						
				获取19-86之间的随机正整数？
				
4.基本数据类型包装类
	什么是基本数据类型包装类呢？
		针对8种基本数据类型包装成的8种引用数据类型
		
			byte	 --->     Byte
			short	 --->     Short
			int      --->     Integer
			long     --->     Long
			float	 --->     Float
			double	 --->     Double
			char	 --->     Character
			boolean  --->     Boolean
			
5.Integer
	
		
		
		


1.Integer
	什么是Integer类？
		Integer 类在对象中包装了一个基本类型 int 的值
		
		int基本数据类型的包装类
		
	常见的构造方法？
		1.public Integer(int value)：可以将int类型转换成Integer类型
		2.public Integer(String s)：可以将数字格式的字符串转换成Integer类型
			注意：如果是非数字格式字符串，会运行报错

	常见的成员方法？
		1.public int intValue()：将Integer类型转换成int类型
		2.*public static int parseInt(String s)：可以将数字格式的字符串转换成int类型
		3.public String toString()：将Integer类型转换成String类型
		4.public static String toString(int i)：将int类型转换String类型
		5.public static Integer valueOf(int i)：将int类型转换成Integer类型
		6.public static Integer valueOf(String s)：可以将数字格式的字符串转换成Integer类型
		
	自动装箱和拆箱？
		什么是自动装箱？
			int -> Integer
			
			举例子：
				Integer in = 12;
				/*
					Integer in = Integer.valueOf(12);
				*/
				System.out.println(in);
			
		什么是自动拆箱？
			Integer -> int
			
			举例子：
				Integer in = new Integer(12);
				int num = in + 1;
				/*
					int num = in.intValue() + 1;
				*/
				System.out.println(num);
	
		自动装箱和拆箱？
			Integer in = new Integer(12);
			in = in + 1;
			/*
				in = Integer.valueOf(in.intValue() + 1);
			*/
			System.out.println(in);//13
			
	常见的面试题？
		考题一：
			Integer in1 = new Integer(127);
			Integer in2 = new Integer(127);
			System.out.println(in1 == in2);//false
			
		考题二：
			Integer in1 = new Integer(128);
			Integer in2 = new Integer(128);
			System.out.println(in1 == in2);//false
			
		考题三：
			Integer in1 = 127;
				/*
					Integer.valueOf(127);
				*/
			Integer in2 = 127;
				/*
					Integer.valueOf(127);
				*/
			System.out.println(in1 == in2);//true
			
		考题四：
			Integer in1 = 128;
				/*
					Integer.valueOf(128);
				*/
			Integer in2 = 128;
				/*
					Integer.valueOf(128);
				*/
			System.out.println(in1 == in2);//false
		
2.System
	什么是System类？
		系统工具类
		构造方法私有了
		成员方法静态的
		
	常见的成员方法？	
		1.public static void exit(int status)：终止当前正在运行的 Java 虚拟机
		2.public static long currentTimeMillis()：返回以毫秒为单位的当前时间，获取当前时间的毫秒值
		3.public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)：
								从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束
				src - 源数组。
				srcPos - 源数组中的起始位置。
				dest - 目标数组。
				destPos - 目标数据中的起始位置。
				length - 要复制的数组元素的数量。
				
3.Date
	什么是Date类？
		日期时间类
		类 Date 表示特定的瞬间，精确到毫秒
				
	常见的构造方法？
		1.public Date()：获取当前系统日期时间对象
		2.public Date(long date)：根据指定的毫秒值获取日期时间对象
		
	常见的成员方法？
		1.public long getTime()：获取date对象的毫秒值
		2.public void setTime(long time)：设置date对象的日期时间
		
	日期的解析和格式化？
		SimpleDateFormat类可以帮助我们实现日期的解析和格式化
	
		日期的格式化：Date -> String
			Date date = new Date();
			//SimpleDateFormat sdf = new SimpleDateFormat();
			//SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss E");
			//SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss E");
			//SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss E");
			SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss E");
			String time = sdf.format(date);
			System.out.println(time);
		
		日期的解析：String -> Date
			String time = "2000-12-12 15:15:15";
			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			Date date = sdf.parse(time);
			System.out.println(date);
			
		练习？
			你在这个世界活了多少天？
				
4.Calendar
	什么是Calendar类？
		日期时间类
		
	常见的成员方法？
		1.public static Calendar getInstance()：使用默认时区和语言环境获得一个日历，获取Calendar对象
		2.public int get(int field)：返回给定日历字段的值
		3.public void set(int field,int value)：将给定的日历字段设置为给定值
		4.public final Date getTime()：获取Date对象
		5.public abstract void add(int field,int amount)：
						根据日历的规则，为给定的日历字段添加或减去指定的时间量
				
	练习题？
		判断某一年是平年还是闰年？
		
5.Arrays
	什么是Arrays类？
		数组工具类
		构造私有
		方法静态
		
	常见的成员方法？
		1.public static void sort(int[] a)：排序
		2.public static String toString(int[] a)：打印数组
		3.public static int[] copyOf(int[] original, int newLength)：复制，扩容用的
			
			
		
			1.UUID
	什么是UUID类？
		表示通用唯一标识符 (UUID) 的类
		
	常见的方法？
		public static UUID randomUUID()：获取UUID对象
		public String toString()：将UUID类型转化为String类型
		
2.Random
	什么是Random类？
		此类的实例用于生成伪随机数流
		
	常见的构造方法？
		public Random()
		
	常见的成员方法？
		public int nextInt(int n)：返回一个伪随机数，它是取自此随机数生成器序列的、在 
									0（包括）和指定值（不包括）之间均匀分布的 int 值
			
	练习？
		获取1-100之间的随机正整数？
			方式一：
				int num = (int)(Math.random() * 100) + 1
			
			方式二：
				int num = new Random().nextInt(100) + 1
		
3.BigDecimal
	什么是BigDecimal类？
		不可变的、任意精度的有符号十进制数
		
		目的：为了解决小数运算的精度损失，为了让数据更加精准
		
	常见的构造方法？
		public BigDecimal(int val)
		public BigDecimal(String val)
		
		注意：如果为了让小数计算的结果更加精确，要使用参数为字符串的构造方法
		
	常见的成员方法？
		public BigDecimal add(BigDecimal augend)：加法运算
		public BigDecimal subtract(BigDecimal subtrahend)：减法运算
		public BigDecimal multiply(BigDecimal multiplicand)：乘法运算
		public BigDecimal divide(BigDecimal divisor)：除法运算
		
		public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)：除法运算(针对除不开的情况)
							第一个参数：此 BigDecimal 要除以的值。
							第二个参数：保留小数点后几位。
							第三个参数：要应用的舍入模式
								public static final int ROUND_DOWN：去尾
								public static final int ROUND_UP：前进
								public static final int ROUND_HALF_UP：四舍五入
							
4.1.8新增加日期时间类
	LocalDate类？
		LocalDate是一个不可变的日期时间对象，表示日期，通常被视为年月日
		2021-12-12
	
	LocalTime类？
		LocalTime是一个不可变的日期时间对象，代表一个时间，通常被看作是小时 - 秒。 时间表示为纳秒精度
		10:10:10.543
	
	LocalDateTime类？
		LocalDateTime是一个不可变的日期时间对象，代表日期时间，通常被视为年 - 月 - 日 - 时 - 分 - 秒
		2021-12-12 10:10:10
		
		常见的成员方法？
			1.获取LocalDateTime对象的方法
				public static LocalDateTime now()：获取当前日期时间对象
				public static LocalDateTime of(int year,
                               Month month,
                               int dayOfMonth,
                               int hour,
                               int minute,
                               int second)：获取指定日期时间对象
			
			2.获取年月日时分秒的方法
				public int getYear()：获取年
				public int getMonthValue()：获取月
				public int getDayOfMonth()：获取日
				public int getHour()：获取时
				public int getMinute()：获取分
				public int getSecond()：获取秒
			
			3.转换方法
				public LocalDate toLocalDate()：将LocalDateTime转换成LocalDate
				public LocalTime toLocalTime():将LocalDateTime转换成LocalTime
			
			4.解析和格式化的方法
				DateTimeFormatter类：
					public static DateTimeFormatter ofPattern(String pattern)
			
				格式化：LocalDateTime -> String
				public String format(DateTimeFormatter formatter)：格式化
					
					LocalDateTime localDateTime = LocalDateTime.now();
					DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss E");
					String time =localDateTime.format(dateTimeFormatter);
					System.out.println(time);
				
				解析：String -> LocalDateTime
				public static LocalDateTime parse(CharSequence text,DateTimeFormatter formatter)
					
					String s = "2022-12-12 12:12:12";
					DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
					LocalDateTime localDateTime = LocalDateTime.parse(s, dateTimeFormatter);
					System.out.println(localDateTime);
			
			5.增量和减量的方法
				plus系列方法
				public LocalDateTime plusXXX(long xxx)：添量或者减量对应的日期时间
			
			6.修改的方法
				with系列方法
				public LocalDateTime withXXX(int xxx)：修改对应的日期时间
				
	练习题？
		已知String s = "2021-12-24"，增加一天时间？
			方式一：Date版本
				String s = "2021-12-24";
		
				//解析：String -> Date
				SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
				Date date = sdf.parse(s);
				
				//增加1天的时间量
				long time = date.getTime();
				time += 1 * 24 * 60 * 60 * 1000;
				date.setTime(time);
				
				//格式化：Date -> String
				String newS = sdf.format(date);
				
				System.out.println(s);
				System.out.println(newS);
			
			
			方式二：LocalDate版本
				String s = "2021-12-24";
		
				DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
				
				//解析：String -> LocalDate
				LocalDate localDate = LocalDate.parse(s, dateTimeFormatter);
				
				//增加1天时间量
				localDate = localDate.plusDays(1);
				
				//格式化：LocalDate -> String
				String newS = localDate.format(dateTimeFormatter);
				
				System.out.println(s);
				System.out.println(newS);
			
5.异常
	什么是异常？
		异常就是程序出现的错误，bug
		
	异常的体系结构？
		Throwable
			-- Error 错误
				非常严重的问题
				一般都是格式语法错误，类找不到或者是内存溢出等，都会引发错误
			
			-- Exception 异常
				中小型的问题
				-- 非RuntimeException(编译时期异常：在编译的使用出现的异常)
					-- ParseException
					
				-- RuntimeException(运行时期异常：在运行的时候出现的异常)
					-- IndexOutOfBoundsException
						-- ArrayIndexOutOfBoundsException
						-- StringIndexOutOfBoundsException
					-- NullPointerException
					-- ClassCastException
					
	异常的处理？
		1.捕获
			格式：
				try {
					出现异常的代码
				} catch(异常类名 变量名) {
					异常的处理方案
				} finally {
					资源的释放
				}
				
				----------------------------
				
				try {
					出现异常的代码
				} finally {
					资源的释放
				}
				
				----------------------------
				try {
					出现异常的代码
				} catch(异常类名 变量名) {
					异常的处理方案
				}
		
		2.抛
		
				
				
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
	
	1.异常
	什么是异常？
		异常就是程序出现的错误，bug
		
	异常的体系结构？
		Throwable
			-- Error 错误
				非常严重的问题
				一般都是格式语法错误，类找不到或者是内存溢出等，都会引发错误
			
			-- Exception 异常
				中小型的问题
				-- 非RuntimeException(编译时期异常：在编译的使用出现的异常)
					-- ParseException
					
				-- RuntimeException(运行时期异常：在运行的时候出现的异常)
					-- IndexOutOfBoundsException
						-- ArrayIndexOutOfBoundsException
						-- StringIndexOutOfBoundsException
					-- NullPointerException
					-- ClassCastException
					
	异常的处理？
		1.捕获
			格式：
				try {
					出现异常的代码
				} catch(异常类名 变量名) {
					异常的处理方案
				} finally {
					资源的释放
				}
				
				----------------------------
				
				try {
					出现异常的代码
				} finally {
					资源的释放
				}
				
				----------------------------
				try {
					出现异常的代码
				} catch(异常类名 变量名) {
					异常的处理方案
				}
		
		2.抛
			1.被动抛
				格式：throws 异常类名
				位置：方法声明上
				
				注意：
					1.哪里调用抛哪里
					2.如果抛的是编译时期异常，接收到的异常的地方需要处理(1.要么继续抛，2.要么捕获)
					  如果抛的是运行时期异常，接收到的异常的地方就不需要处理
					3.在子父类继承中，子类重写父类方法，如果父类方法没有抛异常，子类重写的方法也不能抛异常
					4.在子父类继承中，子类重写父类方法，子类重写的方法所抛的异常不能是父类方法抛的异常的父类类型
			
			2.主动抛
				格式：throw 异常对象
				位置：方法中
				
	自定义异常？
		自己创建一个异常类
		
		public class MyException extends RuntimeException {
			public MyException() {}
			
			public MyException(String message) {
				super(message);
			}
		}
		
2.集合
	什么是集合？
		就是一个容器
		
	集合的作用？
		用来装东西
		
	集合容器的特点？
		1.集合容器长度可以改变
		2.集合容器只能存储引用数据类型的数据(元素只能是对象)
		3.一个集合容器中，可以存储不同引用数据类型的数据
		
	集合容器和数组容器的区别？
		1.
			数组容器：一旦初始化，长度就不可以改变了
			集合容器：长度是可变的
			
		2.
			数组容器：数组容器中既可以存储基本数据类型，也可以存储引用数据类型的数据
			集合容器：集合容器只能存储引用数据类型的数据(元素只能是对象)
				
		3.
			数组容器：一个数组容器中所有的元素的数据类型必须一致
			集合容器：一个集合容器中，可以存储不同引用数据类型的数据
			
	集合的体系结构？
		单列集合：
			Collection 单列集合顶层接口
				-- List 子接口
					-- ArrayList  实现类
					-- LinkedList 实现类
					-- Vector     实现类
					
				-- Set  子接口
					-- HashSet    实现类
					-- TreeSet    实现类
					-- LinkedHashSet 实现类
					
		双列集合：
			Map 双列集合顶层接口
				-- HashMap       实现类
				-- TreeMap       实现类
				-- LinkedHashMap 实现类
				-- Hashtable     实现类
					-- Properties 实现类
				
3.Collection接口
	单列集合顶层接口
	
	常见的成员方法？
		boolean add(Object obj)：添加元素
		boolean addAll(Collection c)：添加一个集合中的所有元素
		void clear()：清空
		boolean isEmpty()：判断容器中是否为空
		boolean contains(Object o)：判断是否包含指定元素
		boolean remove(Object o)： 删除指定元素
		boolean removeIf(Predicate filter)：按照条件删除元素
		int size()： 获取容器的长度
		Object[] toArray()：将集合容器转换成数组容器
		Iterator<E> iterator()：获取迭代器对象
		
	Collection集合容器的遍历？
		方式一：转数组
			//创建集合容器
			Collection c = new ArrayList();
			
			//添加元素
			c.add("aaa");
			c.add("bbb");
			c.add("ccc");
			
			Object[] objs = c.toArray();
			for(int i = 0; i < objs.length; i++) {
				System.out.println(objs[i]);
			}
		
		方式二：迭代器
			//创建集合容器
			Collection c = new ArrayList();
			
			//添加元素
			c.add("aaa");
			c.add("bbb");
			c.add("ccc");
			
			//Iterator iterator()
			Iterator it = c.iterator();
			while(it.hasNext()) {
				Object obj = it.next();
				System.out.println(obj);
			}
		
		方式三：增强for(foreach)
			格式： 
				for(元素的数据类型 变量名 : 容器的名字) {
				
				}
				
			增强for循环底层：使用的是迭代器
			
			//创建集合容器
			Collection c = new ArrayList();
			
			//添加元素
			c.add("aaa");
			c.add("bbb");
			c.add("ccc");
			
			//遍历集合容器
			for(Object obj : c) {
				System.out.println(obj);
			}
	
4.List接口
	List是Collection子接口
	
	特点？
		1.有序的(存入和取出的顺序是一致的)
		2.元素可以重复
		3.有索引
			
	常见的成员方法？
		List接口中大部分方法和Collection中的方法是一样的，
		我们只需要学习特有的方法即可。
		
		void add(int index, Object element)：增
		Object remove(int index)：删
		Object set(int index, Object element)：改
		Object get(int index)：查
				
	List集合容器的遍历？
		方式一：转数组
			//创建集合容器
			List list = new ArrayList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			Object[] objs = list.toArray();
			for (int i = 0; i < objs.length; i++) {
				System.out.println(objs[i]);
			}
		
		方式二：迭代器
			//创建集合容器
			List list = new ArrayList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			Iterator it = list.iterator();
			while(it.hasNext()) {
				Object obj = it.next();
				System.out.println(obj);
			}
		
		方式三：增强for
			//创建集合容器
			List list = new ArrayList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			for (Object obj : list) {
				System.out.println(obj);
			}
		
		方式四：普通for
			//创建集合容器
			List list = new ArrayList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			for(int i = 0; i < list.size(); i++) {
				Object obj = list.get(i);
				System.out.println(obj);
			}
				
5.ArrayList类		
	ArrayList是List的实现类
	
	特点？
		1.有序的(存入和取出的顺序是一致的)
		2.元素可以重复
		3.有索引

	常见的构造方法？
		public ArrayList()：构造一个初始容量为 10 的空列表
	
	常见的成员方法？
		和List是一样的
	
	ArrayList集合的遍历方式？
		方式一：转数组
			//创建集合容器
			ArrayList list = new ArrayList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			Object[] objs = list.toArray();
			for (int i = 0; i < objs.length; i++) {
				System.out.println(objs[i]);
			}
		
		方式二：迭代器
			//创建集合容器
			ArrayList list = new ArrayList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			Iterator it = list.iterator();
			while(it.hasNext()) {
				Object obj = it.next();
				System.out.println(obj);
			}
		
		方式三：增强for
			//创建集合容器
			ArrayList list = new ArrayList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			for (Object obj : list) {
				System.out.println(obj);
			}
		
		方式四：普通for
			//创建集合容器
			ArrayList list = new ArrayList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			for(int i = 0; i < list.size(); i++) {
				Object obj = list.get(i);
				System.out.println(obj);
			}
				
	练习题？
		一：已知有一个ArrayList容器，里面存储以下几个元素："aaa","bbb","aaa","aaa","ccc","ddd",
		要求删除集合容器中所有的"aaa"？
			方式一：迭代器（不能用集合删除其中的某个元素，要用迭代器去删除，娃娃机例子）
			方式二：普通for
				
				
				
				
		1.数据结构
	队列：先进先出，后进后出
	栈：先进后出，后进先出
	数组：查询快，增删慢
		ArrayList集合底层的数据结构就是数组数据结构
	链表：查询慢，增删快
		单向链表和双向链表
		LinkedList集合底层的数据结构就是双向链表数据结构
	二叉树：
		1.普通二叉树
			特点：
				1.二叉树是由节点组成的
				2.二叉树有且只有一个根节点
				3.任何一个节点最多只能有2个子节点
			
		2.二叉查找树
			特点：
				1.二叉树是由节点组成的
				2.二叉树有且只有一个根节点
				3.任何一个节点最多只能有2个子节点
				4.大的放在节点的右边，小的放在节点的左边，也就是说任何节点的
				  左子树都比它小，右子树都比它大
		
		3.二叉平衡树
		4.红黑树

2.LinkedList
	LinkedList是List的实现类
	
	特点？
		1.有序的(存入和取出的顺序是一致的)
		2.元素可以重复
		3.有索引
		
	常见的构造方法？
		public LinkedList()
	
	常见的成员方法？
		和List中的方法是一样
		
		public void addFirst(Object e)
		public void addLast(Object e)
		public Object getFirst()
		public Object getLast()
		public Object removeFirst()
		public Object removeLast()
		
	LinkedList集合容器的遍历？
		方式一：转数组
			//创建集合容器
			LinkedList list = new LinkedList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			Object[] objs = list.toArray();
			for (int i = 0; i < objs.length; i++) {
				System.out.println(objs[i]);
			}
		
		方式二：迭代器
			//创建集合容器
			LinkedList list = new LinkedList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			Iterator it = list.iterator();
			while(it.hasNext()) {
				Object obj = it.next();
				System.out.println(obj);
			}
		
		方式三：增强for
			//创建集合容器
			LinkedList list = new LinkedList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			for (Object obj : list) {
				System.out.println(obj);
			}
		
		方式四：普通for
			//创建集合容器
			LinkedList list = new LinkedList();
			
			//添加元素
			list.add("aaa");
			list.add("bbb");
			list.add("ccc");
			list.add("ddd");
			list.add("eee");
			
			//遍历
			for(int i = 0; i < list.size(); i++) {
				Object obj = list.get(i);
				System.out.println(obj);
			}
		
3.泛型
	什么是泛型？
		是指参数化类型，定义泛型的时候格式很像在定义方法的形参，在使用的时候需要传递具体的数据类型
		
	泛型的格式？
		<E>
		<K, V>
	
	泛型的使用？
		//创建集合容器
		ArrayList<String> al = new ArrayList<String>();
		
		//添加元素
		al.add("aaa");
		al.add("bbb");
		al.add("ccc");
		
		//遍历
		for (String s : al) {
			System.out.println(s);
		}
		--------------------------------------------------
		//创建集合容器
		ArrayList<String> al = new ArrayList<String>();
		
		//添加元素
		al.add("aaa");
		al.add("bbb");
		al.add("ccc");
		
		//遍历
		Iterator<String> it = al.iterator();
		while(it.hasNext()) {
			String s = it.next();
			System.out.println(s);
		}
		
	泛型的作用？
		限制集合中存储的元素的数据类型
		避免强制类型转换
		
	泛型的注意事项？
		1.泛型只能是引用数据类型，不能写基本数据类型
		2.前面的泛型的数据类型要和后面的泛型的数据类型匹配
		3.后面的箭头可以省略不写
			ArrayList<String> al1 = new ArrayList<String>();
			ArrayList<String> al2 = new ArrayList<>();
			ArrayList<String> al3 = new ArrayList();
		
	自定义泛型？
		1.自定义泛型类
			class A<QQ> {
				public void print(QQ q) {
					System.out.println(q);
				}
			}
		
		2.自定义泛型方法
			class B {
				public <E> void print(E e) {
					System.out.println(e);
				}
			}
		
		3.自定义泛型父类(父接口)
			interface Inter<E> {
				public abstract void print(E e);
			}

			class InterImpl<E> implements Inter<E> {
				public void print(E e) {
					System.out.println(e);
				}
			}
			
	泛型通配符？
		1.?
			ArrayList<?> al1 = new ArrayList<String>();
			ArrayList<?> al2 = new ArrayList<Integer>();
			ArrayList<?> al3 = new ArrayList<Character>();
			ArrayList<?> al4 = new ArrayList<Object>();
		
		2.? extends E
			向上限定
			
			ArrayList<? extends Number> al1 = new ArrayList<Number>();
			ArrayList<? extends Number> al2 = new ArrayList<String>();错误
			ArrayList<? extends Number> al3 = new ArrayList<Object>();错误
			ArrayList<? extends Number> al4 = new ArrayList<Integer>();
			ArrayList<? extends Number> al5 = new ArrayList<Double>();
			
		3.? super E
			向下限定
			
			ArrayList<? super Number> al1 = new ArrayList<Number>();
			ArrayList<? super Number> al2 = new ArrayList<Object>();
			ArrayList<? super Number> al3 = new ArrayList<Integer>();错误
			ArrayList<? super Number> al4 = new ArrayList<Double>();错误
			ArrayList<? super Number> al5 = new ArrayList<String>();错误
		
4.Set接口
	Set接口是Collection的子接口
	
	特点：
		1.无序的(存入和取出的顺序不一致)
		2.元素唯一的
		3.无索引
	
	常见的成员方法？
		和Collection是一样的
		
	Set集合的遍历？
		1.方式一：转数组
		2.方式二：迭代器
		3.方式三：增强for
		
5.TreeSet实现类
	TreeSet是Set接口的实现类
	
	特点：
		1.无序的(存入和取出的顺序不一致)
		2.元素唯一的
		3.无索引
		4.可以排序
	
	常见的成员方法？
		和Set接口是一样的
		
	TreeSet集合的遍历？
		1.方式一：转数组
		2.方式二：迭代器
		3.方式三：增强for
		
	练习题？
		题一：创建一个TreeSet集合，里面存储String类型的数据，遍历？
			//创建集合容器
			TreeSet<String> ts = new TreeSet<String>();
			
			//添加元素
			ts.add("aca");
			ts.add("c");
			ts.add("abb");
			
			//遍历集合容器
			for (String s : ts) {
				System.out.println(s);
			}
			
			是根据字符串的字典顺序进行排序，由小到大
	
		题二：创建一个TreeSet集合，里面存储Integer类型的数据，遍历？
			//创建集合容器
			TreeSet<Integer> ts = new TreeSet<Integer>();
			
			//添加元素
			ts.add(12);
			ts.add(11);
			ts.add(15);
			ts.add(14);
			ts.add(13);
			
			//遍历
			for (Integer in : ts) {
				System.out.println(in);
			}
		
			是根据数字大小进行排序，由小到大
		
		题三：创建一个TreeSet集合，里面存储自定义对象，遍历？
			//创建集合容器
			TreeSet<Pig> ts = new TreeSet<Pig>();
			
			//添加元素
			ts.add(new Pig("tom", 18));
			ts.add(new Pig("jack", 18));
			ts.add(new Pig("rose", 17));
			ts.add(new Pig("jerry", 19));
			ts.add(new Pig("tony", 23));
			
			//遍历
			for (Pig p : ts) {
				System.out.println(p);
			}
			
			运行结果会报异常ClassCastException，
			如果想要不报错，正常运行，我们至少要实现2个条件之一：
				1.自然排序
					实现步骤：
						1.自定义一个类，实现Comparable接口
						2.重写compareTo()
						3.在compareTo()方法中写排序规则
						4.创建集合，添加元素，遍历
						
						public int compareTo() {
							return 0; 元素只有一个
							return 正数; 正序排列
							return 负数; 倒叙排列
						}
				
				2.比较器
					实现步骤：
						1.自定义一个类
						2.创建TreeSet集合对象，在有参构造中传递Comparator对象
						3.重写compare()
						4.在compare()方法中写排序规则
						5.添加元素，遍历
		
						public int compare() {
							return 0; 元素只有一个
							return 正数; 正序排列
							return 负数; 倒叙排列
						}
		
		
		
		
		
		
		
		
	
		
		1.数据结构
	队列：先进先出，后进后出
	
	栈：先进后出，后进先出
	
	数组：查询快，增删慢
		ArrayList集合底层的数据结构就是数组数据结构
		
	链表：查询慢，增删快
		单向链表和双向链表
		LinkedList集合底层的数据结构就是双向链表数据结构
		
	二叉树：
		1.普通二叉树
			特点：
				1.二叉树是由节点组成的
				2.二叉树有且只有一个根节点
				3.任何一个节点最多只能有2个子节点
			
		2.二叉查找树
			特点：
				1.二叉树是由节点组成的
				2.二叉树有且只有一个根节点
				3.任何一个节点最多只能有2个子节点
				4.大的放在节点的右边，小的放在节点的左边，也就是说任何节点的
				  左子树都比它小，右子树都比它大
		
		3.平衡二叉树
			自平衡的二叉查找树
			
			特点：
				1.二叉树是由节点组成的
				2.二叉树有且只有一个根节点
				3.任何一个节点最多只能有2个子节点
				4.大的放在节点的右边，小的放在节点的左边，也就是说任何节点的
				  左子树都比它小，右子树都比它大
				5.任何节点的左子树和右子树的高度差不能超过1，一旦超过1就会发生自旋转(左旋和右旋)
		
		4.红黑树
			特点：
				1.节点的颜色要么是黑色要么是红色
				2.根节点必须是黑色的
				3.如果一个节点是红色的，那么它的两个子节点必须是黑色的，也就是说不能出现
				  连续两个红色的节点
				4.如果一个节点没有子节点，那么它默认指向了名为Nil的节点，该节点被称为叶子节点，
				  叶子节点的颜色必须是黑色的
				5.任何节点到其叶子节点这条简单路径上的黑色节点的个数是一样多的

			注意：
				1.节点的默认颜色是红色
				2.如果出现了两个连续的红色节点，怎么办？
					子节点是红色，父节点是红色，出现了连续两个红色
					1.如果叔叔的节点是红色的，那么父节点由红变黑，叔叔节点由红变黑，
					  爷爷节点由黑变红，如果爷爷节点是根节点，由红变黑
					2.如果叔叔的节点是黑色的，那么父节点由红变黑，爷爷节点由黑变红，然后再旋转
			TreeSet集合底层数据结构是红黑树
					
	哈希表：
		哈希值：哈希值是由对象的地址值再结合其他的一系列算法最终得到的一个int类型的数字，可以通过
			    Object类中的hashCode()获取到。
				
		1.7之前：哈希表 = 数组 + 链表 (元素为链表的数组)
		1.7之前：哈希表 = 数组 + 链表 + 红黑树 (元素为链表或者红黑树的数组)
				
2.TreeSet实现类
	TreeSet是Set接口的实现类
	
	特点：
		1.无序的(存入和取出的顺序不一致)
		2.元素唯一的
		3.无索引
		4.可以排序
	
	常见的成员方法？
		和Set接口是一样的
		
	TreeSet集合的遍历？
		1.方式一：转数组
		2.方式二：迭代器
		3.方式三：增强for
		
	练习题？
		题一：创建一个TreeSet集合，里面存储String类型的数据，遍历？
			//创建集合容器
			TreeSet<String> ts = new TreeSet<String>();
			
			//添加元素
			ts.add("aca");
			ts.add("c");
			ts.add("abb");
			
			//遍历集合容器
			for (String s : ts) {
				System.out.println(s);
			}
			
			是根据字符串的字典顺序进行排序，由小到大
	
		题二：创建一个TreeSet集合，里面存储Integer类型的数据，遍历？
			//创建集合容器
			TreeSet<Integer> ts = new TreeSet<Integer>();
			
			//添加元素
			ts.add(12);
			ts.add(11);
			ts.add(15);
			ts.add(14);
			ts.add(13);
			
			//遍历
			for (Integer in : ts) {
				System.out.println(in);
			}
		
			是根据数字大小进行排序，由小到大
		
		题三：创建一个TreeSet集合，里面存储自定义对象，遍历？
			//创建集合容器
			TreeSet<Pig> ts = new TreeSet<Pig>();
			
			//添加元素
			ts.add(new Pig("tom", 18));
			ts.add(new Pig("jack", 18));
			ts.add(new Pig("rose", 17));
			ts.add(new Pig("jerry", 19));
			ts.add(new Pig("tony", 23));
			
			//遍历
			for (Pig p : ts) {
				System.out.println(p);
			}
			
			运行结果会报异常ClassCastException，
			如果想要不报错，正常运行，我们至少要实现2个条件之一：
				1.自然排序
					实现步骤：
						1.自定义一个类，实现Comparable接口
						2.重写compareTo()
						3.在compareTo()方法中写排序规则
						4.创建集合，添加元素，遍历
						
						public int compareTo() {
							return 0; 元素只有一个（去重）
							return 正数; 正序排列
							return 负数; 倒叙排列
						}
						
					练习题？
						需求一：根据人的年龄从小到大排序，如果年龄相同，则去重？
							@Override
							public int compareTo(Person p) {
								//比较年龄
								return this.age - p.age;//（this代表新的，p代表老的旧的）
							}
							
						需求二：根据人的年龄从大到小排序，如果年龄相同，则去重？
							@Override
							public int compareTo(Person p) {
								return p.age - this.age;
							}
						
						需求三：根据人的年龄从小到道排序，如果年龄相同，再按照姓名字典顺序排序，
						        如果姓名也相同，则去重？
							@Override
							public int compareTo(Person p) {							
								//比较年龄
								int num = this.age - p.age;
								
								//比较姓名
								return num == 0 ? this.name.compareTo(p.name) : num;
							}
				
				2.比较器
					实现步骤：
						1.自定义一个类
						2.创建TreeSet集合对象，在有参构造中传递Comparator对象
						3.重写compare()
						4.在compare()方法中写排序规则
						5.添加元素，遍历
		
						public int compare() {
							return 0; 元素只有一个
							return 正数; 正序排列
							return 负数; 倒叙排列
						}
						
					练习题？
						需求一：根据人的年龄从小到大排序，如果年龄相同，则去重？
							TreeSet<Student> ts = new TreeSet<>(new Comparator<Student>() {
								@Override
								public int compare(新Student s1, 老Student s2) {
									//比较年龄：小到大
									return s1.getAge() - s2.getAge();
								}
							});
							
						需求二：根据人的年龄从大到小排序，如果年龄相同，则去重？
							TreeSet<Student> ts = new TreeSet<>(new Comparator<Student>() {
								@Override
								public int compare(Student s1, Student s2) {
									//比较年龄：小到大
									return s2.getAge() - s1.getAge();
								}
							});
						
						需求三：根据人的年龄从小到道排序，如果年龄相同，再按照姓名字典顺序排序，
						        如果姓名也相同，则去重？
							TreeSet<Student> ts = new TreeSet<>(new Comparator<Student>() {
								@Override
								public int compare(Student s1, Student s2) {
									//比较年龄
									int num = s1.getAge() - s2.getAge();
									//比较姓名
									return num == 0 ? s1.getName().compareTo(s2.getName()) : num;
								}
							});
		
3.HashSet实现类
	HashSet是Set接口的实现类
		
	特点：
		1.无序的(存入和取出的顺序不一致)
		2.元素唯一的
		3.无索引
	
	常见的成员方法？
		和Set接口是一样的
		
	TreeSet集合的遍历？
		1.方式一：转数组
		2.方式二：迭代器
		3.方式三：增强for
		
	练习题？
		题一：使用HashSet集合存储String类型的数据，遍历？
			//创建集合容器
			HashSet<String> hs = new HashSet<String>();
			
			//添加元素
			hs.add("aaa");
			hs.add("bbb");
			hs.add("ccc");
			hs.add("bbb");
			hs.add("ddd");
			
			//遍历
			for (String s : hs) {
				System.out.println(s);
			}
			
		题二：使用HashSet集合存储Integer类型的数据，遍历？
			//创建集合容器
			HashSet<Integer> hs = new HashSet<>();
			
			//添加元素
			hs.add(111);
			hs.add(4);
			hs.add(222);
			hs.add(333);
			
			//遍历
			for (Integer in : hs) {
				System.out.println(in);
			}
		
		题三：使用HashSet集合存储自定义类型的数据，遍历？
			HashSet<Pig> hs = new HashSet<>();
		
			hs.add(new Pig("tom", 18));
			hs.add(new Pig("jerry", 18));
			hs.add(new Pig("rose", 17));
			hs.add(new Pig("tom", 18));
			hs.add(new Pig("jack", 23));
			
			for (Pig p : hs) {
				System.out.println(p);
			}
		
			通过测试发现，如果地址值相同，就会去重。
			
			提出新的需求：如果属性值全部相同，要去重？
				重写hashCode()和equals()
				
				@Override
				public int hashCode() {
					return this.name.hashCode() + this.age * 12;
				}
				
				@Override
				public boolean equals(Object obj) {
					Pig p = (Pig)obj;
					return this.name.equals(p.name) && this.age == p.age;
				}
	
4.LinkedHashSet实现类
	LinkedHashSet是Set接口的实现类
	
	特点？
		1.有序的(存入和取出的顺序一致)
		2.元素唯一的
		3.无索引
		
		
		
		
		
		Map 双列集合顶层接口
	-- HashMap 实现类
	-- TreeMap 实现类
	-- LinkedHashMap 实现类
	-- Hashtable 实现类
		-- Properties（最重要的是load方法，可以从加载配置文件）

1.Map接口
	双列集合
	
	特点？
		1.无序的(存入和取出的顺序不一致)
		2.无索引
		3.元素唯一(键唯一，值可以重复)
		4.双列的
		
	常见的成员方法？
		V put(K key,V value)：添加，修改(根据键修改值)
		V get(Object key)：根据键获取值
		V remove(Object key)：根据键删除键值对，返回被删除的值
		int size()：获取集合长度
		void clear()：清空容器
		boolean containsKey(Object key)：判断是否包含指定键
		boolean containsValue(Object value)：判断是否包含指定值
		Collection<V> values()：将所有的值获取到，存储到Collection集合中
		Set<K> keySet()：将所有的键获取到，存储到set集合中
		Set<Map.Entry<K,V>> entrySet()：将键值对对象存储到了Set集合中
		
	集合的遍历？
		方式一：通过键找值
			Set<K> keySet()
			
			//创建集合容器
			Map<String, Integer> map = new HashMap<>();
			
			//添加元素
			map.put("tom", 18);
			map.put("jerry", 18);
			map.put("jack", 19);
			map.put("rose", 19);
			map.put("tony", 20);
			
			//遍历集合
			//Set<K> keySet()
			Set<String> set = map.keySet();
			for(String key : set) {
				Integer value = map.get(key);
				System.out.println(key + "..." + value);
			}
		
		方式二：通过键值对对象找键和值
			Set<Map.Entry<K,V>> entrySet()
			
			//创建集合容器
			Map<String, Integer> map = new HashMap<>();
			
			//添加元素
			map.put("tom", 18);
			map.put("jerry", 18);
			map.put("jack", 19);
			map.put("rose", 19);
			map.put("tony", 20);
			
			//遍历
			//Set<Map.Entry<K,V>> entrySet()
			Set<Entry<String, Integer>> set = map.entrySet();
			for (Entry<String, Integer> entry : set) {
				String key = entry.getKey();
				Integer value = entry.getValue();
				System.out.println(key + "..." + value);
			}
			
2.HashMap实现类
	特点？
		1.无序的(存入和取出的顺序不一致)
		2.无索引
		3.元素唯一(键唯一，值可以重复)
		4.双列的
		
	常见的成员方法？
		和Map是一样的
		
	遍历？
		方式一：通过键找值
		方式二：通过键值对对象找键和值
		
	练习题？
		题一：使用HashMap存储元素，键是String，值是Pig，遍历？
			//创建集合
			HashMap<String, Pig> hm = new HashMap<>();
			
			//添加元素
			hm.put("9527", new Pig("tom", 18));
			hm.put("9528", new Pig("jerry", 19));
			hm.put("9529", new Pig("rose", 20));
			
			//遍历集合
			Set<Entry<String, Pig>> set = hm.entrySet();
			for (Entry<String, Pig> entry : set) {
				String key = entry.getKey();
				Pig value = entry.getValue();
				System.out.println(key + ":" + value.getName() + "..." + value.getAge());
			}
		
		题二：使用HashMap存储元素，键是Pig(属性相同，去重)，值是String，遍历？
			//创建集合容器
			HashMap<Pig, String> hm = new HashMap<>();
			
			//添加元素
			hm.put(new Pig("tom", 18), "9527");
			hm.put(new Pig("jerry", 18), "9528");
			hm.put(new Pig("rose", 19), "9529");
			hm.put(new Pig("tom", 18), "9530");
			
			//遍历
			Set<Pig> set = hm.keySet();
			for (Pig key : set) {
				String value = hm.get(key);
				System.out.println(key.getName() + "..." + key.getAge() + "..." + value);
			}
		
3.TreeMap实现类
	特点？
		1.无序的(存入和取出的顺序不一致)
		2.无索引
		3.元素唯一(键唯一，值可以重复)
		4.双列的
		
	常见的成员方法？
		和Map是一样的
		
	遍历？
		方式一：通过键找值
		方式二：通过键值对对象找键和值	
	
	练习题？
		题一：使用TreeMap存储元素，键是String，值是Person，遍历？
			//创建集合容器
			TreeMap<String,Person> tm = new TreeMap<>();
			
			//添加元素
			tm.put("成都", new Person("tom", 18));
			tm.put("都江堰", new Person("jerry", 19));
			tm.put("眉山", new Person("rose", 19));
			tm.put("乐山", new Person("jack", 20));
			tm.put("乐山", new Person("tony", 21));
			
			//遍历
			for(String key : tm.keySet()) {
				Person value = tm.get(key);
				System.out.println(key + "..." + value.getName() + "..." + value.getAge());
			}
		
		题二：使用TreeMap存储元素，键是Person，值是String，遍历？
			//创建集合容器
			TreeMap<Person,String> tm = new TreeMap<>(new Comparator<Person>() {
				@Override
				public int compare(Person p1, Person p2) {
					int num1 = p2.getAge() - p1.getAge();
					int num2 = num1 == 0 ? p2.getName().compareTo(p1.getName()) : num1;
					return num2;
				}
			});
			
			//添加元素
			tm.put(new Person("tom", 18),"成都");
			tm.put(new Person("jerry", 19),"都江堰");
			tm.put(new Person("rose", 19),"眉山");
			tm.put(new Person("tom", 18),"成都");
			tm.put(new Person("jack", 20),"乐山");
			tm.put(new Person("tony", 21),"乐山");
			
			//遍历
			for(Person key : tm.keySet()) {
				String value = tm.get(key);
				System.out.println(key + "..." + value);
			}
			
4.Collections
	集合工具类

	常见的成员方法？	
		public static <T extends Comparable<? super T>> void sort(List<T> list)：
										根据元素的自然顺序 对指定列表按升序进行排序
		public static <T> void sort(List<T> list,Comparator<? super T> c)： 
										根据指定比较器产生的顺序对指定列表进行排序
		
5.可变参数
	需求：定义一个方法，该方法的功能是获取两个整数和？
		public static int getSum(int i, int j) {
			return i + j;
		}
		
	需求：定义一个方法，该方法的功能是获取三个整数和？
		public static int getSum(int i, int j, int k) {
			return i + j + k;
		}
		
	需求：定义一个方法，该方法的功能是获取四个整数和？
		public static int getSum(int i, int j, int x, int y) {
			return i + j + x + y;
		}
		
	需求：定义一个方法，该方法的功能是获取N个整数和？
		public static int getSum(???) {
			return 
		}

	什么是可变参数？
		参数的个数可以变化的
		
	可变参数的定义格式？
		修饰符 返回值类型 方法的名字(数据类型...变量名) {
			语句体;
			return 返回值;
		}
		
		public static void print(int...a) {
		
		}
		
	可变参数的本质？
		就是数组
		
	注意事项？
		如果一个方法的形参有多个的话，而且还有一个是可变参数的话，那么可变参数必须放在最后面
		
6.递归
	什么是递归？
		递归是指方法内部调用方法本身
		
	递归的注意事项？
		1.递归次数不能太多，太多会容易造成内存溢出
		2.递归要有出口，没有出口会造成死递归
	
	练习题？
		题一：使用递归求N的阶乘
			5! = 5 * 4 * 3 * 2 * 1
	
			public class Demo02 {
				public static void main(String[] args) {
					System.out.println(getJC(5));
				}
				
				//使用递归求N的阶乘
				public static int getJC(int n) {
					if(n == 1) {
						return 1;
					} else {
						return n * getJC(n-1);
					}
				}
			}
	
			1.File类
	什么是File类？
		文件和目录路径名的抽象表示形式
		它就代表文件或者文件夹(目录)，就是将文件或者文件夹封装成File对象来体现的
		
	常见的构造方法？
		public File(String pathname)
		public File(File parent,String child)
		public File(String parent,String child)
	
	常见的成员方法？
		创建相关方法？
			public boolean createNewFile()：创建文件，如果创建成功返回true，创建失败返回false
			public boolean mkdir()：创建文件夹
			public boolean mkdirs()：创建多级文件夹
		
		删除相关方法？
			public boolean delete()：删除文件或者文件夹
			
			注意：
				1.使用该方法删除的文件或者文件夹是不会经过回收站的
				2.该方法不能删除里面有子文件或者子文件夹的文件夹
		
		判断相关方法？
			public boolean exists()：判断指定的文件或者文件夹是否存在
			public boolean isDirectory()：判断file是文件夹吗
			public boolean isFile()：判断file是文件吗
		
		获取相关方法？
			public long length()：获取文件的字节大小
			public String getName()：获取文件或者文件夹的名字
			public String getPath()：获取文件或者文件夹的路径
			public String getAbsolutePath()：获取绝对路径
			public File[] listFiles()：将文件夹中的子文件和子文件夹都封装成file对象，并且存储到了数组容器中
		
2.绝对路径和相对路径
	什么是绝对路径？
		以盘符开始的路径就称为绝对路径
		
		例子：C:\\Users\\apple\\Desktop\\ccc\\ddd
		
	什么是相对路径？
		不以盘符开始的路径就称为相对路径
		
		aaa
		aaa\\bbb
		
		相对于谁？
			相对于当前项目所在目录下
			1.IO流（重点是复制）
	我们学习IO流的目的？
		当我们要操作的数据多的时候，就需要对数据进行存储，方便后期的管理操作。
		这个时候我们就要考虑使用容器来存储，但是呢容器有数组和集合，不管使用哪一个容器，都不能够
		将数据永久性的进行存储。但是有些情况下我们是需要对数据进行永久性的存储，那集合和数组就无法实现了。
		
		这个时候我们就要使用IO流技术来实现这样的需求
		IO流：
			1.将内存中的数据存储到本地磁盘
			2.将本地磁盘中的数据还原到内存中
			
	什么是IO流？
		I：
			Input
			
			输入，读取
			
			将本地磁盘中的数据读取到内存中
		
		O：
			Output
			
			输出，写出
			
			将内存中的数据写出到本地磁盘
			
		流：
			是指数据就像水流一样传输着
			
			水流，电流
			
	IO流的分类？
		按照流向分？
			输入流
			输出流
		
		按照类型分？
			字节流
			字符流
			
		我们平时都怎么这些IO流？
			1.字节输入流
			2.字节输出流
			3.字符输入流
			4.字符输出流
			
	IO流的体系结构？              (一旦是缓冲的输出流，要记得刷新或者释放资源)
		OutputStream 字节输出流的顶层抽象类
			-- *FileOutputStream 
			-- *ObjectOutputStream  （对象操作流，序列化流，操作的类要实现Serializable接口，并且将id变量变为常量）
			-- FilterOutputStream
				-- *BufferedOutputStream（缓冲字节输出流，高效，用了装饰修饰法）
				-- *PrintStream （打印字节输出流）
				
		InputStream 字节输入流的顶层抽象类
			-- *FileInputStream		
			-- *ObjectInputStream	（反序列化流）
			--  FilterInputStream
				-- *BufferedInputStream
		
		Writer 字符输出流的顶层抽象类
			-- *OutputStreamWriter （转换流）
				-- *FileWriter 
			-- *BufferedWriter
			-- *PrintWriter
			
		Reader 字符输入流的顶层抽象类
			-- *InputStreamReader
				-- *FileReader 
			-- *BufferedReader
			
2.FileOutputStream
	字节输出流
	
	常见的构造方法？
		public FileOutputStream(File file)
		public FileOutputStream(String name)
		public FileOutputStream(File file, boolean append)
		public FileOutputStream(String name, boolean append)
		
		注意：如果文件不存在，构造方法也会帮助我们创建出一个文件
	
	常见的成员方法？
		public void write(int b)：向文件中写数据，一次写出一个字节数据
		public void write(byte[] b)：向文件中写数据，一次写出一个字节数组的数据
		public void write(byte[] b,int off,int len)：向文件中写数据，一次写出一个字节数组的一部分
		
		2个小问题？
			1.如何实现追加数据？
				public FileOutputStream(File file, boolean append)
				public FileOutputStream(String name, boolean append)
				
				第二个参数传递true实现追加
			
			2.如何实现换行功能？
				换行符：
					windows：\r\n
					linux：\n
					mac：\r
			
3.FileInputStream
	字节输入流
	
	常见的构造方法？
		public FileInputStream(File file)
		public FileInputStream(String name)
		
		注意：如果文件不存在，则运行报错
	
	常见的成员方法？
		public int read()：读取文件中的数据，一次读取一个字节数据，如果读不到了返回-1
		public int read(byte[] b)：读取文件中的数据，一次读取一个字节数组的数据，如果读不到了返回-1，读到了
									返回读取到的字节个数

4.文件的复制
	方式一：一次读取一个字节，一次写出一个字节
		//创建字节输入流对象
		FileInputStream fis = new FileInputStream("aaa.txt");
		
		//创建字节输出流对象
		FileOutputStream fos = new FileOutputStream("bbb.txt");
		
		//一次读取一个字节，一次写出一个字节
		int by = 0;
		while((by = fis.read()) != -1) {
			fos.write(by);
		}
		
		//释放资源
		fos.close();
		fis.close();
	
	方式二：一次读取一个字节数组，一次写出一个字节数组的一部分
		//创建字节输入流对象
		FileInputStream fis= new FileInputStream("aaa.txt");
		
		//创建字节输出流对象
		FileOutputStream fos = new FileOutputStream("ccc.txt");
		
		//一次读取一个字节数组，一次写出一个字节数组的一部分
		byte[] bys = new byte[1024];
		int len = 0;
		while((len = fis.read(bys)) != -1) {
			fos.write(bys, 0, len);
		}
		
		//释放资源
		fos.close();
		fis.close();
		
5.IO流的异常处理
	//创建字节输入流对象
	FileInputStream fis = null;
	//创建字节输出流对象
	FileOutputStream fos = null;
	try {
		fis = new FileInputStream("aaa.txt");
		fos = new FileOutputStream("ccc.txt");
		
		//一次读取一个字节数组，一次写出一个字节数组的一部分
		byte[] bys = new byte[5];
		int len = 0;
		while((len = fis.read(bys)) != -1) {
			fos.write(bys，0，len);
		}
	} catch(Exception e) {
		e.printStackTrace();
	} finally {
		//释放资源
		if(fos != null) {
			try {
				fos.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
		if(fis != null) {
			try {
				fis.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
	1.BufferedOutputStream
	缓冲字节输出流
	高效字节输出流
	效率高

	常见的构造方法？
		public BufferedOutputStream(OutputStream out)
	
	常见的成员方法？
		和FileOutputStream中的方法是一样的
		
		public void flush()：刷新此缓冲的输出流
			close()和flush()的区别？
				close()用来释放资源的，在释放之前先自动刷新一次，close()方法只能调用一次
				flush()用来刷新的，flush()方法可以调用多次

2.BufferedInputStream
	缓冲字节输入流
	高效字节输入流
	效率高
	
	常见的构造方法？
		public BufferedInputStream(InputStream in)
	
	常见的成员方法？
		和FileInputStream中的方法是一样的
		
3.复制文件
	方式一：普通字节输入流 + 普通字节输出流：一次读取一个字节，一次写出一个字节
	方式二：普通字节输入流 + 普通字节输出流：一次读取一个字节数组，一次写出一个字节数组的一部分
	方式三：高效字节输入流 + 高效字节输出流：一次读取一个字节，一次写出一个字节
		//创建高效字节输入流对象
		BufferedInputStream bis = new BufferedInputStream(new FileInputStream("aaa.txt"));
		
		//创建高效字节输出流对象
		BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bbb.txt"));
		
		//一次读取一个字节，一次写出一个字节
		int by = 0;
		while((by = bis.read()) != -1) {
			bos.write(by);
		}
		
		//释放资源
		bos.close();
		bis.close();
		
	方式四：高效字节输入流 + 高效字节输出流：一次读取一个字节数组，一次写出一个字节数组的一部分
		//创建高效字节输入流对象
		BufferedInputStream bis = new BufferedInputStream(new FileInputStream("aaa.txt"));
		
		//创建高效字节输出流对象
		BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bbb.txt"));
		
		//一次读取一个字节，一次写出一个字节
		int by = 0;
		while((by = bis.read()) != -1) {
			bos.write(by);
		}
		
		//释放资源
		bos.close();
		bis.close();

4.装饰设计模式
	应用场景：
		当我们想要对某个类中的某些方法进行增强的时候，就可以使用装饰设计模式
		
		选择方案：
			1.继承
			2.装饰设计模式
			3.动态代理设计模式
			
	例子：
		1.
			public class Demo01 {
				public static void main(String[] args) {
					托尼 tony = new 托尼();
					tony.eat();
					tony.drink();
					tony.sleep();
					tony.run();
					tony.jump();
					
					钢铁侠 gtx = new 钢铁侠(tony);
					gtx.eat();
					gtx.drink();
					gtx.sleep();
					gtx.run();
					gtx.jump();
				}
			}

			abstract class Person {
				public abstract void eat();
				
				public abstract void drink();
				
				public abstract void sleep();
				
				public abstract void run();
				
				public abstract void jump();
			}

			class 托尼 extends Person {
				@Override
				public void eat() {
					System.out.println("吃肉");
				}

				@Override
				public void drink() {
					System.out.println("喝水");
				}

				@Override
				public void sleep() {
					System.out.println("睡觉");
				}

				@Override
				public void run() {
					System.out.println("正常跑");
				}

				@Override
				public void jump() {
					System.out.println("正常跳");
				}
			}

			class 钢铁侠 extends Person {
				private Person person;
				
				public 钢铁侠(Person person) {//Person person = new 托尼();
					this.person = person;
				}

				@Override
				public void eat() {
					person.eat();//托尼.eat()
				}

				@Override
				public void drink() {
					person.drink();//托尼.drink();
				}

				@Override
				public void sleep() {
					person.sleep();//托尼.sleep();
				}

				@Override
				//方法功能增强了
				public void run() {
					System.out.println("超级跑");
				}

				@Override
				//方法功能增强了
				public void jump() {
					System.out.println("超级跳");
				}
			}
			
		2.
			public class Demo02 {
				public static void main(String[] args) {
					FileInputStream fis = new FileInputStream("aaa.txt");
					int by = fis.read();
					System.out.println(by);
					fis.close();
					
					BufferedInputStream bis = new BufferedInputStream(new FileInputStream("aaa.txt"));
					int by = bis.read();
					System.out.println(by);
					bis.close();
				}
			}

			abstract class InputStream {
				public abstract int read();
				public abstract int read(byte[] bys);
				public abstract void close();
				public abstract void aaa();
				public abstract void bbb();
				public abstract void ccc();
			}

			class FileInputStream extends InputStream {
				public FileInputStream(String path) {
					
				}
				
				@Override
				public int read() {
					xxxooo
					return 0;
				}

				@Override
				public int read(byte[] bys) {
					xxxooo
					return 0;
				}

				@Override
				public void close() {
					xxxooo
				}

				@Override
				public void aaa() {
					xxxooo
				}

				@Override
				public void bbb() {
					xxxooo
				}

				@Override
				public void ccc() {
					xxxooo
				}
			}

			class BufferedInputStream extends InputStream {
				private InputStream is;
				
				public BufferedInputStream(InputStream is) {
					this.is = is;
				}

				@Override
				public int read() {
					增强的代码
					return 0;
				}

				@Override
				public int read(byte[] bys) {
					增强的代码
					return 0;
				}

				@Override
				public void close() {
					is.close();
				}

				@Override
				public void aaa() {
					is.aaa();
				}

				@Override
				public void bbb() {
					is.bbb();
				}

				@Override
				public void ccc() {
					is.ccc();
				}
				
			}
			
5.字符流
	为什么会有字符流呢？
		因为在有些情况下使用字节流是无法完成的
		比如说当我们对有中文文件进行读取操作的时候，就会出现乱码问题
		
		字符流 = 字节流 + 编码表
		
6.编码表
	ASCII：是所有编码表中最最基础的编码表，里面的内容很少，只有26个大小写的英文字母，数字和一些特殊符号组成
	
	GBK：中国的编码表，收录汉字有21003个，一个汉字占2个字节，里面囊括了ASCII
	
	Unicode：
		统一码（Unicode），也叫万国码、单一码，是计算机科学领域里的一项业界标准，包括字符集、编码方案等。
		Unicode是为了解决传统的字符编码方案的局限而产生的，
		它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求
		里面囊括了ASCII
	
		*UTF-8：一个中文占3个字节
		UTF-16：一个中文占2个字节
		UTF-32：一个中文占4个字节
		
7.字符串的编码和解码
	编码？
		字符串变成字节数据
		
		怎么实现编码操作？
			public byte[] getBytes()：使用平台的默认字符集将此 String 编码为 byte数组
			public byte[] getBytes(String charsetName)：使用指定的字符集将此 String 编码为 byte数组
	
	解码？
		字节数据变成字符串
		
		怎么实现解码操作？
			public String(byte[] bytes)：通过使用平台的默认字符集解码指定的 byte 数组
			public String(byte[] bytes,String charsetName)：通过使用指定的 charset 解码指定的 byte 数组

8.FileWriter
	字符输出流（可以写int，char，char【】，String）
	
	常见的构造方法？
		public FileWriter(File file)
		public FileWriter(String fileName)
		public FileWriter(File file, boolean append)
		public FileWriter(String fileName, boolean append)
	
	常见的成员方法？
		public void write(int c)
		public void write(char[] cbuf)
		public void write(char[] cbuf,int off,int len)
		public void write(String str)
		public void write(String str,int off,int len)
		
9.FileReader
	字符输入流
	
	常见的构造方法？
		public FileReader(File file)
		public FileReader(String fileName)
	
	常见的成员方法？
		public int read()
		public int read(char[] cbuf)
		
10.文件复制
	方式五：普通字符输入流 + 普通字符输出流：一次读取一个字符，一次写出一个字符
		//创建字符输入流对象
		FileReader fr = new FileReader("aaa.txt");
		
		//创建字符输出流对象
		FileWriter fw = new FileWriter("bbb.txt");
		
		//一次读取一个字符，一次写出一个字符
		int ch = 0;
		while((ch = fr.read()) != -1) {
			fw.write(ch);
		}
		
		//释放资源
		fw.close();
		fr.close();
	方式六：普通字符输入流 + 普通字符输出流：一次读取一个字符数组，一次写出一个字符的一部分
		//创建字符输入流对象
		FileReader fr = new FileReader("aaa.txt");
		
		//创建字符输出流对象
		FileWriter fw = new FileWriter("ccc.txt");
		
		//一次读取一个字符数组，一次写出一个字符数组的一部分
		char[] chs = new char[1024];
		int len = 0;
		while((len = fr.read(chs)) != -1) {
			fw.write(chs, 0, len);
		}
		
		//释放资源
		fw.close();
		fr.close();

11.BufferedWriter
	缓冲字符输出流
	高效字符输出流
	提高效率
	
	常见的构造方法？
		public BufferedWriter(Writer out)
	
	常见的成员方法？
		和FileWriter是一样的
	
		特有方法：public void newLine()：换行，会根据不同的操作系统变化换行符

12.BufferedReader
	缓冲字符输入流
	高效字符输入流
	提高效率
	
	常见的构造方法？
		public BufferedReader(Reader in)
	常见的成员方法？
		和FileReader是一样的
		
		特有方法：public String readLine()：一次读取一行
		
13.复制文件
	方式七：高效字符输入流 + 高效字符输出流：一次读取一个字符，一次写出一个字符
		//创建高效字符输入流对象
		BufferedReader br = new BufferedReader(new FileReader("Demo01.java"));
		
		//创建高效字符输出流对象
		BufferedWriter bw = new BufferedWriter(new FileWriter("Demo02.java"));
		
		//一次读取一个字符，一次写出一个字符
		int ch = 0;
		while((ch = br.read()) != -1) {
			bw.write(ch);
		}
		
		//释放资源
		bw.close();
		br.close();
	方式八：高效字符输入流 + 高效字符输出流：一次读取一个字符数组，一次写出一个字符数组的一部分
		//创建高效字符输入流对象
		BufferedReader br = new BufferedReader(new FileReader("Demo01.java"));
		
		//创建高效字符输出流对象
		BufferedWriter bw = new BufferedWriter(new FileWriter("Demo03.java"));
		
		//一次读取一个字符数组，一次写出一个字符数组的一部分
		char[] chs = new char[1024];
		int len = 0;
		while((len = br.read(chs)) != -1) {
			bw.write(chs, 0, len);
		}
		
		//释放资源
		bw.close();
		br.close();
	方式九：高效字符输入流 + 高效字符输出流：一次读取一个行，一次写出一行
		//创建高效字符输入流对象
		BufferedReader br = new BufferedReader(new FileReader("Demo01.java"));
		
		//创建高效字符输出流对象
		BufferedWriter bw = new BufferedWriter(new FileWriter("Demo04.java"));
		
		//一次读取一行，一次写出一个字符串
		String line = null;
		while((line = br.readLine()) != null) {
			bw.write(line);
			bw.newLine();
		}
		
		//释放资源
		bw.close();
		br.close();
		
14.字符流和字节流复制文件的区别
	字节流：万能流，也就是说使用字节流复制任何类型的文件都可以
	
	字符流：不是万能流，只能复制我们看得懂的文件
	
	能看懂的文件：
		.txt
		.java
		...
	
	看不懂的文件：
		.jpg
		.mp3
		.mp4
		.avi
	
	
	
	
	
	
	
	
	
1.转换流
	什么是转换流？
		能将字节流转换成字符流的流就称为转换流
		转换流是所有流中唯一可以设置编码的流
		
	a.OutputStreamWriter
		转换字符输出流
		
		常见的构造方法？
			public OutputStreamWriter(OutputStream out)
			public OutputStreamWriter(OutputStream out, String charsetName)
		
		常见的成员方法？
			和FileWriter是一样的
	
	b.InputStreamReader
		转换字符输入流对象
	
		常见的构造方法？
			public InputStreamReader(InputStream in)
			public InputStreamReader(InputStream in,String charsetName)

		常见的成员方法？
			和FileReader是一样的
			
2.复制文件
	方式一：
		//创建转换输入流对象
		InputStreamReader isr = new InputStreamReader(new FileInputStream("aaa.txt"));
		
		//创建转换输出流对象
		OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("bbb.txt"));
		
		//一次读取一个字符，一次写出一个字符
		int ch = 0;
		while((ch = isr.read()) != -1) {
			osw.write(ch);
		}
		
		//释放资源
		osw.close();
		isr.close();
		
	方式二：
		//创建转换输入流对象
		InputStreamReader isr = new InputStreamReader(new FileInputStream("aaa.txt"));
		
		//创建转换输出流对象
		OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("ccc.txt"));
		
		//一次读取一个字符数组，一次写出一个字符数组的一部分
		char[] chs = new char[1024];
		int len = 0;
		while((len = isr.read(chs)) != -1) {
			osw.write(chs, 0, len);
		}
		
		//释放资源
		osw.close();
		isr.close();
	
	方式三：
		//创建高效字符输入流对象
		BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("aaa.txt")));
		
		//创建高效字符输出流对象
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("ddd.txt")));
		
		//一次读取一个字符，一次写出一个字符
		int ch = 0;
		while((ch = br.read()) != -1) {
			bw.write(ch);
		}
		
		//释放资源
		bw.close();
		br.close();
	
	方式四：
		//创建高效字符输入流对象
		BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("aaa.txt")));
		
		//创建高效字符输出流对象
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("eee.txt")));
		
		//一次读取一个字符数组，一次写出一个字符数组的一部分
		char[] chs = new char[1024];
		int len = 0;
		while((len = br.read(chs)) != -1) {
			bw.write(chs, 0, len);
		}
		
		//释放资源
		bw.close();
		br.close();
	
	方式五：
		//创建高效字符输入流对象
		BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("aaa.txt")));
		
		//创建高效字符输出流对象
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("fff.txt")));
		
		//一次读取一行，一次写出一行
		String line = null;
		while((line = br.readLine()) != null) {
			bw.write(line);
			bw.newLine();
		}
		
		//释放资源
		bw.close();
		br.close();	
			
3.打印流
	打印用到的流就是打印流，打印流是一个输出流
	PrintStream
	PrintWriter	
	
	PrintWriter？
		常见的构造方法？
			public PrintWriter(String fileName)
			public PrintWriter(Writer out, boolean autoFlush)
				注意：
					开启自动刷新的条件：
						1.autoFlush为true
						2.println、printf 或 format方法
			
		常见的成员方法？
			和FileWriter是一样的
			
			特有的方法：
				public void println(XXX xxx)
				
			println()和writer()方法的区别？
				1.println()自带换行，writer()不带换行
				2.println()可以接受任意类型的数据，writer()只能几种类型的数据
				3.println()能够开启刷新，writer()不能开启刷新
			
4.复制文件
	方式六：
		写法一：
			//创建高效字符输入流对象
			BufferedReader br = new BufferedReader(new FileReader("aaa.txt"));
			
			//创建打印流对象
			PrintWriter pw = new PrintWriter("bbb.txt");
			
			//一次读取一行，一次打印一行
			String line = null;
			while((line = br.readLine()) != null) {
				pw.println(line);
			}
			
			//释放资源
			pw.close();
			br.close();
		
		写法二：
			//创建高效字符输入流对象
			BufferedReader br = new BufferedReader(new FileReader("aaa.txt"));
			
			//创建打印流对象
			PrintWriter pw = new PrintWriter(new FileWriter("ccc.txt"), true);
			
			//一次读取一行，一次打印一行
			String line = null;
			while((line = br.readLine()) != null) {
				pw.println(line);
			}
			
			//释放资源
			br.close();
			
5.对象操作流
	用来操作对象的流就是对象操作流
	
	注意：想要实现序列化和反序列化操作，该类要实现序列化接口（Serializable）
	
	a.ObjectOutputStream
		序列化流
		
		什么是序列化？
			是指将对象从内存中写出到本地磁盘中
			
			对象 内存 -> 磁盘
			
		常见的构造方法？
			public ObjectOutputStream(OutputStream out)
		
		常见的成员方法？
			public final void writeObject(Object obj)
	
	b.ObjectInputStream（注意要将类中的id变成常量）
		反序列化流
	
		什么是反序列化？
			是指将本地磁盘中的数据还原成内存中的对象
			
			对象 磁盘 -> 内存
			
		常见的构造方法？
			public ObjectInputStream(InputStream in)
		
		常见的构造方法？
			public final Object readObject()

6.Properties
	双列集合
	
	Properties 类表示了一个持久的属性集。
	Properties 可保存在流中或从流中加载。
	属性列表中每个键及其对应值都是一个字符串
	
	常见的构造方法？
		public Properties()
	
	常见的成员方法？
		和map是一样的
		put()
		get()
		
		特有方法？
			public Object setProperty(String key, String value)  设置键值对
			*public String getProperty(String key)	   通过键得到对应的值
			public Set<String> stringPropertyNames()   将全部的键放到set集合中
			
			和IO流相关方法：
			public void store(OutputStream out,String comments)：将集合中的数据存储到文件中
			*public void load(InputStream inStream)：将文件中的数据加载到集合容器中，通过“=”或者“：”来区分键和值

	Properties的作用？
		用来加载配置文件的
			
			
			
			
			
			
			
			
			1.网络编程
	什么是网络编程？
		是指通过我们写好的程序，可以实现互联网端的数据的传输
		网络编程，也叫做Socket编程，也叫做套接字
		
	网络编程三要素？
		1.IP地址
			IP地址就代表了唯一的某个计算机，它就是计算机的唯一标志
			
			IP协议中还有一个非常重要的内容，那就是给因特网上的每台计算机和其它设备都规定了一个唯一的地址，叫做“IP地址”。
			由于有这种唯一的地址，才保证了用户在连网的计算机上操作时，能够高效而且方便地从千千万万台计算机中选出自己所需的对象来。
			IP地址就像是我们的家庭住址一样，如果你要写信给一个人，你就要知道他（她）的地址，这样邮递员才能把信送到。
			计算机发送信息就好比是邮递员，它必须知道唯一的“家庭地址”才能不至于把信送错人家。
			只不过我们的地址是用文字来表示的，计算机的地址用二进制数字表示。
			
			IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。
			IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。
			例：点分十进IP地址（100.4.5.6），实际上是32位二进制数（01100100.00000100.00000101.00000110）。
			
			如何查看计算机的IP地址呢？
				ipconfig
				ipconfig -all
		
		2.端口号
			端口号代表了唯一的某个应用程序，它就是应用程序的唯一标识
			
			通过地址 找到 酒店 -> 通过IP地址 找到 计算机
			通过房号 找到 房间 -> 通过端口号 找到 应用程序
		
			所谓的端口，就好像是门牌号一样，客户端可以通过ip地址找到对应的服务器端，但是服务器端是有很多端口的，
			每个应用程序对应一个端口号，通过类似门牌号的端口号，客户端才能真正的访问到该服务器。
			为了对端口进行区分，将每个端口进行了编号，这就是端口号。
			
			端口号只有整数，范围是从0到65535
			
			如何端口号冲突怎么处理？
				1.换一个端口号
				2.把之前占用端口号的应用程序给关闭了，端口号就释放了，问题怎么知道哪个应用程序占用了呢？
					查看占用端口号的PID(进程ID)
					netstat -ano
					
					在资源管理器中找到pid对应的应用程序，强制停止即可	
		
		3.协议
			协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。
			如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。
			
			为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议（protocol），
			它最终体现为在网络上传输的数据包的格式。
			
			UDP协议
			*TCP协议
			
			网络通信协议
			
2.InetAddress
	此类表示互联网协议 (IP) 地址。
		
	常见的成员方法？
		public static InetAddress getByName(String host)：获取对象
		public String getHostAddress()：获取ip地址字符串表示形式
		public String getHostName()：获取计算机的主机名字
		
3.UDP协议下的数据传输
	UDP协议的特点？
		1.面向无连接
		2.传输速度相对较快
		3.不安全
		
	发送端代码编写？
		步骤：
			1.创建Socket对象
			2.创建数据
			3.创建数据报包对象，将数据封装到里面
			4.发送数据报包对象
			5.释放资源
	
	
	接收端代码编写？
		步骤：
			1.创建Socket对象
			2.创建数据报包对象
			3.接收数据报包对象
			4.解析
			5.释放资源
			
	练习？
		模拟聊天室？
		
4.TCP协议下的数据传输
	TCP协议的特点？
		1.面向有连接
			建立连接(3次握手):
				1. A 对 B 说：你瞅啥
				2. B 对 A 说：瞅你咋地
				3. A 对 B 说：来，咱俩聊聊
			
			断开连接(4次挥手)：
				1. A 对 B 说：我们分手吧
				2. B 对 A 说：好，我知道了
				3. B 对 A 说：你确定吗？你忍心吗？不会后悔吗？
				4. A 对 B 说：我确定了，因为我找到了另一个
		
		2.传输速度相对较慢
		3.相对安全
		
	发送端代码编写？
		步骤：
			1.创建Socket对象
			2.创建数据
			3.获取管道输出流
			4.写出数据
			5.释放资源
	
	接收端代码编写？
		步骤：
			1.创建Socket对象
			2.监听连接
			3.获取管道输入流对象
			4.入读数据
			5.释放资源

		
		
		
		
		1.多线程
	什么是多线程？
		什么是进程？
			开启了一个应用程序，就相当于开启了一个进程
		
		什么是线程？
			线程是进程中的一条执行单元，执行路径
			
		举例子：百度云盘，360安全卫士，迅雷......
		
		什么是并行？
			在同一时刻，多个执行单元在多个CPU上同时执行
		
		什么是并发？
			在同一时间，多个执行单元在一个CPU上交替执行
	
	多线程实现方式？
		方式一：继承Thread
			1.自定义一个类
			2.继承Thread，重写run()
			3.在run()中写线程执行的代码
			4.在main()中创建自定义类的对象
			5.调用start()
		
		方式二：实现Runnable
			1.自定义一个类
			2.实现Runnable，重写run()
			3.在run()中写线程执行的代码
			4.在main()中创建自定义类的对象
			5.在main()中创建Thread类对象，并且将自定义类对象传入其中
			6.调用start()
		
		方式三：实现Callable
			1.自定义一个类
			2.实现Callable，重写call()
			3.在call()中写线程执行的代码
			4.在main()中创建自定义类对象
			5.在main()中创建FutureTask对象，并且将自定义类对象传入其中
			6.在main()中创建Thread类对象，并且将FutureTask对象传入其中
			7.调用start()
			
		三种实现方式的区别？
			实现Runnable和实现Callable？
				优点：扩展性好一些，在实现一个接口的同时还可以继承其他的类
				缺点：代码复杂，而且还不能直接使用Thread线程类中的方法
			
			继承Thread？
				优点：代码简单，也可以直接使用Thread线程类中的方法
				缺点：扩展性差一些，继承了Thread类之后就不能再继承其他的类
				
			实现Callable？
				有返回值
				
	线程类中的常见的方法？
		public final String getName()：获取线程名字
		public final void setName(String name)：设置线程名字
		public static Thread currentThread()：获取当前正在执行的线程对象
		public final void setPriority(int newPriority)：设置优先级
			数字越大，优先级越高，越先执行完
			范围：1-10
			
		public final int getPriority()：获取优先级
		public final void setDaemon(boolean on)：将该线程标记为守护线程或用户线程。
												 当正在运行的线程都是守护线程时，Java 虚拟机退出
		public static void sleep(long millis)：让正在执行的线程睡一会，时间过了自动醒

	线程的生命周期？
		新建状态
		就绪状态
		运行状态
		阻塞状态
		死亡状态
		
	多线程引发的安全问题？		
		举例子：窗口售票问题
			需求：有一个电影院正在上映一场一场非常火爆的电影，共有3个窗口售票，票数总共有100张，售完为止。
				public class Demo09 {
					public static void main(String[] args) {
						Ticket t = new Ticket();
						
						Thread t1 = new Thread(t);
						t1.setName("窗口1");
						t1.start();
						
						Thread t2 = new Thread(t);
						t2.setName("窗口2");
						t2.start();
						
						Thread t3 = new Thread(t);
						t3.setName("窗口3");
						t3.start();
					}
				}

				class Ticket implements Runnable {
					private int tickets = 100;
					
					@Override
					public void run() {
						while(true) {
							if(tickets > 0) {
								try {
									Thread.sleep(500);
								} catch (InterruptedException e) {
									e.printStackTrace();
								}
								
								System.out.println(Thread.currentThread().getName() + "...正在出售第..." + tickets + "...张票");
								tickets--;
							}
						}
					}
				}
				
			产生的问题？
				1.出现了相同的票数
				2.出现了负数票
		
			什么情况下会产生线程安全问题？
				1.多线程的程序中
				2.要有共享资源
				3.操作共享资源的代码至少2条以上
			
			如何解决多线程产生安全问题？
				使用同步机制来解决
				
				方式一：同步代码块
					格式：
						synchronized(锁对象) {
						
						}
						
					注意：锁对象可以是任意对象，但是保证多个线程共用同一把锁对象
				
				方式二：同步方法
					格式：
						修饰符 synchronized 返回值类型 方法名字(形参) {
							
						}
						
					注意：同步方法的锁对象是this
				
				方式三：  
				
				方式四： 
		
		
		1.多线程
	什么是多线程？
		什么是进程？
			开启了一个应用程序，就相当于开启了一个进程
		
		什么是线程？
			线程是进程中的一条执行单元，执行路径
			
		举例子：百度云盘，360安全卫士，迅雷......
		
		什么是并行？
			在同一时刻，多个执行单元在多个CPU上同时执行
		
		什么是并发？
			在同一时间，多个执行单元在一个CPU上交替执行
	
	多线程实现方式？
		方式一：继承Thread
			1.自定义一个类
			2.继承Thread，重写run()
			3.在run()中写线程执行的代码
			4.在main()中创建自定义类的对象
			5.调用start()
		
		方式二：实现Runnable
			1.自定义一个类
			2.实现Runnable，重写run()
			3.在run()中写线程执行的代码
			4.在main()中创建自定义类的对象
			5.在main()中创建Thread类对象，并且将自定义类对象传入其中
			6.调用start()
		
		方式三：实现Callable
			1.自定义一个类
			2.实现Callable，重写call()
			3.在call()中写线程执行的代码
			4.在main()中创建自定义类对象
			5.在main()中创建FutureTask对象，并且将自定义类对象传入其中
			6.在main()中创建Thread类对象，并且将FutureTask对象传入其中
			7.调用start()
			
		三种实现方式的区别？
			实现Runnable和实现Callable？
				优点：扩展性好一些，在实现一个接口的同时还可以继承其他的类
				缺点：代码复杂，而且还不能直接使用Thread线程类中的方法
			
			继承Thread？
				优点：代码简单，也可以直接使用Thread线程类中的方法
				缺点：扩展性差一些，继承了Thread类之后就不能再继承其他的类
				
			实现Callable？
				有返回值，获取返回值的位置要注意放的位置，不然容易卡住（通过FutureTask对象的get
												方法）。
				
	线程类中的常见的方法？
		public final String getName()：获取线程名字
		public final void setName(String name)：设置线程名字
		public static Thread currentThread()：获取当前正在执行的线程对象
		public final void setPriority(int newPriority)：设置优先级
			数字越大，优先级越高，越先执行完
			范围：1-10
			
		public final int getPriority()：获取优先级
		public final void setDaemon(boolean on)：将该线程标记为守护线程或用户线程。
												 当正在运行的线程都是守护线程时，Java 虚拟机退出
		public static void sleep(long millis)：让正在执行的线程睡一会，时间过了自动醒

	线程的生命周期？
		新建状态
		就绪状态
		运行状态
		阻塞状态
		死亡状态
		
	多线程引发的安全问题？		
		举例子：窗口售票问题
			需求：有一个电影院正在上映一场一场非常火爆的电影，共有3个窗口售票，票数总共有100张，售完为止。
				public class Demo09 {
					public static void main(String[] args) {
						Ticket t = new Ticket();
						
						Thread t1 = new Thread(t);
						t1.setName("窗口1");
						t1.start();
						
						Thread t2 = new Thread(t);
						t2.setName("窗口2");
						t2.start();
						
						Thread t3 = new Thread(t);
						t3.setName("窗口3");
						t3.start();
					}
				}

				class Ticket implements Runnable {
					private int tickets = 100;
					
					@Override
					public void run() {
						while(true) {
							if(tickets > 0) {
								try {
									Thread.sleep(500);
								} catch (InterruptedException e) {
									e.printStackTrace();
								}
								
								System.out.println(Thread.currentThread().getName() + "...正在出售第..." + tickets + "...张票");
								tickets--;
							}
						}
					}
				}
				
			产生的问题？
				1.出现了相同的票数
				2.出现了负数票
		
			什么情况下会产生线程安全问题？
				1.多线程的程序中
				2.要有共享资源
				3.操作共享资源的代码至少2条以上
			
			如何解决多线程产生安全问题？
				使用同步机制来解决
				
				方式一：同步代码块
					格式：
						synchronized(锁对象) {
						
						}
						
					注意：锁对象可以是任意对象，但是保证多个线程共用同一把锁对象
				
				方式二：同步方法
					格式：
						修饰符 synchronized 返回值类型 方法名字(形参) {
							
						}
						
					注意：同步方法的锁对象是this
				
				方式三：静态同步方法
					格式：
						修饰符 static synchronized 返回值类型 方法名字(形参) {
							
						}
						
					注意：静态同步方法的锁对象是字节码文件对象
				
				方式四： lock锁
					ReentrantLock lock = new ReentrantLock();
					lock.lock();
					lock.unlock();
		
	等待唤醒机制？
		能够解决生产者和消费者的分析
		
		Object类：
			public final void wait()：在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，
										导致当前线程等待。
										
				wait()和sleep()的区别？
					1.wait()是Object类中的普通的方法。sleep()是Thread类中的静态方法
					2.wait()是等待，不会自己唤醒。sleep()是睡眠，时间到了自动醒来
					3.wait()在等待的时候是会释放锁对象的。sleep()在睡眠的时候是不会释放锁对象的
					
					
			public final void notify()：唤醒在此对象监视器上等待的单个线程
			public final void notifyAll()： 唤醒在此对象监视器上等待的所有线程
		
		例子：
			public class Demo02 {
				public static void main(String[] args) {
					Print p = new Print();
					
					//创建一个线程
					new Thread(new Runnable() {
						@Override
						public void run() {
							while(true) {
								p.print1();
							}
						}
					}).start();
					
					//创建一个线程
					new Thread(new Runnable() {
						@Override
						public void run() {
							while(true) {
								p.print2();
							}
						}
					}).start();
				}
			}

			class Print {
				private Object obj = new Object();
				private boolean flag = false;
				
				public void print1() {
					synchronized(obj) {
						if(!flag) {
							try {
								obj.wait();
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						}
						
						System.out.print("人");
						System.out.print("生");
						System.out.print("若");
						System.out.print("只");
						System.out.print("如");
						System.out.print("初");
						System.out.println("见");
						
						flag = false;
						obj.notify();
					}
				}
				
				public void print2() {
					synchronized(obj) {
						if(flag) {
							try {
								obj.wait();
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						}
						
						System.out.print("何");
						System.out.print("事");
						System.out.print("秋");
						System.out.print("风");
						System.out.print("悲");
						System.out.print("画");
						System.out.println("扇");
						
						flag = true;
						obj.notify();
					}
				}
			}
		
	死锁？
		哲学家的故事
		
		String s1 = "左筷子";
		String s2 = "右筷子";
		
		new Thread("哲学家A") {
			public void run() {
				while(true) {
					synchronized(s1) {
						System.out.println(getName() + "拿到了" + s1 + ",等待" + s2);
						synchronized(s2) {
							System.out.println(getName() + "拿到了" + s2 + ",开吃");
						}
					}
				}
			}
		}.start();
		
		new Thread("哲学家B") {
			public void run() {
				while(true) {
					synchronized(s2) {
						System.out.println(getName() + "拿到了" + s2 + ",等待" + s1);
						synchronized(s1) {
							System.out.println(getName() + "拿到了" + s1 + ",开吃");
						}
					}
				}
			}
		}.start();
		
	Java中的线程安全的类有哪些？
		1.ArrayList和Vector
			ArrayList是线程不安全的，效率高
			Vector是线程安全的，效率低
			
		2.StringBuffer和StringBuilder
			StringBuilder是线程不安全的，效率高
			StringBuffer是线程安全的，效率低
			
		3.HashMap和Hashtable
			HashMap是线程不安全的，效率高
			Hashtable是线程安全的，效率低
			
2.单例设计模式
	使用单例设计模式可以实现一个类有且只能有一个对象
	
	单例设计模式实现方式？
		饿汉式(立即加载)：
			方式一：
				class Singleton {
					private static final Singleton singleton = new Singleton();
					
					private Singleton() {}
					
					public static Singleton getInstance() {
						return singleton;
					}
				}
			
				优点：线程安全
				缺点：因为是静态成员变量，所以会很早的进内存，占用内存空间
		
		懒汉式(延迟加载)：
			方式一： 
				class Singleton {
					private static Singleton singleton;
					
					private Singleton() {}
					
					public static Singleton getInstance() {
						if(singleton == null) {
							singleton = new Singleton();
						}
						
						return singleton;
					}
				}
				
				优点：没有过早的进内存，节省内存空间
				缺点：线程不安全，会创建多个对象
			
			方式二： 
				class Singleton {
					private static Singleton singleton;
					
					private Singleton() {}
					
					public static synchronized Singleton getInstance() {
						if(singleton == null) {
							singleton = new Singleton();
						}
						
						return singleton;
					}
				}
				
				优点：线程安全
				缺点：效率低
			
			方式三：
				class Singleton {
					private static Singleton singleton;
					
					private Singleton() {}
					
					public static Singleton getInstance() {
						if(singleton == null) {
							synchronized(Singleton.class) {
								if(singleton == null) {
									singleton = new Singleton();
								}
							}
						}
						
						return singleton;
					}
				}
				
				优点：不占内存，线程安全，效率高
		
3.枚举
	什么是枚举？
		枚举就是特殊的单例，单例是指对象有且只有一个，而枚举是指对象有且可以多个，但是得有而且还能创建太多，
		一般都是规定好的数量
		
	自定义枚举类？
		格式一：
			class Week {
				public static final Week MON = new Week();
				public static final Week TUE = new Week();
				public static final Week WED = new Week();
				
				private Week() {}
			}
		
		格式二：
			class Week {
				private String name;
				
				public static final Week MON = new Week("星期一");
				public static final Week TUE = new Week("星期二");
				public static final Week WED = new Week("星期三");
				
				private Week(String name) {
					this.name = name;
				}
				
				public String getName() {
					return name;
				}
			}
			
		格式三：
			abstract class Week {
				private String name;
				
				public static final Week MON = new Week("星期一") {
					public void show() {
						System.out.println("星期一");
					}
				};
				public static final Week TUE = new Week("星期二") {
					public void show() {
						System.out.println("星期二");
					}
				};
				public static final Week WED = new Week("星期三") {
					public void show() {
						System.out.println("星期三");
					}
				};
				
				private Week(String name) {
					this.name = name;
				}
				
				public String getName() {
					return name;
				}
				
				public abstract void show();
			}
	
	真正的枚举？
		格式一：
			enum Week {
				MON, TUE, WED;
			}
		
		格式二：
			enum Week {
				MON("星期一"), TUE("星期二"), WED("星期三");
				
				private String name;
				
				private Week(String name) {
					this.name = name;
				}
				
				public String getName() {
					return name;
				}
			}
		
		格式三：
			enum Week {
				MON("星期一") {
					public void show() {
						System.out.println("星期一");
					}
				}, TUE("星期二") {
					public void show() {
						System.out.println("星期二");
					}
				}, WED("星期三") {
					public void show() {
						System.out.println("星期三");
					}
				};
				
				private String name;
				
				private Week(String name) {
					this.name = name;
				}
				
				public String getName() {
					return name;
				}
				
				public abstract void show();
			}
	
	枚举的注意事项？
		1.定义枚举要使用关键字enum
		2.枚举的本质就是个默认继承了Enum类的类
			final class com.enum1.Week extends java.lang.Enum<com.enum1.Week> {
			  public static final com.enum1.Week MON;
			  public static final com.enum1.Week TUE;
			  public static final com.enum1.Week WED;
			  static {};
			  public static com.enum1.Week[] values();
			  public static com.enum1.Week valueOf(java.lang.String);
			}
		3.枚举类默认带一个私有的空参构造方法
		4.枚举项必须放在第一行（即名字放在第一排）
		5.枚举项与枚举项之间要用逗号隔开，最后一个枚举项后面要加分号，如果枚举项后面没有任何内容的话分号
		  可以省略不写
		6.枚举可以放在switch语句的表达式中
			public class Demo03 {
				public static void main(String[] args) {
					Week mon = Week.WED;
					
					switch(mon) {
						case MON:
							System.out.println("星期一");
							break;
						case TUE:
							System.out.println("星期二");
							break;
						case WED:
							System.out.println("星期三");
							break;
					}
				}
			}
		7.枚举中可以定义抽象方法，一旦定义抽象方法，枚举项必须实现
	
	枚举类的相关方法？
		public final int compareTo(E o)
		public final String name()
		public final int ordinal()
		public static <T extends Enum<T>> T valueOf(Class<T> enumType,String name)
		values();
		valueOf();

4.类加载器
	什么是类加载器？
		专门加载.class文件的东西就称为类加载器
		
	类加载器的作用？
		负责将本地磁盘的.class字节码文件加载进内存，形成.class字节码文件对象
		
	类加载器的分类？
		引导类加载器：加载jdk中的jre中lib中的rt.jar中的资源文件
		扩展类加载器：加载jdk中的jre中lib中的ext中资源文件
		系统类加载器：加载classpath路径下的资源文件
			classpath路径：是指.class文件存放的文件夹，默认在bin中
	
	
	1.类加载器
	什么是类加载器？
		专门加载.class文件的东西就称为类加载器
		
	类加载器的作用？
		负责将本地磁盘的.class字节码文件加载进内存，形成.class字节码文件对象
		
	类加载器的分类？
		引导类加载器：加载jdk中的jre中lib中的rt.jar中的资源文件
		扩展类加载器(ExtClassLoader)：加载jdk中的jre中lib中的ext中资源文件
		系统类加载器(AppClassLoader)：加载classpath路径下的资源文件
			classpath路径：是指.class文件存放的文件夹，默认在bin中
			
	类加载器的分层关系？
		最上层：引用类加载器
		中间层：扩展类加载器
		最下层：系统类加载器
	
	类加载器的加载顺序？
		委托机制
		
		首先任何类的字节码文件开始都是由系统类加载器来加载，但是由于委托机制，所以系统类加载器会委托给上一层
		类加载器来加载，即扩展类加载器来加载，由于委托机制，扩展类加载器会委托给上一层类加载器来加载，即引导
		类加载器来加载，引导类加载器没有上一层，就在自己的片区去加载，如果找到就正常加载，如果没有找到，就让
		下一层继续加载，如果扩展类加载器再自己的片区找到了，就正常加载，如果没找到，就让下一层继续加载，就是
		最后会让系统类加载器来加载，如果找到了就正常加载，如果没有找到则会报异常。
		
		举例：
			class Demo {
				public static void main(String[] args) {
					Person p = new Person();
					
					String s = new String();
				}
			}
			
			String.class是由引导类加载器来加载
			Person.class是由系统类加载器来加载
			
		引导类加载器，扩展类加载器和系统类加载器，它们负责加载其他的资源文件，谁来加载它们呢？
			扩展类加载器和系统类加载器都是由引导类加载器来加载的
			引导类加载器是JVM的一部分，它不是类，是由C语言编写的
			
	类加载器的相关方法？
		1.如何获取类加载器对象
			a.获取类的字节码文件对象
				Class clazz = Person.class;
			
			b.通过类的字节码文件对象获取类加载器对象
				ClassLoader classLoader = clazz.getClassLoader();
		
		2.类加载器中的方法
			public final ClassLoader getParent()：返回委托的父类加载器
			public InputStream getResourceAsStream(String name)：返回读取指定资源(classpath路径下的)的输入流
			public URL getResource(String name)：查找具有给定名称的资源
			
			URL类：
				public String getPath()
				
2.五子棋
	单机版：
		画棋盘
		落子
		判断胜负
		再来一局
		悔棋
		保存棋谱
		打谱
		退出
		
	网络版：
		界面布局
		落子
		判断胜负(自己做)
		再来一局(自己做)
		悔棋(自己做)
		退出(自己做)
		
				
			
			
			
			
			
			1.数据库
	我们为什么要学习数据库？
		登录，注册小例子：存储数据和获取数据
		
		容器(集合，数组)？
			不能实现数据的永久性存储
			
		IO流？
			可以实现永久性的存储，但是操作数据的时候效率很低，很麻烦
			
		数据库？
			爽歪歪
			
	什么是数据库？
		可以存储数据库的仓库
		
		数据库就是一个软件，叫做数据库管理系统
		
	数据库的分类？
		关系型数据库：
			*MySql：oracle公司
			Oracle：oracle公司，甲骨文
			DB2：IBM公司
			SQL Server：微软公司
		
		非关系型数据库：
			*Redis
			MongoDB
			HBase
			Neo4J
			
	数据库的服务器开启和关闭？
		打开服务窗口？
			1.在搜索里输入服务，打开即可
			2.在运行窗口中输入services.msc
	
		mysql服务的开启？
			1.找到服务窗口中的mysql，手动开启即可
			2.net start mysql
			
		mysql服务的关闭？
			1.找到服务窗口中的mysql，手动关闭即可
			2.net stop mysql
	
	mysql数据库的登录和退出？	
		登录：mysql -uroot -p密码
		
		退出：exit
		
	三个概念？
		数据库(数据库管理系统)：软件
		数据库（database）：文件夹，里面存储的就是表
		表（table）：文件，数据就是存储在表中
		
2.SQL
	什么是SQL？
		结构化查询语言（Structured Query Language）
	
		sql的工业化标准：使用sql工业化标准做出来的sql语句，是可以操作任何数据库的，通用的
		方言：不同的数据库厂商自己研发出来的sql语句，这种sql语句只能操作自己公司的数据库，不是通用的
		
			普通话和方言
			
	SQL的分类？
		DDL(data definition language)：数据库定义语言
			使用这一类的sql语句可以操作数据库管理系统中数据库和表的结构的
		
		*DML(Data Manipulation Language)：数据库操作语言
			使用这一类的sql语句可以操作数据库中的表中的数据的增删改
		
		*DQL(data query language)：数据库查询语言
			使用这一类的sql语句可以操作数据库中的表中的数据的查询
		
		DCL(Data Control Language)：数据库控制语言
			使用这一类的sql语句可以操作用户的等级，权限，用户名密码等功能
			
	DDL(数据库定义语言)？
		操作数据库和表的结构
		
		操作数据库结构？
			1.查看有哪些数据库？
				show databases;
				
			2.创建一个新的数据库？
				create database 数据库名字;
				create database db3;
				
			3.删除一个数据库？
				drop database 数据库名字;
				drop database db3;
				
			4.查看数据库的创建细节(用的什么sql创建的数据库)？
				show create database 数据库名字;
				show create database db3;
				
			5.指定使用具体的哪一个数据库？
				use 数据库名字;
				use db3;
		set names gbk;在dos窗口可以看中文
				
		操作表结构？
			1.查看数据库中有哪些表？
				show tables;
				
			2.创建一张新的表？ 
				create table 表名 (
					字段名 数据类型,
					字段名 数据类型,
					字段名 数据类型
				);
				
				create table person (
					name varchar(20),
					age int
				);
				
				常见的数据类型？
					int
					decimal(5,2)  小数前面的是一共这么多位数，后面的是小数保留位数
					date：精确到年月日
					datetime：精确到年月日时分秒
					timestamp：精确到年月日时分秒
					varchar(20)
				
			3.删除表？
				drop table 表名;
				drop table person;
				
			4.查看表的创建细节(查看用的是什么sql语句创建的表)？
				show create table 表名;
				show create table person;
				
			5.查看表结构？
				desc 表名;
				desc person;
				
			6.添加一个新的字段？
				alter table 表名 add 字段名 数据类型;
				alter table person add gender varchar(20);
				
			7.修改字段的数据类型？
				alter table 表名 modify 字段名 数据类型;
				alter table person modify gender int;
				
			8.修改字段的名字？
				alter table 表名 change 旧的字段名 新的字段名 数据类型;
				alter table person change gender sex varchar(20);
				
			9.删除字段？
				alter table 表名  drop 字段名;
				alter table person drop sex;
				
			10.修改表名？
				alter table 旧表名 rename 新表名;
				alter table person rename user;
				
				rename table 旧表名 to 新表名;
				rename table user to person;
	
	DML(数据库操作语言)？ 
		操作数据库的表中的数据的增加，修改和删除
		
		增加操作？
			1.添加一条记录
				insert into 表名 (字段名,字段名,...) values (数据, 数据, ...);
				insert into person (name, age) values ('tom', 18);
				insert into person (name) values ('jerry');
				
				insert into 表名 values (数据, 数据, ...);
				insert into person values ('rose', 18);
			
			2.添加多条记录
				insert into 表名 (字段名,字段名,...) values (数据,数据,...),(数据,数据,...),...;
				insert into person (name, age) values ('jack',20),('tony',23),('mary', 30);
				
				insert into 表名 values (数据,数据,...),(数据,数据,...),...
				insert into person values ('lucy', 20), ('jane', 20);
		
		修改操作？
			1.修改所有记录的一个字段的数据？
				update 表名 set 字段名 = 数据;
				update person set age = 18;
				
			2.修改所有记录的多个字段的数据？
				update 表名 set 字段名 = 数据, 字段名 = 数据,....;
				update person set name = 'tom', age = 19;
				
			3.修改某条记录的某个字段的数据？
				update 表名 set 字段名 = 数据 where 字段名 = 数据;
				update person set age = 20 where name = 'jerry';
		
		删除操作？
			1.删除表中所有的记录？
				a.delete from 表名;
					delete from person;
				b.truncate 表名;
					truncate person;
					
					属于DDL的sql语句
					
				a和b的区别？
					a是逐行扫描逐行删除
					b是将整张表删除再重新建一张表
					
			2.删除表中某条记录？
				delete from 表名 where 字段名 = 数据;
				delete from person where age = 19;
				delete from person where name = 'tom';
		
	DQL(数据库查询语言)？
		操作数据库的表中的数据的查询
		
		搭建环境：
			create database db3;
			
			use db3;
			
			create table user (
				id int,
				name varchar(20),
				age int,
				gender varchar(20)
			);
			
			insert into user values(1, 'tom', 18, '男');
			insert into user values(2, 'jerry', 19, '男');
			insert into user values(3, 'rose', 17, '女');
			insert into user values(4, 'jack', 23, '男');
			insert into user values(5, 'tony', 24, '男');
			insert into user values(6, 'mary', 32, '女');
			insert into user values(7, 'lucy', 25, '女');
			
		1.单表查询
			a.简单查询
				需求：查询user表中所有的记录信息？
					select * from user;
					select id, name, age, gender from user;
					select name, age from user;
			
			b.条件查询
				注意：sql语句代表条件关键字是where
			
				1.简单的条件查询
					=
					>
					<
					>=
					>=
					!=,<>
					between...and...
					in(...)
					and,&&
					or,||
					is null
					is not null
					distinct 分段，比如年龄段可以达到去重的效果
					as	别名
					like	模糊查询
					
					需求：查询user表中id值为1的记录信息？
						select * from user where id = 1;
						
					需求：查询user表中name为jerry的记录信息？
						select * from user where name = 'jerry';
						
					需求：查询user表中年龄大于20岁的记录信息？
						select * from user where age > 20;
						
					需求：查询user表中年龄小于20岁的记录信息？
						select * from user where age < 20;
						
					需求：查询user表中年龄大于并且等于18岁的记录信息？
						select * from user where age >= 18;
						
					需求：查询user表中年龄小于等于18岁的记录信息？
						select * from user where age <= 18;
				
				
				2.复杂的条件查询
			
		2.多表查询
		
	1.DQL(数据库查询语言)？
	操作数据库的表中的数据的查询

	搭建环境：
		create database db3;
		
		use db3;
		
		create table user (
			id int,
			name varchar(20),
			age int,
			gender varchar(20)
		);
		
		insert into user values(1, 'tom', 18, '男');
		insert into user values(2, 'jerry', 19, '男');
		insert into user values(3, 'rose', 17, '女');
		insert into user values(4, 'jack', 23, '男');
		insert into user values(5, 'tony', 24, '男');
		insert into user values(6, 'mary', 32, '女');
		insert into user values(7, 'lucy', 25, '女');
		
	1.单表查询
		a.简单查询
			需求：查询user表中所有的记录信息？
				select * from user;
				select id, name, age, gender from user;
				select name, age from user;
		
		b.条件查询
			注意：sql语句代表条件关键字是where
		
			1.简单的条件查询
				=
				>
				<
				>=
				>=
				!=,<>
				between...and...
				in(...)
				and,&&
				or,||
				is null
				is not null
				distinct
				like
				as
				
				需求：查询user表中id值为1的记录信息？
					select * from user where id = 1;
					
				需求：查询user表中name为jerry的记录信息？
					select * from user where name = 'jerry';
					
				需求：查询user表中年龄大于20岁的记录信息？
					select * from user where age > 20;
					
				需求：查询user表中年龄小于20岁的记录信息？
					select * from user where age < 20;
					
				需求：查询user表中年龄大于并且等于18岁的记录信息？
					select * from user where age >= 18;
					
				需求：查询user表中年龄小于等于18岁的记录信息？
					select * from user where age <= 18;
					
				需求：查询user表中年龄不等于18岁的记录信息？
					select * from user where age != 18;
					select * from user where age <> 18;
					
				需求：查询user表中年龄在20岁到25岁之间的记录信息？
					select * from user where age between 20 and 25;
					select * from user where age >= 20 and age <= 25;
					
				需求：查询user表中年龄为18,23,25的记录信息？
					select * from user where age in (18, 23, 25);
					select * from user where age = 18 or age = 23 or age = 25;
					
				需求：查询user表中姓名为tom,rose,lucy的记录信息？
					select * from user where name in('tom', 'rose', 'lucy');
					
				需求：查询user表中姓名为tom,年龄为19岁的记录信息？
					select * from user where name = 'tom' and age = 19;
					select * from user where name = 'tom' && age = 19;
					
				需求：查询user表中姓名为tom或者年龄为19岁的记录信息？
					select * from user where name = 'tom' or age = 19;
					select * from user where name = 'tom' || age = 19;
					
				需求：查询user表中年龄为null的记录信息？
					select * from user where age is null;
					
				需求：查询user表中年龄不为null记录信息？
					select * from user where age is not null;
					
				需求：查询user表中有哪些年龄段？
					select distinct age from user;
					
				需求：查询user表中name为3个字，并且第二个字带'三'的记录信息？
					select * from user where name like '_三_';
					
					注意：
						_：代表任意一个字符
						
				需求：查询user表中name中带'三'的记录信息？
					select * from user where name like '%三%';
					
					注意：
						%：代表任意0或者多个字符
						
				需求：查询user表中name中第二个字带'三'记录信息？
					select * from user where name like '_三%';
					
				需求：查询user表中name中姓'三'的记录信息？
					select * from user where name like '三%';
					
				需求：查询表中所有的记录信息？(别名版)
					select * from user;
					
					select id, name, age, gender from user;
					
					select id as 编号, name as 姓名, age as 年龄, gender as 性别 from user;
					
					select id 编号, name 姓名, age 年龄, gender 性别 from user;
					
					select * from user as u;
					
					select u.id, u.name, u.age, u.gender from user u;
			
			2.复杂的条件查询
				1.聚合函数查询
					count()：统计
					sum()：求和
					max()：求最大值
					min()：求最小值
					avg()：求平均值
					
					需求：查询user表有多少条记录？
						select count(*) from user;
						
					需求：查询user表中所有人的年龄和？
						select sum(age) from user;
						
					需求：查询user表中最大年龄？
						select max(age) from user;
						
					需求：查询user表中最小年龄？
						select min(age) from user;
						
					需求：查询user表中年龄的平均值？
						select avg(age) from user;
						select truncate(avg(age), 2) from user;
						select sum(age) / count(*) from user;
					
				2.排序查询
					order by 字段 asc/desc
				
					需求：根据年龄进行排序(小到大)？
						select * from user order by age asc;
						
						select * from user order by age;
						
					需求：根据年龄惊醒排序(大到小)？
						select * from user order by age desc;
						
					需求：对年龄为18,23,25的记录降序排列？
						select * from user where age in (18, 23, 25) order by age desc;
						
					需求：根据姓名进行字典顺序排序？
						select * from user order by name asc;
						
					需求：根据年龄进行降序排序，如果年龄相同再根据姓名字典顺序排序？
						select * from user order by age desc, name asc;
				
				3.分组查询
					group by 分组的字段
					
					需求：根据性别进行分组？
						select gender from user group by gender;
						
					需求：根据年龄段进行分组？
						select * from user group by age;
						
					需求：根据性别进行分组，得到每组的人数？
						select gender, count(*) from user group by gender;
						
					需求：根据年龄进行分组，得到每组的人数？
						select age, count(*) from user group by age;
						
					需求：根据性别进行分组，得到每组的人数，要求每组的每个人的年龄必须大于20岁？
						select gender, count(*) from user where age > 20 group by gender;
						
					需求：根据年龄进行分组，得到每组的人数，要求每组人数必须大于1？
						select age, count(*) from user group by age having count(*) > 1;
						
						having和where区别？
							1.where写在group by前面，having写在group by后面
							2.where是在分组之前条件判断，having是在分组之后再进行条件判断
							3.where后面不能写聚合函数，having后面可以写聚合函数
				
				4.分页查询
					limit 起始个数, 每页显示的条数
					
					需求：查询第一页的记录信息？
						select * from user limit 0, 5;
						
					需求：查询第二页的记录信息？
						select * from user limit 5, 5;
						
					需求：查询第三页的记录信息？
						select * from user limit 10, 5;
						
					需求：查询第N页的记录信息？
						select * from user limit (n-1) * 每页显示的条数, 每页显示的条数;
			    
2.约束
	1.非空约束
		not null：不为空
		
		创建表的时候添加非空约束？
			create table user (
				name varchar(20) not null,
				age int
			);
			
		删除非空约束？
			alter table user modify name varchar(20);
			
		创建表之后再添加非空约束？
			alter table user modify name varchar(20) not null;
	
	2.唯一约束
		unique：数据唯一
		
		创建表的时候添加唯一约束？
			create table user (
				name varchar(20) unique,
				age int
			);
			
		删除唯一约束？
			alter table user drop index name;
			
		创建表之后再添加唯一约束？
			alter table user modify name varchar(20) unique;
	
	3.主键约束
		primary key：非空且唯一
		
		创建表的时候添加主键约束？
			create table user (
				id int primary key,
				name varchar(20)
			);
		
		删除主键约束？
			alter table user drop primary key;
			
		创建表之后再添加主键约束？
			alter table user modify id int primary key;
	
	4.自动增长
		auto_increment：自动增长
		
		创建表的时候添加自动增长？
			create table user (
				id int primary key auto_increment,
				name varchar(20)
			);
			
		删除自动增长？
			alter table user modify id int;
			
		创建表之后再添加自动增长？
			alter table user modify id int auto_increment;
	
	5.外键约束
		foreign key：让两张表之间产生了关系，而且限制多的一方的字段不能随意填写
		格式：constraint 外键名字 foreign key (本字段名) references 表名(字段名);
		
		创建表的时候的添加外键约束？
			用户表：
				create table user (
					id int primary key auto_increment,
					name varchar(20)
				);
				
			电脑表：
				create table computer (
					id int primary key auto_increment,
					name varchar(20),
					uid int,
					constraint c_u_key foreign key (uid) references user(id)
				);
				
		删除外键约束？
			alter table computer drop foreign key c_u_key;
			
		创建表之后再添加外键约束？
			alter table computer add constraint c_u_key foreign key (uid) references user(id);
		
3.表与表之间的关系
	1.一对一
		举例子：
			公民表和身份证表的关系
			
			建表原则：将两张表合并成一张表
			
	
	*2.一对多(多对一)
		举例子：
			用户表和电脑表的关系
				
			一个用户可以有多台电脑
			一台电脑是能属于一个用户
	
	*3.多对多
			
				1.表与表之间的关系
	1.一对一
		举例子：
			公民表和身份证表的关系
			
			建表原则：将两张表合并成一张表
			
	
	*2.一对多(多对一)
		举例子：
			用户表和电脑表的关系
				
			一个用户可以有多台电脑
			一台电脑是能属于一个用户
			
			建表原则：在多的一方添加一个字段，外键关联到一的一方的主键id
	
	*3.多对多
		举例子：
			学生表和老师表的关系
			
			一个学生可以被多个老师教
			一个老师会教多个学生
			
			建表原则：额外新创建一张新的第三方表，设置联合主键，两个字段分别外键关联另外两张表的主键
			
	练习题？
		已知有三张表，用户表，分类表和商品表，分析它们的关系合理的创建表？
			
			用户表
			分类表
			商品表
			
			用户表和商品表有关系吗？
				一个用户可以买多个商品
				一个商品可以被多个用户买
				多对多关系
				
			用户表和分类表有关系吗？
				没有关系
				
			分类表和商品表有关系吗？
				一个商品属于一个分类
				一个分类有多个商品
				一对多关系
				
			用户表？
				create table user (
					id int primary key auto_increment,
					name varchar(20)
				);
			
			分类表？
				create table category (
					id int primary key auto_increment,
					name varchar(20)
				);
			
			商品表？
				create table goods (
					id int primary key auto_increment,
					name varchar(20),
					cid int,
					foreign key (cid) references category(id)
				);
				
			第三方表？
				create table u_g (
					uid int,
					gid int,
					primary key(uid, gid),//设置联合主键
					foreign key (uid) references user(id),
					foreign key (gid) references goods(id)
				);
	
2.多表查询
	多张表一起查询
	
	环境搭建：
		drop database db3;
		create database db3;
		use db3;
		
		create table a (
			id int,
			name varchar(20)
		);
		
		insert into a values(1,'tom');
		insert into a values(2,'jerry');
		insert into a values(3,'rose');
		
		create table b (
			id int,
			name varchar(20)
		);
		
		insert into b values(1,'张三');
		insert into b values(2,'李四');
		insert into b values(4,'王五');
	
	1.笛卡尔积查询
		select * from a, b;
		
		注意：笛卡尔积查询没有任何用处，但是呢是一切多表查询的基础
		
	2.内连接查询
		1.隐式内连接查询
			需求：查询a表中id值等于b表中id值的所有记录信息？
				select * from a, b where a.id = b.id;
		
		2.显示内连接查询
			需求：查询a表中id值等于b表中id值的所有记录信息？
				select * from a inner join b on a.id = b.id;
	
	3.外连接查询
		1.左外连接查询
			需求：查询a表中id值等于b表中id值的所有记录信息(a表中的所有记录都要查询出来)？
				select * from a left join b on a.id = b.id;
				
			需求：查询a表中id值等于b表中id值的所有记录信息(b表中的所有记录都要查询出来)？
				select * from b left join a on a.id = b.id;
		
		2.右外连接查询
			需求：查询a表中id值等于b表中id值的所有记录信息(a表中的所有记录都要查询出来)？
				select * from b right join a on a.id = b.id;
				
			需求：查询a表中id值等于b表中id值的所有记录信息(b表中的所有记录都要查询出来)？
				select * from a right join b on a.id = b.id;
		
	4.子查询
		嵌套查询，sql语句里面套个sql语句
	
		1.内部查询语句查询出来的是一个数据
			需求：查询a表中id值等于b表中姓名为李四的id值的记录信息？
			
			需求：查询a表中id值等于XXX的记录信息？
				select * from a where id = XXX
			
			需求：查询b表中姓名为李四的id值？
				select id from b where name = '李四';
				
			需求：查询a表中id值等于b表中姓名为李四的id值的记录信息？
				select * from a where id = (select id from b where name = '李四');
		
		2.内部查询语句查询出来的是多个数据
			需求：查询a表中id值等于b表中姓名为李四，王五的id值的记录信息？
				select * from a where id in (select id from b where name = '李四' or name = '王五');
		
		3.内部查询语句查询出来的是一张表
			需求：查询a表中的所有记录信息(id值降序排列)？
				select * from a order by id desc;
				
				select * from (select * from a order by id desc) newA;
			
			子查询可以对表进行重构
		
3.事务
	什么是事务？
		一般是指要做的或所做的事情
		
		要做的事情
		
		事情有大事情，也有小事情
		
		什么是大事情，什么是小事情？
			需求：向表中添加一条记录
				一条sql语句完成这个需求
			
			需求：删除表中的一条记录
				一条sql语句完成这个需求
			
			需求：修改表中的一条记录
				一条sql语句完成这个需求
			
			需求：查询表中的一条记录
				一条sql语句完成这个需求
				
			小事情是指一条sql语句就可以完成的需求
			
			需求：转账操作
				两条sql语句完成这个需求
				
			大事情是指两条或者两条以上才可以完成的需求
		
	对事务的处理？
		方式一：
			start transaction; 开启事务
			commit; 提交事务
			rollback; 回滚事务
			
			常见组合：
				1.
					start transaction;
					commit;
				2.
					start transaction;
					rollback;
		
		方式二：
			将自动提交改为手动提交
			
			查看事务的提交方式：select @@autocommit;
				1：自动提交
				0：手动提交
				
			修改事务的提交方式：set @@autocommit = 0;
			
	事务的四大特性？
		原子性：原子化学反应中最小的单位，是指一个事务是不可以再被拆开的
		持久性：是指通过事务处理之后的数据，也是永久存储的
		一致性：在事务处理之前和事务处理之后的结果都是一致的
		隔离性：事务与事务之间是互相不干涉的，互相不影响
			注意：但是如果出现事务与事务之间操作的表是同一张表的时候，就会打破隔离性
			
			如果打破了隔离性，会引发什么问题？
				脏读：事务A 读到了 事务B 未提交的数据
				不可重复读：事务A 读到了 事务B 已经提交的修改的数据
				虚读(幻读)：事务A 读到了 事务B 已经提交的添加的数据
				
			怎么解决？
				设置隔离级别
				read uncommitted：如果设置了这个隔离级别，上面的三个问题都解决不了
				read committed：如果设置了这个隔离级别，能解决脏读，但是其他两个问题解决不了
				repeatable read：如果设了这个隔离级别，能解决脏读和不可重复读，但是解决不了虚读
				serializable：如果设置了这个隔离级别，什么问题都能解决，但是效率特别低，不推荐
				
				mysql默认隔离级别：repeatable read
				oracle默认隔离级别：read committed
				
				查看当前的隔离级别？
					select @@tx_isolation;
					
				修改当前的隔离级别？
					set global transaction isolation level 隔离级别;
					
4.JDBC
	什么是JDBC？
		Java数据库连接 Java DataBase Connectivity
		
		JavaEE技术之一
	
	JDBC有什么用？
		实现使用Java语言操作数据库
		
	JDBC的本质？
		JDBC是SUN公司提供的一套规范，接口，为了统一标准
		
	JDBC入门小案例？
		实现步骤：
			0.导jar包
			
			//1.注册驱动
			Class.forName("com.mysql.jdbc.Driver");
			
			//2.获取数据连接对象
			Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "123");
			
			//3.获取执行sql语句对象
			Statement stat = conn.createStatement();
			
			//4.执行sql语句
			int i = stat.executeUpdate("insert into user values('tom', 18)");
			
			//5.获取结果
			System.out.println(i);
			
			//6.释放资源
			stat.close();
			conn.close();
			
		步骤详解：
			0.导jar包
				因为想要使用jdbc操作数据库，需要具体的实现类和里面的方法，这些都在jar包中，我们需要额外导入
				
			1.注册驱动
				Class.forName("com.mysql.jdbc.Driver");//将com.mysql.jdbc.Driver的字节码文件从本地磁盘加载进
													   //内存中
				
				注册驱动是为了告诉我们使用哪个数据库，已经对一些重要的数据进行初始化工作
				
				注册驱动的原始代码：DriverManager.registerDriver(new Driver());
				为什么不写原始代码呢？
					1.会造成二次注册，没有必要
					2.耦合性大一些，大依赖于jar包的存在
	
			2.获取数据连接对象
				Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "123");
	
				第一个参数：协议 + IP + 端口 + 数据库名
				第二个参数：数据库的用户名
				第三个参数：数据库的密码
				
				public static Connection getConnection(String url,String user,String password)
				public static Connection getConnection(String url,Properties info)
				public static Connection getConnection(String url)

				注意：如果使用的IP是localhost，端口是默认的3306的话，我们写的时候可以这么写：
					Connection conn = DriverManager.getConnection("jdbc:mysql///db3", "root", "123");
			
			3.获取执行sql语句对象	
				Statement stat = conn.createStatement();
				
				注意：以后不怎么写
				
			4.执行sql语句
				增删改查
				
				*int executeUpdate(String sql)：对数据进行增删改操作的，返回实际影响的行数
				*ResultSet executeQuery(String sql)：对数据进行查询操作的，返回是结果集对象
				boolean execute(String sql)：对数据进行增删改查操作的

				
				
				
				
			
	
		
		
		
		
		1.JDBC
	什么是JDBC？
		Java数据库连接 Java DataBase Connectivity
		
		JavaEE技术之一
	
	JDBC有什么用？
		实现使用Java语言操作数据库
		
	JDBC的本质？
		JDBC是SUN公司提供的一套规范，接口，为了统一标准
		
	JDBC入门小案例？
		实现步骤：
			0.导jar包
			
			//1.注册驱动
			Class.forName("com.mysql.jdbc.Driver");
			
			//2.获取数据连接对象
			Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "123");
			
			//3.获取执行sql语句对象
			Statement stat = conn.createStatement();
			
			//4.执行sql语句
			int i = stat.executeUpdate("insert into user values('tom', 18)");
			
			//5.获取结果
			System.out.println(i);
			
			//6.释放资源
			stat.close();
			conn.close();
			
		步骤详解：
			0.导jar包
				因为想要使用jdbc操作数据库，需要具体的实现类和里面的方法，这些都在jar包中，我们需要额外导入
				
			1.注册驱动
				Class.forName("com.mysql.jdbc.Driver");//将com.mysql.jdbc.Driver的字节码文件从本地磁盘加载进
													   //内存中
				
				注册驱动是为了告诉我们使用哪个数据库，已经对一些重要的数据进行初始化工作
				
				注册驱动的原始代码：DriverManager.registerDriver(new Driver());
				为什么不写原始代码呢？
					1.会造成二次注册，没有必要
					2.耦合性大一些，大依赖于jar包的存在
	
			2.获取数据连接对象
				Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "123");
	
				第一个参数：协议 + IP + 端口 + 数据库名
				第二个参数：数据库的用户名
				第三个参数：数据库的密码
				
				public static Connection getConnection(String url,String user,String password)
				public static Connection getConnection(String url,Properties info)
				public static Connection getConnection(String url)

				注意：如果使用的IP是localhost，端口是默认的3306的话，我们写的时候可以这么写：
					Connection conn = DriverManager.getConnection("jdbc:mysql///db3", "root", "123");
			
			3.获取执行sql语句对象	
				Statement stat = conn.createStatement();
				
				注意：以后不怎么写
				
			4.执行sql语句
				增删改查
				
				*int executeUpdate(String sql)：对数据进行增删改操作的，返回实际影响的行数
				*ResultSet executeQuery(String sql)：对数据进行查询操作的，返回是结果集对象
					ResultSet接口：
						*boolean next()
						Object getObject(int columnIndex)
						Object getObject(String columnLabel)
						int getInt(int columnIndex)
						*int getInt(String columnLabel)
						String getString(int columnIndex)
						*String getString(String columnLabel)
						
				boolean execute(String sql)：对数据进行增删改查操作的
					增删改操作返回false
					查询操作返回true
					
			5.释放资源
				结果集对象
				执行sql语句对象
				数据库连接对象
				
				这三个需要释放资源
			
	练习？
		1.已知有一张表，表中有些数据，将表中数据使用JDBC加载进行内存，存储到对象中，再将对象存储到集合中，
		  遍历集合，打印对象的属性？
		  
		2.已知有一张表，表中有些数据，我们要模拟用户登录功能，我们需要录入用户名和密码，如果表中存在则提示
		  登录成功，否则提示登录失败？
			public class Demo04 {
				public static void main(String[] args) throws Exception {
					//键盘录入
					Scanner sc = new Scanner(System.in);
					
					//接收用户名和密码
					System.out.println("请录入用户名：");
					String username = sc.nextLine();
					System.out.println("请录入密码：");
					String password = sc.nextLine();
					
					//登录
					boolean b = login(username, password);
					if(b) {
						System.out.println("登录成功~");
					} else {
						System.out.println("登录失败~");
					}
				}
				
				public static boolean login(String username, String password) throws Exception {
					//注册驱动
					Class.forName("com.mysql.jdbc.Driver");
					
					//获取数据库连接对象
					Connection conn = DriverManager.getConnection("jdbc:mysql:///db3", "root", "123");
					
					//获取执行sql语句对象
					Statement stat = conn.createStatement();
					
					//执行sql语句
					String sql = "select * from user where username = '" + username + "' and password = '" + password + "'";
					ResultSet rs = stat.executeQuery(sql);
					
					return rs.next();
				}
			}
		  	键盘录入密码时多写一点or “1“=1；就会成功录入。
			注意：上面的代码会引发sql注入问题
			
			怎么解决sql注入问题？
				使用PreparedStatment对象的占位符方式，就可以解决sql注入问题
		  
2.JDBC工具类
	public class JdbcUtils {
		private static String driver;
		private static String url;
		private static String username;
		private static String password;
		
		private JdbcUtils() {}
		
		static {
			try {
				//加载配置文件
				Properties p = new Properties();
				p.load(JdbcUtils.class.getClassLoader().getResourceAsStream("jdbc.properties"));
				
				//初始化
				driver = p.getProperty("driver");
				url = p.getProperty("url");
				username = p.getProperty("username");
				password = p.getProperty("password");
				
				//注册驱动
				Class.forName(driver);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		
		//获取数据库连接对象
		public static Connection getConnection() throws Exception {
			//获取数据库连接对象
			Connection conn = DriverManager.getConnection(url, username, password);
			return conn;
		}
		
		//释放资源
		//查询
		public static void close(Connection conn, PreparedStatement ps, ResultSet rs) {
			if(conn != null) {
				try {
					conn.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			
			if(ps != null) {
				try {
					ps.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			
			if(rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		
		//增删改
		public static void close(Connection conn, PreparedStatement ps) {
			close(conn, ps, null);
		}
	}
		  
3.JDBC对事务的处理
	Connection接口：
		void setAutoCommit(boolean autoCommit)：开启事务
		void commit()：提交事务
		void rollback()：回滚事务

	例子：
		public class Demo07 {
			public static void main(String[] args) throws Exception {
				//获取数据库连接对象
				Connection conn = JdbcUtils.getConnection();
				
				//开启事务
				conn.setAutoCommit(false);
				
				//获取执行sql语句的对象
				PreparedStatement ps = conn.prepareStatement("update user set money = money + ? where name = ?");
				
				//tom的金额减去100
				ps.setInt(1, -100);
				ps.setString(2, "tom");
				ps.executeUpdate();
				
				System.out.println(1/0);
				
				//jerry的金额增加100
				ps.setInt(1, 100);
				ps.setString(2, "jerry");
				ps.executeUpdate();
				
				//提交事务
				conn.commit();
				
				//释放资源
				JdbcUtils.close(conn, ps);
			}
		}
		  
		  
		  
		  
		  
		  
		  
		  1.JavaWeb常识
	a.JavaWeb
		什么是JavaWeb？
			使用Java语言开发基于互联网的项目
			
		软件架构？
			1.C(Client)/S(Server)：客户端/服务器
				一般本地有一个客户端软件，远处有一个服务器
				
				举例子：QQ, 微信, 百度云盘, 迅雷, ... ...
				
				优点：用户体验度好，功能强大
				缺点：占内存，开发，测试，部署，维护等等都非常的麻烦，成本大
			
			*2.B(Browser)/S(Server)：浏览器/服务器
				在本地打开一个浏览器，输入网址，去访问远程的服务器
				
				举例子：淘宝，京东，... ...
				
				优点：开发，测试，部署，维护等等都非常的简单
				缺点：用户体验度相对较差，对硬件要求更高
	
	b.网站和网页
		什么是网站？
			网站是由多个网页组成的一个集合体
			
		什么是网页？
			一个网站有多个页面构成，每一个页面都称为一个网页，一个网页就是一个html文件
			
		常见的浏览器？
			QQ浏览器，IE浏览器，火狐浏览器，谷歌浏览器，360浏览器，苹果浏览器 ... ...
			
		浏览器的内核？
			什么是内核？
				渲染引擎，是浏览器最为重要的核心
				
			内核的作用？
				它能够获取到网页中的内容，进行解析，通过另外一种效果给我们呈现出来
			
			常见的内核？
				不同的浏览器内核是不一样的
				
				trident IE浏览器内核
				gecko   火狐浏览器内核
				webkit  苹果浏览器内核
				blink   谷歌浏览器内核
				
				国内浏览器的内核大部分使用的是webkit和blink内核
	
	c.资源
		什么是资源？
			资源指的就是文件的意思
			
		资源的分类？
			静态资源
			动态资源
			
		什么是静态资源？
			静态资源是指文件中的内容是写死的，今天打开是这个样子，过100年打开还是这个样子，没有任何变化
			
			举例子：
				文本文件，图片，视频，音频
				html，css，js
				
				前端静态资源三兄弟：
					html：是写网页的
					css：美化网页的
					js：让网页动起来的
					
			注意：通过浏览器访问一个静态资源，静态资源会直接响应回浏览器，浏览器的内核也只能解析静态资源，
			将丰富的内容给我们呈现出来。
		
		什么是动态资源？
			动态资源是指文件中的内容是活的，今天打开一个样，明天打开另一个样
			
			举例子：
				jsp，servlet
				
			注意：通过浏览器访问一个动态资源，动态资源是不会直接响应回浏览器的，动态资源先会转换成静态资源，
			然后将静态资源响应回浏览器，浏览器的内核也只能解析静态资源，将丰富的内容给我们呈现出来。
				
2.html
	什么是html？
		超文本标记语言（Hypertext Markup Language）
		
		什么是超文本？
			超文本就是指超级文本，比普通文本功能更加强大的文本
			
			普通文本里面只能有一个内容，可设置字体大小，样式
			超级文本里面可以有文字内容，也可以有图片，视频，音频，动态图片.....
			
			普通人和超人
		
		什么是标记语言？
			文本中的内容都是由标签组成的
			
			标签：<内容>
			
	html的作用？
		用来写网页的
		
	html的入门小案例？
		第一步：
			创建一个HelloWorld.html文件
			
		第二步：
			在文件中写内容：
				<html>
					<head>
						<title>约吗</title>
					</head>
					<body>
						约吗？
					</body>
				</html>
			
		第三步：
			通过浏览器打开该文件即可

	html的基础语法？
		1.html文件的后缀名是以.html或者.htm为结尾的
		
		2.html文件是由标签组成，标签的写法有两种
			写法一：围堵标签
				有头有尾
				
				<html></html>
				<body></body>
			
			写法二：自闭合标签
				<br/>
				<hr/>
				
		3.标签的嵌套
			<html></html>
			<head></head>
			
			错误写法：
				<html><head></html></head>
				
			正确写法：
				<html><head></head></html>
				<html><br/></html>
		
		4.html中的标签是不区分大小写的
			<html></html>
			<HTML></HTML>
			<html></HTML>
			
			以上写法都是正确格式
			
		5.html中的标签中是可以写属性的
			属性格式：属性名=属性值
			位置：标签内部
			注意：属性值要加引号，单双都可以
			
			<font color='red'></font>
			<hr color='red'/>
			
		6.html是一个非常不严谨的标记语言
			我们很难把html给写错了
			
	html常见的标签？
		1.结构体标签
			<!DOCTYPE html>：声明该文件是一个以html5为标签的html文件
		
			html标签：html中的根标签，只能有一个根标签
			
			head标签：头标签，里面可以写一些子标签，一般它里面的内容主要是针对页面的属性进行设置的
			
			meta标签：主要是针对页面的属性的设置
				charset属性：utf-8 告诉浏览器用什么编码来打开此文件
			
			title标签：页面的标题标签
			
			body标签：体标签，里面可以写一些子标签，一般它里面的内容都是用来显示的内容
	
		2.文本标签
			注释标签：<!--内容-->
			
			标题标签：<h数字></h数字>
				注意：数字1-6，越大标题越小，超出范围和没加标题标签一个效果
			
			段落标签：<p></p>

			换行标签：<br/>
			
			水平线标签：<hr/>
				常见的属性：
					color属性：设置水平线的颜色
					size属性：设置水平线的粗细
						数值越大越粗
					width属性：设置水平线的宽度
					align属性：设置水平线居左居右
						left
						right
						center
						
			加粗标签：
				<b></b>
				<strong></strong>
				
			斜体标签：
				<i></i>
				<em></em>
				
			删除线标签：
				<s></s>
				<del></del>
				
			下划线标签：
				<u></u>
				<ins></ins>
				
			字体标签：<font></font>
				常见的属性：
					color属性：设置字体的颜色
					size属性：设置字体大小的
						注意：如果超出范围，字体按照7的大小来设置
					face属性：设置字体的样式
			
				color属性和width属性的设置？
					width属性：
						方式一：写数字，单位是像素(px)
							<hr width="100">
							
						方式二：百分比
							<hr width="30%">
							
					color属性：
						方式一： 
							<font color="blue">滚犊子</font>
							
						方式二： 
							<font color="#93ff7b">滚犊子</font>
							
						方式三：
							<font style="color: rgb(0, 0, 255)">滚犊子</font>
							
		3.图片标签
			<img/>
			
			常见的属性：
				src属性：设置图片的路径
					路径的分类：
						绝对路径：
							以盘符开始的路径
							
						相对路径：
							不以盘符开始的路径
							
							./：相对于当前路径
								注意：./可以省略不写的
							
							../：相对于上一级目录
							
				alt属性：图片说明
				title属性：图片说明
				width属性：设置图片宽度
				height属性：设置图片高度
					注意：针对图片我们不会同时设置高和宽，只会设置一个，另外一个属性会等比例改变
				align属性：设置图片位置
					left
					right
				border属性：设置图片的边框
				
		4.列表标签
			a.有符号有序号
				<ol type="i">
					<li>哈哈</li>
					<li>呵呵</li>
					<li>嘻嘻</li>
					<li>嘿嘿</li>
					<li>嘤嘤</li>
				</ol>
			
			b.有符号无序号
				<ul type="square">
					<li>咨询部</li>
					<li>教研部</li>
					<li>行政部</li>
					<li>财务部</li>
					<li>研发部</li>
				</ul>
			
			c.无符号无序号
				<dl>
					<dt>热门手游</dt>
					<dd>王者荣耀</dd>
					<dd>和平精英</dd>
					<dd>五子棋</dd>
					<dd>原神</dd>
				</dl>
				
		5.特殊符号
			&nbsp; 空格
			&lt; <
			&gt; >
			
		6.块级标签
			<span></span>
			<div></div>
			
			div + css对页面进行布局
			
		7.语义化标签
			<header></header>
			<footer></footer>
						
	1.html
	常用的标签？
		8.超链接标签
			<a></a>
			
			常见的属性：
				href属性：设置点击链接到哪里
					1.外部链接
						<a href="http://www.baidu.com">去百度</a>
						<a href="http://www.woniuxy.com">去蜗牛</a>
					
					2.内部链接
						<a href="./demo02.html">到demo02.html</a>
					
					3.空链接
						<a href="#">点我啊</a>
					
					4.下载链接
						<a href="../img/10.jpg" download>下载大美女</a>
					
					5.锚点链接
						<div id="top"></div>
						<a href="#top">回到顶部</a>
					
					6.图片链接
						<a href="http://www.woniuxy.com"><img src="../img/10.jpg" width="300"/></a>
							
				target属性：
					_self
					_blank
					
		9.表格标签
			表格标签：<table></table>
				常见的属性：
					border属性：边框
					cellspacing：0 设置外边线和内边线的距离
					callpadding：设置内边线和内容之间的距离
					align：设置表格的位置
					bgcolor：设置表格颜色
					width：设置宽
					height：设置高
			
			行标签：<tr></tr>
			列标签：<td></td>
					<th></th>
			表格标题标签：<caption></caption>
			表格语义化标签：
				<thead></thead>
				<tbody></tbody>
				<tfoot></tfoot>
				
			合并单元格：
				合并行：rowspan
				合并列：colspan
			
			嵌套关系：table > tr > td
			
		10.表单标签
			<form><form>
			
			常见的属性：
				action属性：表单提交到的路径
				
				method属性：表单的提交方式
					get：默认值，表单项数据会在地址栏上显示出来
					post：表单项数据不会在地址栏上显示出来
					
					推荐使用post，因为安全
			
			注意：是一个隐藏的看不到的一个表单
			
			作用：用来收集用户输入的各种数据，能够和服务器进行数据的交互(采集数据)
			
			常见的表单项标签：
				input标签：
					<input/>
					
					常见的属性：
						type属性：
							type="text" 普通文本框
							type="password" 密码框
							type="radio" 单选框
							type="date" 时间日期框
							type="checkbox" 复选框
							type="email" 邮箱框，自带校验功能
							type="file" 文件框
							type="color" 颜色框
							type="number" 数字框
							type="hidden" 隐藏框
							type="submit" 按钮，自带提交功能
							type="button" 按钮，最最普通没有任何功能的按钮
							type="reset" 按钮，自带重置功能
							
						checked属性：
							checked="checked"
							注意：该属性只能加在单选框或者多选框的里面
							
						placehoder属性：
							placeholder="请输入用户名"
							
				select标签：
					<select></select>
					<option></option>
					
					常见的属性：
						selected属性：
								selected="selected"
								注意：该属性只能加载下拉框中
					
				textarea标签：
					<textarea></textarea>
					
				label标签：
					for属性：
						<label for="标签的id属性值">用户名</label>
			
				表单项通用属性：
					id属性：代表标签的唯一标识
					
					*name属性：后台需要通过name属性值来获取数据，所以标签必须写
					
					*value属性：后台所获取到的数据，手动输入就不写，不手动输入就需要写
					
			
			
				1.CSS
	什么是CSS?
		层叠样式表（cascading style sheet），也叫做级联样式表
		
		层叠？
			是指多个样式可以施加在一个标签上
		
		样式？
			颜色，大小，边框等等
			
	css的作用？
		1.美化页面
		2.让结构代码和样式代码进行分离
			a.提高代码复用性
			b.提高代码维护性
			c.提高开发效率
		
	css的引入方式？
		方式一：
			在html标签中添加一个style属性，在style属性中写：
				<div style="属性名:属性值;属性名:属性值"></div>
		
		方式二：
			在head标签中添加style标签，在style标签中写选择器：
				<head>
					<style>
						选择器: {
						
						}
						
						选择器: {
						
						}
					</style>
				</head>
		
		方式三：
			在head标签中添加link标签，用来引入外来的css文件：
				<link rel="stylesheet" href="css文件路径"/>
		
		注意：如果三种方式都设置了，样式也一样，就近原则
		
	css的选择器？
		什么是选择器？
			能够帮助我们快速的找到某个或者某个标签的东西
			
		基本选择器？
			元素选择器：
				格式：
					标签名 {
						属性名:属性值
						属性名:属性值
						... ...
					}
			
			id选择器：
				格式：
					#id属性值 {
						属性名:属性值
						属性名:属性值
						... ...
					}
					
			类选择器：
				格式：
					.class属性值 {
						属性名:属性值
						属性名:属性值
						... ...
					}
			
		复杂选择器？
			通配符选择器：
				格式：
					* {
						属性名:属性值
						属性名:属性值
						... ...
					}
			
			包含(后代)选择器：
				格式：
					标签名 标签名 {
						属性名:属性值
						属性名:属性值
						... ...
					}
					
			子元素选择器：
				格式：
					标签名 > 标签名 {
						属性名:属性值
						属性名:属性值
						... ...
					}
					
			组合选择器：
				格式：
					选择器1,选择2,... {
						属性名:属性值
						属性名:属性值
						... ...
					}
			
			属性选择器：
				格式一：
					标签名[属性名] {
						属性名:属性值
						属性名:属性值
						... ...
					}
					
				格式二：
					标签名[属性名 = '属性值'] {
						属性名:属性值
						属性名:属性值
						... ...
					}
				
				
				
				
				
				
				
				
				
				
				
				1.css
	css的选择器？
		什么是选择器？
			能够帮助我们快速的找到某个或者某个标签的东西
			
		基本选择器？
			元素选择器：
				格式：
					标签名 {
						属性名:属性值
						属性名:属性值
						... ...
					}
			
			id选择器：
				格式：
					++++#id属性值 {
						属性名:属性值
						属性名:属性值
						... ...
					}
					
			类选择器：
				格式：
					.class属性值 {
						属性名:属性值
						属性名:属性值
						... ...
					}
			
		复杂选择器？
			通配符选择器：
				格式：
					* {
						属性名:属性值
						属性名:属性值
						... ...
					}
			
			包含(后代)选择器：
				格式：
					标签名 标签名 {
						属性名:属性值
						属性名:属性值
						... ...
					}
					
			子元素选择器：
				格式：
					标签名 > 标签名 {
						属性名:属性值
						属性名:属性值
						... ...
					}
					
			组合选择器：
				格式：
					选择器1,选择2,... {
						属性名:属性值
						属性名:属性值
						... ...
					}
			
			属性选择器：
				格式一：
					标签名[属性名] {
						属性名:属性值
						属性名:属性值
						... ...
					}
					
				格式二：
					标签名[属性名 = '属性值'] {
						属性名:属性值
						属性名:属性值
						... ...
					}
					
			复合选择器：
				<style>
					.aaa b,.bbb input {
						color: red;
					}
				</style>
				
				<div class="aaa">
					<b>在吗</b>
					<input />
				</div>
				<div class="bbb">
					<b>约吗</b>
					<input />
				</div>
				
			伪类选择器：
				:link  设置 a 对象在未被访问前的样式
				:hover  设置对象在其鼠标悬停时的样式（可以在悬停时同时设置cursor：pointer样式，将鼠标变为抓手）
				:active 设置对象在被用户激活(在鼠标点击与释放之间发生的事件)时的样式
				:visited 设置 a 对象在其链接地址已被访问过时的样式
				针对的是超链接
				
				注意：a:hover 必须在 CSS 定义中的 a:link 和 a:visited 之后，
				才能生效！a:active 必须在 CSS 定义中的 a:hover 之后才能生效！伪类名称对大小写不敏感。
				
				:focus 设置对象在成为输入焦点(该对象的 onfocus 事件发生)时的样式
				针对的是文本框
			
	css的样式？
		1.字体样式
			font-family：规定文本的字体
			font-style：用于指定斜体文本
			font-weight：指定字体的粗细
			font-size：设置文本的大小
			font: 复合属性
				font-style
				font-variant
				font-weight
				font-size/line-height
				font-family
				
				注意：
					1.属性值是有先后顺序的
					2.font-size 和 font-family 的值是必需的。如果缺少其他值之一，则会使用其默认值。
			
		2.文本样式
			color：设置文本的颜色
			text-align：设置文本的水平对齐方式
			text-decoration：设置或删除文本装饰
			text-indent：指定文本第一行的缩进
			line-height：指定行之间的间距
			
		3.背景样式
			background-color：指定元素的背景色
			background-image：指定用作元素背景的图像
			background-repeat：指定背景图像重复情况
			
		4.边框样式
			border-style：指定要显示的边框类型
			border-width：指定四个边框的宽度
			border-color：设置四个边框的颜色
			border-radius：向元素添加圆角边框
			border：复合属性
				border-width
				border-style（必需）
				border-color
			
		5.外边距和内边距(盒子模型)
			使用盒子模型对页面进行布局
			div + css
			
			外边距(外补丁)：
				margin-top：外上边距
				margin-right：外右上边距
				margin-bottom：外下边距
				margin-left：外左边距
				
			内边距(内补丁)：
				padding-top：内上边距
				padding-right：内右边距
				padding-bottom：内下边距
				padding-left：内左边距
				
			box-sizing属性：允许我们在元素的总宽度和高度中包括内边距（填充）和边框
				默认情况下，元素的宽度和高度是这样计算的：
					width + padding + border = 元素的实际宽度
					height + padding + border = 元素的实际高度
			
				box-sizing: border-box;
				
		6.浮动
			周六自学：设置浮动，清除浮动
			
		7.定位
			周六自学：相对定位，绝对定位
			
			
			
			
			
			
			
			
			
			1.css
	css的样式？		
		6.浮动
			可以帮助我们实现将多个div块放在一行上
			
			float：设置浮动
				left - 左浮动
				right - 右浮动
				none - 不浮动
				
			clear：清除浮动
				none - 不清楚浮动
				left - 清除左浮动
				right- 清除右浮动
				both - 清除左右浮动
			
		7.定位
			通过设置定位，来使用top,left,right,bottom属性
			
			position：设置定位
				相对定位：relative
					相对于其正常位置进行定位
					
					注意：设置相对定位不会影响其他元素
				
			
				绝对定位：absolute
					相对于最近的定位祖先元素进行定位
					
					注意：设置绝对定位会影响其他元素
			
2.js
	什么是js？
		js全称叫做JavaScript，它是一门编程语言，也是一门脚本语言
		
		编程语言：里面带有逻辑算法
		脚本语言：不需要编译解释执行，而是直接解析执行
			脚本一词来源古代的戏子，唱戏的。戏子看着手中的脚本就知道做什么动作
		
		注意：JavaScript和Java没有任何关系，但是由于它的创建SUN公司有参与，所以JS的基础语法和Java有99%的相似，
		所以我们学过Java的程序员再学习JS是相当简单的
		
		JavaScript = ECMAScript(基础语法) + BOM(JS特有的,浏览器对象模型) + DOM(文档对象模型)
		
	js的作用？
		让页面动起来
		
	js的引入方式？
		方式一：
			在head标签中写script标签
			
			<head>
				<script>
					alert("约吗");
				</script>
			</head>
		
		方式二：
			在head标签中写script标签，在此标签中引入外来文件
			
			<head>
				<meta charset="utf-8">
				<title>js引入方式</title>
				<script src="../js/aaa.js"></script>
			</head>
			
		注意：
			1.script标签是可以写在任意位置的
			2.script标签是可以写多个的
			3.多个script标签的执行是先后顺序的，自上而下
	
	ECMAScript？
		常量，变量，数据类型，运算符，流程控制语言，数组，函数，对象...
		
		注释？
			Java的注释：
				1.单行注释 //
				2.多行注释 /*  */
				3.文档注释 /** */
			
			js的注释：
				1.单行注释 //
				2.多行注释 /*  */
				
		数据类型？
			Java的数据类型：
				2大类4小类8小种
				
				基本数据类型
					整型：byte,short,int,long
					浮点型：float,double
					字符型：char
					布尔型：boolean
				
				引用数据类型
					核心类库中的
					我们自定义的
				
			js的数据类型：
				原始数据类型(java中的基本数据类型)：
					Undefined、Null、Boolean、Number 和 String
					
					number：数字类型，包括了小数，整数，NaN(Not a Number)
					Booolean：布尔类型，包括true和false
					String：字符串类型，"abc"
					Null：null类型，既是一个数据类型，也是一个值
					Undefined：undefined类型，既是一个数据类型，也是一个值
				
				引用数据类型：
					String，Date，Number，Boolean，Object......
					自定义对象
		
		变量？
			Java的变量：强类型的语言
				数据类型 变量名 = 数据;
				  int       i   = 12;
				  
				说明：当我们运行程序的时候，int i = 12会在内存开辟一块空间，空间的名字就是i，空间中存储
				的数据的数据类型就是int，空间中存储的数据就是12
			
			js的变量：弱类型的语言
				var 变量名 = 数据;
				var    i   =   12;
				
				说明：当我们运行程序的时候，var i = 12会在内存开辟一块空间，空间的名字就是i，没有给空间
				存储的数据指定数据类型，空间中存储的数据就是12
				
				let 变量名 = 数据;
				let   i    =  12;
				
			注意：
				1.测试变量可以使用以下几种方式：
					alert(i);
					document.write(i);
					console.log(i);
				2.查看变量的数据类型有以下几种方式：
					typeof 变量名
					typeof(变量名)
				
		常量？		
			Java的常量：
				java常量的分类：
					字面值常量：
						整数常量
						小数常量
						字符常量
						字符串常量
						布尔常量
						空常量
					自定义常量：
						被final修饰的变量
				
			js的常量：
				js常量的分类：
					字面值常量
					自定义常量:
						const 变量名 = 数据;
						
		
		运算符？
			1.算术运算符
				+,-,*,/,++,--...
				
				/：
					Java中的/：
						整数除以整数，结果也为整数
						
						System.out.println(10/3);
						System.out.println(2/5);
					
					js的/：
						结果该是什么就是什么
						
						alert(2/5);
						alert(5/2);
				
				+：
					Java中的+：
						1.加减的加号
						2.连接符
						3.正负的正
					
					js中的+：
						1.加减的加号
						2.连接符
						3.正负的正
						4.转换符
							a.string -> number
								数字格式的字符串：
									var i = "123";
									var j = 12;
									var a = +i + j;
									alert(a);
									alert(typeof a);
								
								非数字格式的字符串：
									var i = "约吗";
									var j = 12;
									var a = +i + j;
									alert(a);
									alert(typeof a);
							
							b.boolean -> number
								//var i = true;
								var i = false;
								var j = 12;
								var a = +i + j;
								alert(a);
								alert(typeof a);
								
								true —> 1
								false -> 0
								
				++,--：
					和Java中的是一样的
					
					var i = 10;
					var j = ++i + i++ + i-- + --i;
					alert(j);
			
			2.赋值运算符
				=,+=,-=,...
				和Java是一样的
			
			3.比较运算符
				>,<,>=,<=,!=,==,===
				
				>,<：
					java中的>：
						String s1 = "abc";
						String s2 = "ab";
						System.out.println(s1 > s2);//编译报错
						
					js中的>：
						var s1 = "abc";
						var s2 = "ab";
						alert(s1 > s2);//比较的是字典顺序
						
				==：
					java中的==：
						int i = 12;
						int j = 12;
						System.out.println(i == j);//true
						
						int i = 12;
						String j = "12";
						System.out.println(i == j);//编译报错
					
					js中的==：
						var i = 12;
						var j = 12;
						alert(i == j);//true
						
						var i = 12;
						var j = "12";
						alert(i == j);//true
						
				===：
					var i = 12;
					var j = "12";
					alert(i === j);//true
					
					===必须是数据类型和数值都一样才是true
			
			4.逻辑运算符
				!,&&,||...
				和Java中的是一样的
			
			5.三元运算符
				Java中的三元运算符：
					条件表达式 ? 表达式1 : 表达式2;
					
					1 > 2 ? System.out.println(1):System.out.println(2);//编译报错
				
				js中的三元运算符：
					条件表达式 ? 表达式1 : 表达式2;
					
					1 > 2 ? alert(1) : alert(2);//正确
		
		
		
		
		
		
		
		
		
		
		1.js
	a.ECMAScript(js的基础语法)？
		流程控制语句？
			if...else, switch, for...
			
			1.if...else
				java中的if...else：
					if(条件表达式) {
						
					} else {
					
					}
					
					条件表达式必须是boolean类型的数据
					
				js中的if...else：
					if(条件表达式) {
					
					} else {
					
					}
					
					条件表达式可以为任意类型的数据
					
					但是只有几个值(false,0,"",null,NaN,undefined)为false，其余的全是true
					
			2.switch
				java中的switch：
					switch(表达式) {
						case 取值1:
							xxxooo;
							break;
						case 取值2：
							xxxooo;
							break;
						... ...
					}
					
					表达式的数据类型可以为byte,short,int,char,枚举,String
					
				js中的switch：
					switch(表达式) {
						case 取值1:
							xxxooo;
							break;
						case 取值2：
							xxxooo;
							break;
						... ...
					}
					
					表达式的数据类型可以为任意类型
					
			3.for循环
				注意：写循环的时候，不要写int 
				
				for(var i = 0; i < 10; i++) {
				
				}
					
		*函数(方法)？
			java中的方法：
				修饰符 返回值类型 方法名字(参数列表) {
					xxxooo;
					return 返回值;
				}
				
				public void aaa() {
					return;
				}
				
			js中的方法：
				在js中函数有三层含义：*1.方法，2.对象，3.构造方法
			
				格式一：
					function 方法名(参数列表) {
						xxxooo;
						return 返回值;
					}
					
					function aaa() {
					
					}
				
				格式二：
					var 变量名 = function(参数列表) {
						xxxooo;
						return 返回值;
					}
					
					var a = function() {
					
					}
				
				*函数作为方法？
					1.无参无返回值
						function aaa() {
							alert("约吗");
						}
						
						aaa();
						
						----------------
						
						var bbb = function() {
							alert("滚犊子");
						}
						
						bbb();
						
					2.有参数
						function aaa(i) {
							alert(i);
						}
						
						aaa(12);
						
						function bbb(i, j) {
							alert(i + j);
						}
						
						bbb(1,2);
					
					3.有返回值
						function aaa() {
							alert("约吗");
							return 12;
						}
						
						var a = aaa();
						alert(a);
					
						function bbb() {
							return "约吗";
						}
						
						alert(bbb());
						
					4.传参数量不定
						function aaa(i) {
							alert(i);
						}
						
						//aaa(12);
						aaa(13,14);
						aaa(14,15,16,17);
						
						注意：每个函数中默认都带有一个arguments数组，所以传递多个少都不会报错，都会存储到数组
						容器中
				
				函数作为对象？
					function person() {
						//name
					}

					//给person对象动态绑定一个uname属性
					person.uname = "tom";
					//给person对象动态绑定一个age属性
					person.age = 18;
					
					alert(person.uname);
					alert(person.age);
					
					person.setUname = function(uname) {
						this.uname = uname;
					}
					
					person.setAge = function(age) {
						this.age = age;
					}
					
					person.getUname = function() {
						return this.uname;
					}
					
					person.getAge = function() {
						return this.age;
					}
					
					person.setUname("jerry");
					person.setAge(19);
					
					alert(person.getUname());
					alert(person.getAge());
				
				函数作为构造方法？
					function Person() {
						//prototype
					}
					
					Person.prototype.name = "tom";
					Person.prototype.age = 18;
					
					var person = new Person();
					alert(person.name);
					alert(person.age);
			
		数组？
			java中的数组：
				int[] arr = new int[5];
				int[] arr = {1,2,3,4,5};
				
			js中的数组：
				数组的创建？
					格式一：
						var arr = [1,2,3,4,5];
						
						注意：1,2,3,4,5都是元素
					
					格式二：
						var arr = new Array(1,2,3,4,5);
						
						注意：1,2,3,4,5都是元素
					
					格式三：
						var arr = new Array(5);
						
						注意：5是数组的长度
						
					注意：js中的数组更像是java中的集合
			
				数组的遍历？
					方式一：普通for（中间未被定义的会被获取，值为undefined）
						var arr = [13,15,17];
			
						for(var i = 0; i < arr.length; i++) {
							document.write(arr[i] + "<br>");
						}
					
					方式二：for...in（中间未定义的不会被获取）
						for(var i in arr) {
							document.write(arr[i] + "<br>");
						}
						
					两种方式的区别？
						var arr = [12,13];
						arr[5] = 14;
						arr[4] = undefined;
						
						for(var i = 0; i < arr.length; i++) {
							document.write(arr[i] + "<br>");
						}
						
						/* for(i in arr) {
							document.write(arr[i] + "<br>");
						} */
				
				数组属性和方法？
					属性：
						length
					
					方法：
						join():可将所有数组元素结合为一个字符串
						pop():从数组中删除最后一个元素
						push()：（在数组结尾处）向数组添加一个新的元素
			
		对象？
			Date：
				getTime()：返回自 1970 年 1 月 1 日午夜以来与指定日期的毫秒数
				toLocaleDateString()：使用区域设置约定将 Date 对象的日期部分作为字符串返回
				toLocaleTimeString()：使用区域设置约定将 Date 对象的时间部分作为字符串返回
				toLocaleString()：使用区域设置约定将 Date 对象转换为字符串
			
			String：
				charAt()：返回在指定位置的字符
				concat()：连接字符串
				indexOf()：检索字符串
			
			Math：
				abs(x)：返回 x 的绝对值
				floor(x)：返回 x，向下舍入为最接近的整数
				ceil(x)：返回 x，向上舍入为最接近的整数
				random()：返回 0 到 1 之间的随机数
			
			RegExp：正则表达式
				什么是正则表达式？
					它就是字符串，只不过里面的内容是根据固定的规则写出来的字符串
				
				正则表达式的作用？
					对表单进行校验
					
				常见的正则表达式的规则？
					\\：反斜线字符 
					[abc]：a或b或c的任意一个字符 
					[a-zA-Z]：a-z，A-Z之间的任意一个字符
					.：任何字符 
					\d：等价于[0-9]
					[0-9]：0-9的任意一个字符
					^：行的开头 
					$：行的结尾 
					X?：X，一次或一次也没有 
					X*：X，零次或多次 
					X+：X，一次或多次 
					X{n}：X，恰好 n 次 
					X{n,}：X，至少 n 次 
					X{n,m}：X，至少 n 次，但是不超过 m 次 
				
				正则表达式对象的创建？
					方式一：
						var reg = new RegExp("正则表达式规则");
					
					方式二：
						var reg = /正则表达式规则/;
						
						注意：因为方式二的格式不是字符串，所以不需要写\\，只需要写\
						
				正则表达式的校验方法？
					test(要被校验的字符串);
					
				练习？
					校验手机号？
						var reg = new RegExp("^1[3-9]\\d{9}$");
						var flag = reg.test("15658585858");
						alert(flag);
						
						------------------------------------------
						
						var reg = /^1[3-9]\d{9}$/;
						var flag = reg.test("15658585858");
						alert(flag);
			
			Global：
				global对象中的方法不用对象名调用，可以直接使用里面方法
				
				encodeURI()：对 URI 进行编码
				decodeURI()：解码 URI
				encodeURIComponent()：对 URI 组件进行编码
				decodeURIComponent()：解码 URI 组件
				eval()：评估字符串并像脚本代码一样执行它
				isNaN()：确定值是否是非法数字
				parseInt()：解析字符串并返回整数
				
	b.DOM
		文档对象模型
		
		1.获取标签对象
			格式：var/let 变量名 = document.getElementById("标签的id属性值");
			
			a.如果script标签在目标标签的下面
				<body>
					<div id="aaa"></div>
					<input id="bbb"/>
				</body>
				<script>
					//获取div标签对象
					var div = document.getElementById("aaa");
					alert(div);
					
					//获取input标签对象
					var input = document.getElementById("bbb");
					alert(input);
				</script>
				
			b.如果script标签在目标标签的上面
				<head>
					<meta charset="utf-8">
					<title></title>
					<script>
						//当整个页面加载完才会执行该方法体中的内容
						window.onload = function() {
							//获取div标签对象
							var div = document.getElementById("aaa");
							alert(div);
							
							//获取input标签对象
							var input = document.getElementById("bbb");
							alert(input);
						}
					</script>
				</head>
				<body>
					<div id="aaa"></div>
					<input id="bbb"/>
				</body>
				
				
				
				1.js
	b.DOM
		文档对象模型

		1.获取标签对象
			格式：var/let 变量名 = document.getElementById("标签的id属性值");
			
			a.如果script标签在目标标签的下面
				<body>
					<div id="aaa"></div>
					<input id="bbb"/>
				</body>
				<script>
					//获取div标签对象
					var div = document.getElementById("aaa");
					alert(div);
					
					//获取input标签对象
					var input = document.getElementById("bbb");
					alert(input);
				</script>
				
			b.如果script标签在目标标签的上面
				<head>
					<meta charset="utf-8">
					<title></title>
					<script>
						//当整个页面加载完才会执行该方法体中的内容
						window.onload = function() {
							//获取div标签对象
							var div = document.getElementById("aaa");
							alert(div);
							
							//获取input标签对象
							var input = document.getElementById("bbb");
							alert(input);
						}
					</script>
				</head>
				<body>
					<div id="aaa"></div>
					<input id="bbb"/>
				</body>
			
		2.操作标签的文本内容
			a.设置文本内容
				//获取标签对象
				var div = document.getElementById("aaa");
				
				//通过对象添加文本内容
				div.innerHTML = "约吗";
				
			b.追加文本内容
				//获取标签对象
				var div = document.getElementById("aaa");
				
				//通过对象添加文本内容
				div.innerHTML += "约吗";
				
			c.获取文本内容
				//获取标签对象
				var div = document.getElementById("aaa");
				
				//获取文本内容
				var text = div.innerHTML;
				alert(text);
				
		3.操作标签的样式
			方式一：
				//获取div对象
				var div = document.getElementById("aaa");
				
				//添加样式
				div.style = "border:1px solid red; font-size:100px; color:green";
				
			方式二：
				//获取div对象
				var div = document.getElementById("aaa");
				
				//添加样式
				div.style.border = "1px solid red";
				div.style.fontSize = "100px";
				div.style.color = "green";
				
		4.事件处理(单击事件)
			方式一：html的事件属性
				<script>
					function aaa() {
						//alert("你好贱");
						document.body.bgColor = "green";
					}
				</script>
				
				<input type="button" value="点我啊" onclick="aaa()">
			
			方式二：js原生代码进行事件处理
				<script>
					//当页面加载完才会执行该方法体中的内容
					window.onload = function() {
						//获取按钮对象
						var bt = document.getElementById("bt");
						
						//给按钮对象动态绑定鼠标点击事件
						bt.onclick = function() {
							alert("滚犊子");
						}
					}
				</script>
				
				<input type="button" value="点我啊" id="bt">
			
	c.BOM
		什么是BOM？
			浏览器对象模型(Browser object model)
			
			之所以叫做浏览器对象，是因为万物皆对象，js把浏览器给拆开了，
			将其中的每个部分都封装成了对象。
		
			分成哪些对象？
				Navigator对象
				Screen对象
				*Window对象
				*Location对象
				*History对象
				Document对象：因为它非常重要，所以单独抽取出来变成DOM
				
		Window对象？
			window对象中的方法不需要window对象，可以直接写
		
			常见的方法？
				弹出框相关的方法？
					alert()：显示带有一段消息和一个确认按钮的警告框
					confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框
					prompt()：显示可提示用户输入的对话框
				
				窗口打开和关闭相关的方法？
					open()：打开一个新的浏览器窗口或查找一个已命名的窗口
					close()：关闭浏览器窗口
				
				计时器相关的方法？
					setInterval()：按照指定的周期（以毫秒计）来调用函数或计算表达式
					clearInterval()：取消由 setInterval() 设置的 timeout
					
					setTimeout()：在指定的毫秒数后调用函数或计算表达式
					clearTimeout()：取消由 setTimeout() 方法设置的 timeout
			
			常见的属性？
				document：对 Document 对象的只读引用
				history：对 History 对象的只读引用
				location：用于窗口或框架的 Location 对象
		
		Location对象？
			常见的方法？
				reload()：重新加载当前文档
			
			常见的属性？
				href：设置或返回完整的 URL
				search：设置或返回从问号 (?) 开始的 URL（查询部分）
		
		History对象？
			常见的方法？
				forward()：加载 history 列表中的下一个 URL。
				back()：加载 history 列表中的前一个 URL。
				go()：加载 history 列表中的某个具体页面（传入正数n就往下n页跳转，传入负数m，就往前跳转m页；）

		
			常见的属性？	
				length：返回浏览器历史列表中的 URL 数量
	
	d.DOM
		什么是DOM？
			文档对象模型(document object model)
			
			之所以称为文档对象模型，是因为在js中外物皆对象，所以js将html文件给拆分了，将拆分的各种
			组成部分都封装成了对象。
			
			分成哪几部分？
				*Document：文档对象
				*Element：元素对象(标签)
				Attribute：属性对象
				Comment：注释对象
				Text：文本对象
				*Node：节点对象
				
		DOM树结构的分类？
			HTML DOM树
			XML DOM树
				
		document对象？
			获取标签对象的相关方法？
				getElementById()：根据id属性值获取标签对象
				getElementsByName()：根据name属性值获取标签对象们
				getElementsByTagName()：根据标签名获取标签对象们
				getElementsByClassName()：根据class属性值获取标签对象们
				
			创建相关的方法？
				createElement()：创建元素节点
				createTextNode()：创建文本节点
		
				注意：创建出来的标签对象和文本对象都是游离状态的
		
		element对象？
			element.setAttribute()：把指定属性设置或更改为指定值
			element.removeAttribute()：从元素中移除指定属性
			element.getAttribute()：返回元素节点的指定属性值
		
		node对象？
			appendChild()：向节点的子节点列表的结尾添加新的子节点
			removeChild()：删除（并返回）当前节点的指定子节点
			parentNode：返回节点的父节点
		
		
		
		
		
		
		1.js
	d.DOM
		1.js对样式的操作
			a.
				<script>
					function add() {
						var div = document.getElementById("div");
						
						//div.style = "border:1px solid red; color:yellow; font-size:100px";
						div.style.border = "1px solid red";
						div.style.color = "yellow";
						div.style.fontSize = "100px";
					}
				</script>
				<body>
					<div id="div">约吗</div>
					<input type="button" value="添加样式" onclick="add()">
				</body>
			
			b.
				<style>
					.aaa {
						border: 1px solid red;
						font-size: 100px;
						color: blueviolet;
					}
				</style>
				<script>
					function add() {
						var div = document.getElementById("div");
						div.setAttribute("class", "aaa");
					}
				</script>
				<body>
					<div id="div">约吗</div>
					<input type="button" value="添加样式" onclick="add()">
				</body>
			
			c.
				<style>
					.aaa {
						border: 1px solid red;
						font-size: 200px;
						color: orange;
					}
				</style>
				<script>
					function add() {
						var div = document.getElementById("div");
						div.className = "aaa";
					}
				</script>
				<body>
					<div id="div">约吗</div>
					<input type="button" value="添加样式" onclick="add()">
				</body>
			
		2.js的事件处理
			a.点击事件
				onclick：当用户单击元素时发生此事件
				ondblclick：当用户双击元素时发生此事件
			
			b.加载事件
				onload：在对象已加载时，发生此事件
			
			c.焦点事件
				onfocus：在元素获得焦点时发生此事件
				onblur：当元素失去焦点时发生此事件
				
				focus()：获取焦点方法
				blur()：失去焦点方法
			
			d.键盘事件
				onkeydown：当用户正在按下键时，发生此事件
					  （ function bbb(obj) {
						alert(obj.keyCode + "..." + String.fromCharCode(obj.keyCode));
						}）
					    <input type="text" onkeydown="bbb(event)">
				onkeypress：当用户按下键时，发生此事件
				onkeyup：当用户松开键时，发生此事件
			
			e.鼠标事件
				onmousedown：当用户在元素上按下鼠标按钮时，发生此事件
				onmousemove：当指针在元素上方移动时，发生此事件
				onmouseout：当用户将鼠标指针移出元素或其中的子元素时，发生此事件
				onmouseover：当指针移动到元素或其中的子元素上时，发生此事件
				onmouseup：当用户在元素上释放鼠标按钮时，发生此事件
			
			f.表单事件
				onchange：当form元素的内容、选择的内容或选中的状态发生改变时，发生此事件
					针对单选框，复选框和下拉框
				
				onselect：用户选择文本后（对于<input>和<textarea>）发生此事件
				onsubmit：在提交表单时发生此事件
					表单提交方式有哪些？
						方式一：
							<html>
								<head>
									<meta charset="utf-8">
									<title>js事件处理</title>
									<script>
										function aaa() {
											//进行表单项校验
											
											//return false;
											return true;
										}
									</script>
								</head>
								<body>
									<form action="success.html" method="get" onsubmit="return aaa()">
										<input type="submit" value="注册">
									</form>
								</body>
							</html>
							
						方式二：
							<html>
								<head>
									<meta charset="utf-8">
									<title>js事件处理</title>
									<script>
										window.onload = function() {
											var form = document.getElementById("form");
											form.onsubmit = function() {
												//return true;
												return false;
											}
										}
									</script>
								</head>
								<body>
									<form action="success.html" method="get" id="form">
										<input type="submit" value="注册">
									</form>
								</body>
							</html>
						
						方式三：
							<html>
								<head>
									<meta charset="utf-8">
									<title>js事件处理</title>
									<script>
										function aaa() {
											//对表单项进行校验
											
											//获取表单对象
											var form = document.getElementById("form");
											//调用表单的提交事件方法
											form.submit();
										}
									</script>
								</head>
								<body>
									<form action="success.html" method="get" id="form">
										
									</form>
									
									<!-- <input type="submit" value="注册"> -->
									<input type="button" value="注册" onclick="aaa()">
								</body>
							</html>
			
			
			
			
		
		1.Bootstrap
	什么是BootStrap?
		Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 
		开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷
		
	BootStrap的作用？
		1.提供了丰富css样式和组件和js插件等功能，使我们的页面变得更加的丰富多彩
		2.支持响应式布局开发
		
	Bootstrap的入门小案例？
		1.去bootstrap官网下载开发包
		2.将开发包解压缩成三个文件夹，将三个文件夹拷贝到我们的项目中
		3.去官网帮助文档查找入门案例模板，拷贝到项目中
		4.将js和css文件进行正确引入
		
	Bootstrap的栅格系统？
		什么是响应式布局？
			我们只需要开发出一套页面，可以用在不同的分辨率的设备上
		
			注意：bootstrap的响应式布局是依赖于bootstrap的栅格系统的
			
		什么是栅格系统？
			栅格：就是由很多条水平线和很多条垂直线相交叉，得到的很多个小格子，就称为栅格
			
			栅格系统：是指bootstrap规定了一行有且只能有12个小格子，进行布局的
			
		如何使用bootstrap的栅格系统？
			1.定义容器(相当于table)
				参数：container, container-fluid
			
			2.定义行(相当于tr)
				参数：row
				
			3.定义列(相当于td)
				参数：col
		
2.反射
	什么是反射？
		正射：
			1.先创建对象
			2.给对象的属性赋值，调用对象的方法
		
		反射：
			1.先创建属性或者方法
			2.将属性或者方法赋给某个对象
			
	反射相关常用的API？
		1.获取字节码文件对象
			1.类名.class
				Class clazz1 = Person.class;
				
			*2.Class.forName()
				Class clazz2 = Class.forName("com.Person");（可以解耦，降低耦合性）
			
			3.对象.getClass()
				Person p = new Person();
				Class clazz3 = p.getClass();
		
		2.获取构造方法对象（通过字节码文件对象调用方法）
			目的：为了创建对象
		
			public Constructor<T> getConstructor(Class<?>... parameterTypes)：（传的参数为构造方法的形参类型的.class,例如String.class,int.class等，看构造方法是否有形参）
										获取指定的public所修饰的构造方法对象
			public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)：
										获取指定的构造方法对象
			public Constructor<?>[] getConstructors()：获取所有的public修饰的构造方法对象
			public Constructor<?>[] getDeclaredConstructors()：获取所有的构造方法对象

			Constructor类：
				public T newInstance(Object... initargs)
				public void setAccessible(boolean flag)：
						将此对象的 accessible 标志设置为指示的布尔值。
						值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。
						暴力反射

		3.获取成员变量对象
			目的：为了给某个对象的属性赋值
		
			public Field getField(String name)：获取指定的成员变量对象
			public Field getDeclaredField(String name)：获取指定的成员变量对象
			public Field[] getFields()：获取所有的成员变量对象
			public Field[] getDeclaredFields()：获取所有的成员变量对象

			Field类：
				public void set(Object obj,Object value)
				public Object get(Object obj)
				public void setAccessible(boolean flag)：
									将此对象的 accessible 标志设置为指示的布尔值。
									值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。
									暴力反射
				
			Class类：
				获取字段对象
				获取构造方法对象
				获取成员方法对象
				public T newInstance()

				

		
	
	

			1.反射
	什么是反射？
		正射：
			1.先创建对象
			2.给对象的属性赋值，调用对象的方法
		
		反射：（是在程序运行时，动态的进行某些操作，可以复制，调用方法等）
			1.先创建属性或者方法
			2.将属性或者方法赋给某个对象
			
	反射相关常用的API？
		1.获取字节码文件对象
			1.类名.class
				Class clazz1 = Person.class;
				
			*2.Class.forName()
				Class clazz2 = Class.forName("com.Person");
			
			3.对象.getClass()
				Person p = new Person();
				Class clazz3 = p.getClass();
		
		2.获取构造方法对象
			目的：为了创建对象
		
			public Constructor<T> getConstructor(Class<?>... parameterTypes)：
															所修饰的获取指定的public构造方法对象
			public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)：
																			获取指定的构造方法对象
			public Constructor<?>[] getConstructors()：获取所有的public修饰的构造方法对象
			public Constructor<?>[] getDeclaredConstructors()：获取所有的构造方法对象

			Constructor类：
				public T newInstance(Object... initargs)
				public void setAccessible(boolean flag)：
									将此对象的 accessible 标志设置为指示的布尔值。
									值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。
									暴力反射

		3.获取成员变量对象
			目的：为了给某个对象的属性赋值
		
			public Field getField(String name)：获取指定的成员变量对象
			public Field getDeclaredField(String name)：获取指定的成员变量对象
			public Field[] getFields()：获取所有的成员变量对象
			public Field[] getDeclaredFields()：获取所有的成员变量对象

			Field类：
				public void set(Object obj,Object value)
				public Object get(Object obj)
				public void setAccessible(boolean flag)：
								将此对象的 accessible 标志设置为指示的布尔值。
								值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。
								暴力反射
				
			Class类：
				获取字段对象
				获取构造方法对象
				获取成员方法对象
				public T newInstance()
				
		4.获取成员方法对象
			目的：为了调用某个对象的该方法
		
			public Method getMethod(String name,Class<?>... parameterTypes)：
																获取指定的public修饰的成员方法对象
			public Method getDeclaredMethod(String name, Class<?>... parameterTypes)：
																获取指定的成员方法对象
			public Method[] getMethods()：获取所有的public修饰的成员方法
			public Method[] getDeclaredMethods()：获取所有的成员方法

			Method类：
				public Object invoke(Object obj,Object... args)
				public void setAccessible(boolean flag)：
									将此对象的 accessible 标志设置为指示的布尔值。
									值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。
									暴力反射
	
	练习题？
		题一：
			已知有一个集合，泛型为String，要求通过反射技术向容器中添加Integer类型的数据？
				
		题二：
			模拟框架，实现功能：通过反射技术来调用我们指定的某个类中的某个方法(空参)
			

2.注解（本质是继承了接口的接口）
	什么是注解？
		注解（Annotation），也叫元数据。一种代码级别的说明。
		它是JDK1.5及以后版本引入的一个特性，
		与类、接口、枚举是在同一个层次。
		它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释
		
		注解就是用来解释，说明用的
		
		注释：解释说明的，是给程序员看的
		注解：解释说明的，是给程序看的
		
	注解的作用？
		1.编写文档：通过代码里标识的注解生成文档【生成文档doc文档】
		2.代码分析：通过代码里标识的注解对代码进行分析【使用反射】
		3.编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】
		
	注解的书写位置？
		1.类的上面
			@注解
			class Demo {
			
			}
		
		2.属性的上面
			class Demo {
				@注解
				int i;
			}
		
		3.方法的上面
			class Demo {
				@注解
				public void show() {
				
				}
			}
		
		4.参数的前面
			class Demo {
				public void show(@注解 int i) {
				
				}
			}
			
	注解的分类？
		预定义注解？
			Java自带的注解
			
			@Override：用来判断它所标注的方法是不是重写的方法
			@Deprecated：用来告知它所标注的方法已经过时的，不推荐使用
			@SuppressWarnings：用来压制警告
				常用值：@SuppressWarnings("all")，all是压制所有警告的意思
		
		自定义注解？
			我们自己定义的注解
			
			定义格式？
				@元注解
				修饰符 @interface 注解名字 {
					xxxooo
				}
				
			本质？
				public interface com.annotation.MyAnno1 extends java.lang.annotation.Annotation {
				
				}
				
				注解的本质就是默认继承了Annotation接口的接口
				
			注解的属性？
				什么是注解的属性？
					注解中的属性就是接口中的抽象方法
					
				属性的定义格式？
					数据类型 属性名();
					 int     aaa();
					 
					注意：属性的数据类型只能是以下几种数据类型
							基本数据类型
							String
							枚举
							注解 
							以上几种数据类型的数组类型
							
				属性的书写？
					public @interface MyAnno05 {
						int aaa();
						String bbb();
						MyEnum ccc();
						MyAnno1 ddd();
						String[] eee();
					}
					
				属性的使用？
					使用格式：@注解名(属性名=属性值, 属性名=属性值, ... ...)
					
					//@MyAnno05
					//@MyAnno05(aaa=2)
					//@MyAnno05(bbb="tom")
					//@MyAnno05(ccc=MyEnum.E1)
					//@MyAnno05(ddd=@MyAnno1)
					//@MyAnno05(eee="tom")
					//@MyAnno05(eee={"tom"})
					//@MyAnno05(eee = {"tom","jerry","rose"})
					public class Demo05 {
						public static void main(String[] args) {
							
						}
					}

					@interface MyAnno05 {
						//int aaa();
						//String bbb();
						//MyEnum ccc();
						//MyAnno1 ddd();
						String[] eee();
					}
					
					我们在使用属性的时候需要注意哪些问题？
						1.如果属性有多个，我们都要赋值，属性名=数值名之间要用逗号隔开
							@MyAnno05(aaa=12,bbb="abc",ccc=MyEnum.E2,ddd=@MyAnno1,eee= {"tom","jerry"})
							public class Demo05 {
								public static void main(String[] args) {
									
								}
							}

							@interface MyAnno05 {
								int aaa();
								String bbb();
								MyEnum ccc();
								MyAnno1 ddd();
								String[] eee();
							}

							enum MyEnum {
								E1, E2;
							}
							
						2.我们可以使用default关键字来给属性赋默认初始值，如果属性有了默认初始值，我们在
						使用的时候，是可以不给属性赋值的，也可以给属性赋值
							//@MyAnno06
							//@MyAnno06(age=13)
							//@MyAnno06(name="jerry")
							@MyAnno06(age=13,name="jerry")
							public class Demo06 {

							}

							@interface MyAnno06 {
								int age() default 12;
								String name() default "tom";
							}
							
						3.如果注解中的属性有且只有一个，并且该属性的名字叫做value的话，那我们在赋值的
						时候是可以不用写属性名的
							//@MyAnno07(value="tom")
							@MyAnno07("tom")
							public class Demo07 {

							}

							@interface MyAnno07 {
								String value();
							}
							
							--------------------------------
							
							@MyAnno08(age=18,value="tom")
							//@MyAnno08("tom")
							public class Demo08 {

							}

							@interface MyAnno08 {
								String value();
								int age();
								//int age() default 18;
							}
		
	元注解？
		什么是元注解？
			用来标注注解的注解就是元注解
		
		常见的元注解？
			@Target：设置被该注解所标注的注解的使用范围的
				属性名：ElementType[] value()
				属性值：
					ElementType.TYPE：被标注的注解可以放在类上面
					ElementType.FIELD：被标注的注解可以放在字段上面
					ElementType.METHOD：被标注的注解可以放在方法上面
				
				@MyAnno09
					public class Demo09 {
						@MyAnno09
						int i;
						
						@MyAnno09
						public void show() {
							
						}
					}

					//@Target(value = {ElementType.TYPE})
					//@Target(value=ElementType.TYPE)
					//@Target(ElementType.TYPE)
					//@Target(ElementType.FIELD)
					@Target(ElementType.METHOD)
					@interface MyAnno09 {
						
					}
			
			@Retention：设置被该注解所标注的注解的生存时长（比较常用，特别是第三个属性值）
				属性名：RetentionPolicy value()
				属性值：
					RetentionPolicy.SOURCE：此类型会被编译器丢弃
					RetentionPolicy.CLASS：此类型注解会保留在class文件中，但JVM会忽略它
					RetentionPolicy.RUNTIME：此类型注解会保留在class文件中，JVM会读取它
			
			@Documented：设置被该注解所标注的注解是否存在于帮助文档中
			
			@Inherited：设置被该注解所标注的注解是否被子类继承
			
	注解的解析？
		什么是注解的解析？
			使用反射技术，来获取注解中的属性的属性值，将获取到的属性值应用到程序中，可以起到配置文件的效果
			
			注意：如果想要对注解进行解析，该注解必须加上@Retention(RetentionPolicy.RUNTIME)
			
		注解的解析？
			1.注解在类名的上面
				public class Demo13 {
					public static void main(String[] args) throws Exception {
						//获取字节码文件对象
						Class clazz = Class.forName("com.annotation.A");
						
						//获取注解对象
						//Annotation anno = clazz.getAnnotation(A_anno.class);
						A_anno anno = (A_anno)clazz.getAnnotation(A_anno.class);
						
						//获取属性值
						String name = anno.name();
						int age = anno.age();
						
						System.out.println(name + "..." + age);
					}
				}

				@A_anno(name="tom", age=18)
				class A {
					
				}

				@Retention(RetentionPolicy.RUNTIME)
				@interface A_anno {
					String name();
					int age();
				}
			
			2.注解在字段名的上面
				public class Demo14 {
					public static void main(String[] args) throws Exception {
						//获取字节码文件对象
						Class clazz = Class.forName("com.annotation.B");
						
						//获取字段对象
						Field aaaField = clazz.getDeclaredField("aaa");
						
						//获取注解对象
						B_anno anno = aaaField.getAnnotation(B_anno.class);
						
						//获取属性
						String name = anno.name();
						int age = anno.age();
						
						System.out.println(name + "..." + age);
					}
				}

				class B {
					@B_anno(name="jerry",age=20)
					int aaa;
				}

				@Retention(RetentionPolicy.RUNTIME)
				@interface B_anno {
					String name();
					int age();
				}
			
			3.注解在方法的上面
				public class Demo15 {
					public static void main(String[] args) throws Exception {
						//获取字节码文件对象
						Class clazz = Class.forName("com.annotation.C");
						
						//获取方法对象
						Method showMethod = clazz.getMethod("show");
						
						//获取注解对象
						C_anno anno = showMethod.getAnnotation(C_anno.class);
						
						//获取属性值
						String name = anno.name();
						int age = anno.age();
						System.out.println(name + "..." + age);
					}
				}

				class C {
					@C_anno(name="rose",age=17)
					public void show() {
						
					}
				}

				@Retention(RetentionPolicy.RUNTIME)
				@interface C_anno {
					String name();
					int age();
				}
		
3.xml
	什么是xml？
		可扩展标记语言(Extensive Markup Language)
		
		可扩展：相对于html来说，因为html是预定义的，而xml是自定义的，所以可以扩展很多标签
		
		标记语言：里面代码都是由标签组成的
	
	
	
	
	
	
	
	
	
	1.xml
	什么是xml？
		可扩展标记语言(Extensive Markup Language)
		
		可扩展：相对于html来说，因为html是预定义的，而xml是自定义的，所以可以扩展很多标签
		
		标记语言：里面代码都是由标签组成的
	
		xml和html的区别？
			1.html中的标签都是预定义好的，xml中的标签都是自定义的
			2.html是一个非常不严谨的标记语言，我们很难把它给写错了。
			  xml是一个非常严谨的标记语言，我们很难它给写对了。
			3.html是用来展示数据的，因为它是做页面的
			  xml是用来存储数据的，因为它是做配置文件的
			  
	xml的作用？
		用来当做配置文件的
		
		xml和properties的区别？
			properties配置文件主要针对的是单项配置：
				driver=com.mysql.jdbc.Driver
				url=jdbc:mysql://localhost:3306/db3
				username=root
				password=123
			
			xml配置文件主要针对的是多项配置：
				<databases>
					<database id="mysql">
						<driver>com.mysql.jdbc.Driver</driver>
						<url>jdbc:mysql://localhost:3306/db3</url>
						<username>root</username>
						<password>123</password>
				</database>
					<database id="oracle">
						<driver>com.oracle.jdbc.Driver</driver>
						<url>jdbc:oracle://localhost:3306/db3</url>
						<username>root</username>
						<password>133</password>
					</database>
				</databases>
		
	xml的入门小案例？
		1.创建一个文件，后缀名该为.xml
		2.在文件中写以下内容：
			<?xml version="1.0"?>
			<students>
				<student>
					<name>tom</name>
					<age>18</age>
				</student>
				<student>
					<name>jerry</name>
					<age>19</age>
				</student>
			</students>
		3.通过浏览器打开此文件即可
		
	xml的语法？
		1.xml文件是以.xml为后缀名
		2.xml文件的第一行必须写文档声明
			<?xml version="1.0" encoding="utf-8"?>
			version属性：必须写的，版本号的意思
			encoding属性：告诉浏览器打开此文件使用的编码是什么，可写可不写的
		3.属性要用单引号或者双引号括起来
		4.标签的嵌套要正确嵌套
			不能我中有你，你中有我
			<student><name></student></name> 错误的
			<student><name></name></student> 正确
		5.xml是严格区分大小的
			<aaa>
			</Aaa>
		6.xml的标签名的命名规则：
			a.标签名是可以由数字，字母和符号组成
			b.数组和标点符号不能开头
			c.标签名中不能有空格
		7.xml是非常严谨的标记语言
		
	xml的约束文档？
		xml的约束的分类？
			dtd约束
			schema约束
		
		dtd约束和schema约束的区别？
			schema约束比dtd约束难
			schema约束比dtd约束好
			
		dtd约束？
			1.创建一个xml文件，写上文档声明
			2.引入xml约束
				引入方式一：
					格式：<!DOCTYPE 根元素 [元素声明]>
				
					<?xml version="1.0"?>
					<!DOCTYPE note [
					  <!ELEMENT note (to,from,heading,body)>
					  <!ELEMENT to      (#PCDATA)>
					  <!ELEMENT from    (#PCDATA)>
					  <!ELEMENT heading (#PCDATA)>
					  <!ELEMENT body    (#PCDATA)>
					]>
					<note>
					  <to>George</to>
					  <from>John</from>
					  <heading>Reminder</heading>
					  <body>Don't forget the meeting!</body>
					</note>
				
				引入方式二：
					格式：<!DOCTYPE 根元素 SYSTEM "xml的约束文档名">
					
					<?xml version="1.0"?>
					<!DOCTYPE note SYSTEM "note.dtd">
					<note>
					<to>George</to>
					<from>John</from>
					<heading>Reminder</heading>
					<body>Don't forget the meeting!</body>
					</note> 
				
				引入方式三：
					格式：<!DOCTYPE 根元素 PUBLIC "xml的约束文档名" "URL">
			3.根据约束写xml
			
		schema约束？
			注意：schema约束文件本身就是一个xml文件
			
			1.创建一个xml文件，写上文档声明
			2.引入xml约束
				a.找到根标签
				b.在根标签的属性位置中添加默认的名称空间
					xmlns="约束文档的targetNamespace的值"
				c.在根标签属性位置中关联约束文档
					xsi:schemaLocation="约束文档的targetNamespace的值 约束文档的名字"
				d.关联引入约束文档的属性(schemaLocation)的名称空间
					xmlns:xsi="xmlns的值-instance"
					例如：xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			3.根据约束写xml
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		1.xml
	xml的解析？（解析之后来获得各种值）
		就是指将xml文件中的各种数据获取到，提供给框架使用
		
		xml的解析思想？
			方式一：dom(Document Object Model)解析
				是指将xml加载进内存，形成dom树结构，我们通过树对象来操作里面的节点
				
				优点：将整个文档加载内存，形成树，就可以很方便使用document对象来操作里面的各种组成部分，
					  可以进行增删改查操作
				缺点：如果树太大了，会占内存
			
			方式二：sax(Simple API for XML)解析
				是指逐行扫描，逐行解析
				
				优点：不会形成树，逐行扫描，逐行解析，解析完了就扔了，不占内存
				缺点：因为是逐行扫描逐行解析，用完就扔了，所以不可逆，只能进行查询，不能进行增删改操作
				
		xml的解析工具？
			1.JAXP：JavaEE的技术之一，既有dom方式解析，也有sax方式解析
			2.Dom4J：开源组织提供的一套非常棒的解析工具，融合了dom和sax解析思想，提供了一套api
			3.Jsoup：它是用来解析html，做爬虫小程序的，但是由于html和xml的结构都是标签，所以也可以用来解析xml
			
		Dom4J解析工具的使用？
			注意：想要使用它，一定要先导入jar包
			
			常用API？
				SAXReader：
					public SAXReader()
					public Document read(InputStream in，String charset)：加载xml配置文件，获取document对象

				Document：
					public Element getRootElement()：获取根标签对象
					public List<Node> selectNodes(String xpath)：根据xpath表达式获取标签对象们所封装的集合容器
					public Node selectSingleNode(String xpath)：根据xpath表达式获取标签对象
					
				Element：
					public List<Element> elements()：获取所有的子标签对象们所在的集合
					public String getName()：获取标签对象名字
					public String getText()：获取标签中的文本数据
					public Element element(String name)：根据指定的标签名获取标签对象
					public String attributeValue(String name)：根据指定的属性名获取属性值
					
				Node：
					public String getName()：获取节点对象的名字
					public String getText()：获取节点的文本内容
					
		Jsoup解析工具的使用？
			注意：想要使用它，一定要先导入jar包
			
			
			常用API？
				Jsoup：
					public static Document parse(File file, String charset)：加载配置文件，获取document对象
				
				Document：
					public Element getElementById(String id)：根据id属性值获取标签对象
					public Elements getElementsByTag(String name)：根据标签名获取标签对象们
					public Elements getElementsByAttribute(String name)：根据属性名获取标签对象们
					public Elements getElementsByAttributeValue(String name, String value)：根据属性名和属性值获取标签对象们
				
				Element：
					public String html()：获取标签的内容(包括子标签)
					public String text()：获取标签的文本内容(只包含纯文本)
					public String attr(String name)：根据属性名获取属性值
					
			快速方法？    document对象的方法
				方式一：选择器			
					public Elements select(String name)：根据选择器获取标签对象们
				
				方式二：xpath
					JXDocument：
						public JXDocument(Document document)
						public List<JxNode> selN(String xpath)：根据xpath表达式获取节点对象们
						public JxNode selNOne(String xpath)：根据xpath表达式获取节点对象
					
					JxNode：
						public Element getElement()：将jxnode节点对象转换成element对象
					
2.数据库连接池
	什么是数据库连接池？
		它就是一个容器，里面提前预存储了一些数据库连接对象(Connection)
		
		池子思想：数据库连接池，线程池，... ...
		
	数据库连接池的作用？
		如果没有数据库连接池：我们想要获取数据库连接对象的话，要现去创建对象，用完还要释放资源。如果后面还
		要获取数据库连接对象的话，我们还要重新创建对象，用完还是要释放资源。消耗时间和资源
		
		如果有数据库连接池：我们有一个容器，容器中提前存储了几个数据库连接对象，如果需要用，从池子中拿，用完
		再扔到池子中。如果还要获取数据库连接对象，再从池子中拿即可。不消耗时间和资源
		
	自定义一个简单的数据库连接池？
		public class SimpleConnectionPool {
			private static LinkedList<Connection> pool = new LinkedList<>();
			
			static {
				try {
					//给池子初始化
					for(int i = 1; i <= 5; i++) {
						pool.add(JdbcUtils.getConnection());
					}
				} catch(Exception e) {
					System.out.println("池子初始化失败...");
					e.printStackTrace();
				}
			}
			
			//获取数据库连接对象
			public static synchronized Connection getConnection() {
				if(pool.size() > 0) {
					return pool.removeFirst();
				}
				
				throw new RuntimeException("对不起，服务器繁忙，请您稍后再来");
			}
			
			//归还数据库连接对象
			public static void close(Connection conn) {
				pool.addLast(conn);
			}
		}
				
	第三方提供的数据库连接池？
		C3P0, Druid
		
		在Java中自带了一个数据库连接池的接口，其他第三方提供的连接池都必须是该该接口，重写里面的方法
		
		DataSource：
			getConnection()：通过DataSource对象获取数据库连接对象
				
		Connection：
			close()：归还连接
			
			注意：如果Connection是通过DriverManager.getConnection()这种方式获取的话，那它的close()就是
			释放资源的意思，如果是通过连接池获取到的，那它的close()就是归还的意思。
				
	C3P0数据库连接池？
		方式一：使用配置文件
			第一步：导入jar包
				导入2个jar包
			第二步：导入配置文件
				注意：放在src下，并且文件名不要修改，我们只能修改配置文件中的数据
			第三步：创建C3P0的数据库连接池对象
				DataSource dataSource = new ComboPooledDataSource();
			第四步：获取数据库连接对象
				Connection conn = dataSource.getConnection();
			第五步：归还连接
				conn.close();
		
		方式二：不使用配置文件
			第一步：导入jar包
				导入2个jar包
			第二步：创建C3P0的数据库连接池对象
				ComboPooledDataSource dataSource = new ComboPooledDataSource();
			第三步：设置参数
				dataSource.setDriverClass("com.mysql.jdbc.Drvier");
				dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/db1");
				dataSource.setUser("root");
				dataSource.setPassword("123");
			第四步：获取数据库连接对象
				Connection conn = dataSource.getConnection();
			第五步：归还连接
				conn.close();
			
				
				
				
				
				
				
			
					
					1.数据库连接池
	Druid数据库连接池？
		方式一：使用配置文件
			1.导入druid相关jar包
				1个jar包
			2.导入druid配置文件
				druid.properties
			3.创建数据库连接池对象
				Properties p = new Properties();
				p.load(Demo01.class.getClassLoader().getResourceAsStream("druid.properties"));
				DataSource dataSource = DruidDataSourceFactory.createDataSource(p);
			4.获取数据库连接对象
				Connection conn = dataSource.getConnection();
			5.归还连接
				conn.close();
	
		方式二：不使用配置文件
			1.导入druid相关jar包
				1个jar包
			2.创建数据库连接池对象
				DruidDataSource dataSource = new DruidDataSource();
			3.设置参数
				dataSource.setDriverClassName("com.mysql.jdbc.Driver");
				dataSource.setUrl("jdbc:mysql://localhost:3306/db1");
				dataSource.setUsername("root");
				dataSource.setPassword("123");
			4.获取数据库连接对象
				Connection conn = dataSource.getConnection();
			5.归还连接
				conn.close();
				
2.单元测试
	@Before
	@Test
	@After
	
	先后顺序：@Before -> @Test -> @After
	
3.JdbcTemplate
	什么是JdbcTemplate？
		它是Spring框架对JDBC的封装，就是JDBC工具类，能够简化代码书写
		它还是一个基于ORM思想的工具类
		
		ORM思想？（自我理解：数据库表对应一个类，表中的一条记录对应类的一个对象，这样映射）
			对象关系映射（Object Relational Mapping）
			
			一个类对应数据库中的一张表
			类的变量对应表中的字段
			
	JdbcTemplate的使用？
		方式一：
			1.导入相关的jar包
				导入5个jar包
			2.创建JdbcTemplate对象
				JdbcTemplate jt = new JdbcTemplate(数据源);
				JdbcTemplate jt = new JdbcTemplate(DruidUtils.getDataSource());
			3.调用方法(对数据库进行增删改查)
				update
				queryForObject
				query
			
		方式二：
			1.导入相关的jar包
				导入5个jar包
			2.创建JdbcTemplate对象
				JdbcTemplate jt = new JdbcTemplate();
			3.设置数据源
				jt.setDataSource(DruidUtils.getDataSource());
			4.调用方法(对数据库进行增删改查)
				添加操作：
					jt.update("insert into user values(null, ?, ?)", "tony", 29);

				修改操作：
					jt.update("update user set name = ?, age = ? where id = ?", "mary", 30, 5);
	
				删除操作：
					jt.update("delete from user where id = ?", 5);
					
				查询操作：
					a.查询多条记录
						List<User> users = jt.query("select * from user", 
													new BeanPropertyRowMapper<User>(User.class));
	
						List<User> users = jt.query("select * from user where id in (?, ?)", 
													new BeanPropertyRowMapper<User>(User.class), 1, 2);
	
					b.查询一条记录
						User user = jt.queryForObject("select * from user where id = ?", 
													new BeanPropertyRowMapper<User>(User.class), 1);
	
					c.查询一个数据
						String name = jt.queryForObject("select name from user where id = ?", 
																					String.class, 1);
	
						int count = jt.queryForObject("select count(*) from user", int.class);
	
	
	
	
	
	
	
	
	
	
	1.Lambda表达式
	回顾匿名内部类？
		一：接口中的方法是无参无返回值
			public class Demo01 {
				public static void main(String[] args) {
					//创建Inter对象
					Inter inter = new Inter() {
						public void show() {
							System.out.println("约吗");
						}
					};
					inter.show();
				}
			}

			interface Inter {
				public void show();
			}
		
		二：接口中的方法是有参数无返回值
			public class Demo01 {
				public static void main(String[] args) {
					Inter inter = new Inter() {
						public void show(int i) {
							System.out.println(i);
						}
					};
					inter.show(12);
				}
			}

			interface Inter {
				public void show(int i);
			}
			
		三：接口中的方法有返回值没有参数
			public class Demo01 {
				public static void main(String[] args) {
					Inter inter = new Inter() {
						public int show() {
							return 12;
						}
					};
					System.out.println(inter.show());
				}
			}

			interface Inter {
				public int show();
			}
			
		四：接口中的方法有参数有返回值
			public class Demo01 {
				public static void main(String[] args) {	
					Inter inter = new Inter() {
						public int show(String s) {
							return Integer.parseInt(s);
						}
					};
					System.out.println(inter.show("12"));
				}
			}

			interface Inter {
				public int show(String s);
			}
		
		五：接口作为方法的形式参数
			public class Demo02 {
				public static void main(String[] args) {
					print(new A() {
						public void show() {
							System.out.println("约吗");
						}
					});
				}
				
				public static void print(A a) {
					a.show();
				}
			}

			interface A {
				public void show();
			}
			
		六：接口作为方法的返回值
			public class Demo03 {
				public static void main(String[] args) {
					B b = print();
					b.show();
				}
				
				public static B print() {
					return new B() {
						public void show() {
							System.out.println("滚犊子");
						}
					};
				}
			}

			interface B {
				public void show();
			}
			
	什么是lambda表达式？
		lambda表达式就是一个基于函数式思想用来替代匿名内部类的新特性
		
		什么是函数式思想？
			面向对象思想重点强调的是通过对象的形式来做一些事情
			函数式思想重点强调的是做什么事情，而不是通过什么形式去做
			
			匿名内部类重点关注的创建哪个对象
			lambda表达式重点关注的就是做什么事情
			
		注意：想要学好lambda表达式一定要先学好匿名内部类
		
	lambda表达式入门小案例？
		不使用lambda表达式？
			a.
				public class Demo01 {
					public static void main(String[] args) {
						MyRunnable mr = new MyRunnable();
						Thread t = new Thread(mr);
						t.start();
					}
				}

				class MyRunnable implements Runnable {
					@Override
					public void run() {
						System.out.println("约吗");
					}
				}
				
			b.
				public class Demo01 {
					public static void main(String[] args) {
						new Thread(new Runnable() {
							public void run() {
								System.out.println("滚犊子");
							}
						}).start();
					}
				}
		
		使用lambda表达式？
			public class Demo01 {
				public static void main(String[] args) {
					new Thread(() ->  {System.out.println("在吗");}).start();
				}
			}
			
	lambda表达式的定义格式？
		格式：(形式参数) -> {代码块}
		
		说明：
			()：就代表匿名内部类中重写抽象方法的参数列表，如果没有参数，就保留()即可
			->：固定格式，指向要做的事情是什么
			{}：代表匿名内部类中重写抽象方法的方法体的内容
			
	练习题？
		一：需求：用lambda表达式的方式来创建Inter对象，调用方法，在控制台打印出内容？
			interface Inter {
				//public void show();
				//public void show(String s);
				//public int show();
				//public int show(String s);
			}
			
		二：
			class Demo{
				public static void main(String[] args) {
					//补全代码，在控制台打印出内容即可
				}
				
				public static void print(Inter inter) {
					inter.show();
				}
			}
			
			interface Inter {
				public void show();
			}
		
		三：
			class Demo {
				public static void main(String[] args) {
					//补全代码，在控制台上打印出：约吗
												  滚犊子
				}
				
				public static void print(Inter inter) {
					inter.show("滚犊子");
				}
			}
			
			interface Inter {
				public void show(String s);
			}
		
		四：
			class Demo {
				public static void main(String[] args) {
					//补全代码，在控制台上打印出整数和
				}
				
				public static void print(Inter inter) {
					int sum = inter.show(1,2);
					System.out.println(sum);
				}
			}
			
			interface Inter {
				public int show(int i, int j);
			}
			
	lambda表达式的省略规则？
		格式：(形式参数) -> {代码块}
		
		()：
			1.空参
				小括号是不可以省略
				
				class Demo {
					public static void main(String[] args) {
						Inter inter = () -> {System.out.println("约吗");};
					}
				}
				
				interface Inter {
					public void show();
				}
			
			2.有一个参数
				数据类型可以省略不写
				小括号也是可以省略不写的
				
				class Demo {
					public static void main(String[] args) {
						//Inter inter = (int i) -> {System.out.println(i);};
						
						Inter inter = i -> {System.out.println(i);};
					}
				}
				
				interface Inter {
					public void show(int i);
				}
			
			3.有多个参数
				数据类型可以省略不写
				小括号是不可以省略的，必须写的
				
				class Demo {
					public static void main(String[] args) {
						//Inter inter = (int i, int j) -> {System.out.println(i + j);};
						
						Inter inter = (i, j) -> {System.out.println(i + j);};
					}
				}
		
				interface Inter {
					public void show(int i, int j);
				}
		
		->：不可以省略，必须写
		
		{}：
			1.有效语句只有一条的时候
				花括号可以省略不写
				分号可以省略不写
				如果有return，return也可以省略不写的
			
			2.有效语句有多条的时候
				都不可以省略
				
	lambda表达式的注意事项？
		1.要有接口
		2.接口中有且只能有一个抽象方法
		3.lambda表达式不可以单独使用
		
	lambda表达式和匿名内部类的区别？
		1.匿名内部类可以单独使用，lambda表达式不可以单独使用
		2.如果某个方法的形参的数据类型是普通类或者是抽象类的时候，我们可以使用匿名内部类，
		  但是不可以使用lambda表达式
		3.如果接口中有多个抽象方法的时候，我们可以使用匿名内部类，但是不可以使用lambda表达式了
		4.匿名内部类会生成.class文件，lambda表达式不会生成.class文件
			
	lambda表达式关于方法引用的使用？
		什么是方法引用？
			含有::引用运算符的表达式，就称为方法引用
			
		例子：
			一：
				public class Demo08 {
					public static void main(String[] args) {
						/*F f = new F() {
							public void show(String s) {
								System.out.println(s);
							}
						};
						f.show("约吗");*/
						
						/*F f = (String s) -> {
							System.out.println(s);
						};
						f.show("滚犊子");*/
						
						/*F f = s -> System.out.println(s);
						f.show("在吗");*/
						
						/*F f = System.out::println;
						f.show("哈哈");*/
					}
				}

				interface F {
					public void show(String s);
				}
			
			二：
				public class Demo09 {
					public static void main(String[] args) {
						/*G g = new G() {
							public Person show(String name) {
								return new Person(name);
							}
						};
						Person p = g.show("tom");
						System.out.println(p);*/
						
						/*G g = (String name) -> {return new Person(name);};
						Person p = g.show("jerry");
						System.out.println(p);*/
						
						/*G g = name -> new Person(name);
						Person p = g.show("rose");
						System.out.println(p);*/
						
						G g = Person::new;//G g = a -> new Person(a);
						Person p = g.show("jack");
						System.out.println(p);
					}
				}

				interface G {
					public Person show(String name);
				}

				class Person {
					private String name;
					
					public Person() {}

					public Person(String name) {
						super();
						this.name = name;
					}

					@Override
					public String toString() {
						return "Person [name=" + name + "]";
					}
				}
			
2.接口 
	1.8之前的接口的组成部分：
		常量
			默认修饰符：public static final
		抽象方法
			默认修饰符：public abstract
	
	1.8之后的接口的组成部分：
		常量
		抽象方法
		默认方法
		静态方法
	
	1.9之后的接口的组成部分：
		常量
		抽象方法
		默认方法
		静态方法
		私有方法
	
	默认方法？
		格式：
			public default 返回值类型 方法名(参数列表) {
				方法体内容;
			}
			
			public default void show() {
				System.out.println("约吗");
			}
			
	静态方法？
		格式：
			public static 返回值类型 方法名(参数列表) {
				方法体内容;
			}
			
			public static void show() {
				System.out.println("约吗");
			}
			
	私有方法？
		格式：
			private 返回值类型 方法名(参数列表) {
				方法体内容;
			}
			
			private static 返回值类型 方法名(参数列表) {
				方法体内容;
			}
			
3.函数式接口
	什么是函数式接口？
		接口中有且只有一个抽象方法的接口，就称为函数式接口
			
	函数式接口的标记？
		@FunctionalInterface
		
	函数式接口的使用？
		一：函数式接口作为方法的形参
			public class Demo02 {
				public static void main(String[] args) {
					/*show(new Runnable() {
						public void run() {
							System.out.println("约吗");
						}
					});*/
					
					show(() -> {System.out.println("约吗");});
				}
				
				public static void show(Runnable runnable) {
					Thread t = new Thread(runnable);
					t.start();
				}
			}
		
		二：函数式接口为方法的返回值
			public class Demo03 {
				public static void main(String[] args) {
					ArrayList<String> al = new ArrayList<>();
					
					al.add("bbb");
					al.add("c");
					al.add("aaaaaaa");
					al.add("eeeee");
					al.add("dddd");
					
					System.out.println(al);
				
					Collections.sort(al, getComparator());
					
					System.out.println(al);
				}
				
				public static Comparator<String> getComparator() {
					/*return new Comparator<String>() {
						@Override
						public int compare(String s1, String s2) {
							return s2.length() - s1.length();
						}
					};*/
					
					//return (String s1, String s2) -> {return s2.length() - s1.length();};
					
					return (s1, s2) -> s2.length() - s1.length();
				}
			}
		
	常用的函数式接口？
		Supplier<T> 生产型函数式接口
			T get()：获取
			
		Consumer<T> 消费型函数式接口
			void accept(T t)：消费
			
		Predicate<T> 比较型函数式接口
			boolean test(T t)
			
		Funcation<T,R> 转换型函数式接口
			R apply(T t)
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
		
		
		
			1.MyBatis
	什么是MyBatis？
		MyBatis本是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了google 
		code，并且改名为MyBatis。2013年11月迁移到Github。
		iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。
		iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）。
		
		MyBatis是一个基于ORM思想的持久层框架(半成品的软件)
		
		使用Java代码操作数据库的技术？
			1.JDBC 最原始的写法
			2.JdbcTemplate 工具类(ORM)
			3.MyBatis 框架(ORM)
			
	MyBatis的有优点？
		1.简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件。
		  易于学习，易于使用。通过文档和源代码，可以比较完全的掌握它的设计思路和实现
			
		2.灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 
		  sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。
		  
		3.解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，
		  更易单元测试。sql和代码的分离，提高了可维护性。
		  
		4.提供映射标签，支持对象与数据库的orm字段关系映射
		
		5.提供对象关系映射标签，支持对象关系组建维护
		
		6.提供xml标签，支持编写动态sql
	
	MyBatis的入门小案例？
		实现步骤：
			1.导入jar包
				2个jar包
			
			2.创建映射类
				新建一个User类
			
			3.创建dao接口
				在dao包下创建一个UserDao接口，提供一个findAll抽象方法
			
			4.编写MyBatis的核心配置文件sqlMapConfig.xml
				<configuration>
					<environments default="mysql">
						<environment id="mysql">
							<transactionManager type="JDBC"/>
							<dataSource type="POOLED">
								<property name="driver" value="com.mysql.jdbc.Driver"/>
								<property name="url" value="jdbc:mysql://localhost:3306/db3"/>
								<property name="username" value="root"/>
								<property name="password" value="123"/>
							</dataSource>
						</environment>
					</environments>
					
					<mappers>
						<mapper resource="com/mybatis/dao/UserMapper.xml"/>
					</mappers>
				</configuration>
			
			5.编写MyBatis的映射文件md
				<mapper namespace="com.mybatis.dao.UserDao">
					<select id="findAll" resultType="com.mybatis.pojo.User">
						select * from user
					</select>
				</mapper>
			
			6.写测试代码，进行测试
				//a.获取加载核心配置文件的流对象
				InputStream is = Resources.getResourceAsStream("sqlMapConfig.xml");
				
				//b.获取SqlSession工厂的构建者对象
				SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
				
				//c.获取SqlSession工厂对象
				SqlSessionFactory sqlSessionFactory = builder.build(is);
				
				//d.获取SqlSession对象
				SqlSession sqlSession = sqlSessionFactory.openSession();
				
				//e.获取UserDao代理类对象
				UserDao userDao = sqlSession.getMapper(UserDao.class);
				
				//f.进行查询操作
				List<User> users = userDao.findAll();
				for (User user : users) {
					System.out.println(user);
				}
				
				//g.释放资源
				sqlSession.close();
	
	MyBatis对数据库的常见的操作？
		1.添加操作
			UserDao：
				public void add(User user);
				
			UserMapper：
				<insert id="add" parameterType="com.mybatis.pojo.User">
					insert into user values(null, #{name}, #{age})
				</insert>
				
			UserTest：
				//e.获取UserDao代理类对象
				UserDao userDao = sqlSession.getMapper(UserDao.class);
				
				//f.进行添加操作
				User user = new User();
				user.setName("rose");
				user.setAge(16);
				userDao.add(user);
				
				//提交事务
				sqlSession.commit();
				
				//g.释放资源
				sqlSession.close();
		
		2.修改操作
		3.删除操作
		4.查询操作
			
	设计模式：
		1.构建者设计模式（创造者设计模式）（可以创造某一个类的对象，但该对象创造过程麻烦，就可以使用该设计模式）	
		2.工厂设计模式（创造多个不同对象）
		
	可以增强方法的方式有哪些？
		1.继承，重写方法
		2.装饰设计模式（day22）	
		3.动态代理设计模式（proxy）
			
			
			
			
			
			
			
			
	1.MyBatis
	MyBatis对数据库的常见的操作？
		1.添加操作
			UserDao：
				public void add(User user);
				
			UserMapper：
				<insert id="add" parameterType="com.mybatis.pojo.User">
					insert into user values(null, #{name}, #{age})
				</insert>
				
			UserTest：
				//e.获取UserDao代理类对象
				UserDao userDao = sqlSession.getMapper(UserDao.class);
				
				//f.进行添加操作
				User user = new User();
				user.setName("rose");
				user.setAge(16);
				userDao.add(user);
				
				//提交事务
				sqlSession.commit();
				
				//g.释放资源
				sqlSession.close();
		
		2.修改操作
			UserDao：
				public void update(User user);
				
			UserMapper：
				<update id="update" parameterType="com.mybatis.pojo.User">
					update user set username = #{username}, password = #{password} where id = #{id}
				</update>
				
			UserTest：
				//获取UserDao对象
				UserDao userDao = sqlSession.getMapper(UserDao.class);
				
				//修改操作
				User user = new User();
				user.setUsername("jerry");
				user.setPassword("345");
				userDao.update(user);
				
				//提交
				sqlSession.commit();
				
				//释放资源
				sqlSession.close();
		
		3.删除操作
			UserDao：
				public void delete(int id);
				
			UserMapper：
				<delete id="delete" parameterType="int">
					delete from user where id = #{id}
				</delete>
				<!-- <delete id="delete" parameterType="int">
					delete from user where id = #{aaa}
				</delete> -->
				
			UserTest：
				//获取UserDao对象
				UserDao userDao = sqlSession.getMapper(UserDao.class);
				
				//删除操作
				userDao.delete(1);
				
				//提交
				sqlSession.commit();
				
				//释放资源
				sqlSession.close();
		
		4.查询操作
			a.查询所有
				UserDao：
					public List<User> findAll();
					
				UserMapper：
					<select id="findAll" resultType="com.mybatis.pojo.User">
						select * from user
					</select>
				
				UserTest：
					//获取UserDao对象
					UserDao userDao = sqlSession.getMapper(UserDao.class);
					
					//查询所有操作
					List<User> users = userDao.findAll();
					for (User user : users) {
						System.out.println(user);
					}
					
					//释放资源
					sqlSession.close();
					
			b.根据id查询一条记录
				UserDao：
					public User findById(int id);
					
				UserMapper：
					<select id="findById" parameterType="int" resultType="com.mybatis.pojo.User">
						select * from user where id = #{id}
					</select>
					
				UserTest：
					//获取UserDao对象
					UserDao userDao = sqlSession.getMapper(UserDao.class);
					
					//查询所有操作
					User user = userDao.findById(1);
					System.out.println(user);
					
					//释放资源
					sqlSession.close();
					
			c.查询总记录数
				UserDao：
					public int count();
					
				UserMapper：
					<select id="count" resultType="int">
						select count(*) from user
					</select>
					
				UserTest：
					//获取UserDao对象
					UserDao userDao = sqlSession.getMapper(UserDao.class);
					
					//查询总记录数
					int count = userDao.count();
					System.out.println(count);
					
					//释放资源
					sqlSession.close();
					
			d.模糊查询
				方式一：
					UserDao：
						public List<User> findByUsername(String username); 
						
					UserMapper：
						<select id="findByUsername" parameterType="string" resultType="com.mybatis.pojo.User">
							select * from user where username like #{username}
						</select>
					
					UserTest：
						//获取UserDao对象
						UserDao userDao = sqlSession.getMapper(UserDao.class);
						
						//查询总记录数
						List<User> users = userDao.findByUsername("%o%");
						for (User user : users) {
							System.out.println(user);
						}
						
						//释放资源
						sqlSession.close();
				
				方式二：
					UserDao：
						public List<User> findByUsername1(String username); 
						
					UserMapper：
						<select id="findByUsername1" parameterType="string" 
																		resultType="com.mybatis.pojo.User">
							select * from user where username like '%${value}%'
						</select>
				
					UserTest：
						//获取UserDao对象
						UserDao userDao = sqlSession.getMapper(UserDao.class);
						
						//查询总记录数
						List<User> users = userDao.findByUsername1("o");
						for (User user : users) {
							System.out.println(user);
						}
						
						//释放资源
						sqlSession.close();
				
			e.分页查询
				方式一：
					UserDao：
						public List<User> findByPage(Map<String, Integer> map);
						
					UserMapper：
						<select id="findByPage" parameterType="map" resultType="com.mybatis.pojo.User">
							select * from user limit #{index}, #{page}
						</select>
						
					UserTest：
						//获取UserDao对象
						UserDao userDao = sqlSession.getMapper(UserDao.class);
						
						//分页查询
						Map<String, Integer> map = new HashMap<String, Integer>();
						map.put("index", 3);
						map.put("page", 3);
						List<User> users = userDao.findByPage(map);
						for (User user : users) {
							System.out.println(user);
						}
						
						//释放资源
						sqlSession.close();
				
				方式二：
					UserDao：
						public List<User> findByPage1(@Param("index") int index, @Param("page") int page);
					
					UserMapper：
						<select id="findByPage1" resultType="com.mybatis.pojo.User">
							select * from user limit #{index}, #{page}
						</select>
						
					UserTest：
						//获取UserDao对象
						UserDao userDao = sqlSession.getMapper(UserDao.class);
						
						//分页查询
						Map<String, Integer> map = new HashMap<String, Integer>();
						List<User> users = userDao.findByPage1(3, 3);
						for (User user : users) {
							System.out.println(user);
						}
						
						//释放资源
						sqlSession.close();
						
			f.根据id查询一条记录
				UserDao：
					public User findById1(Person person);
					
				UserMapper：
					<select id="findById1" parameterType="com.mybatis.pojo.Person"       
																		resultType="com.mybatis.pojo.User">
						select * from user where id = #{user.id}
					</select>
					
				UserTest：
					//获取UserDao对象
					UserDao userDao = sqlSession.getMapper(UserDao.class);
					
					//根据id查询一条记录
					Person p = new Person();
					User user = new User();
					user.setId(2);
					p.setUser(user);
					User u = userDao.findById1(p);
					System.out.println(u);
					
					//释放资源
					sqlSession.close();
					
			g.添加一条记录,并且返回添加的那条记录的id值
				查看最后添加的记录的id是多少？
					selecdt last_insert_id();
					
				UserDao：
					public void add1(User user);
					
				UserMapper：
					<insert id="add1" parameterType="com.mybatis.pojo.User">
						<selectKey keyColumn="id" keyProperty="id" resultType="int" order="AFTER">
							select last_insert_id()
						</selectKey>
						insert into user values(null, #{username}, #{password})
					</insert>
					
				UserTest：
					//获取UserDao对象
					UserDao userDao = sqlSession.getMapper(UserDao.class);
					
					//添加操作
					User user = new User();
					user.setUsername("lucy");
					user.setPassword("123");
					System.out.println(user);
					userDao.add1(user);
					System.out.println(user);
					
					//提交
					sqlSession.commit();
					
					//释放资源
					sqlSession.close();
					
	MyBatis核心配置文件的相关配置？
		1.配置别名
			<typeAliases>
				<!-- <typeAlias type="com.mybatis.pojo.User" alias="user"/>
				<typeAlias type="com.mybatis.pojo.Person" alias="person"/> -->
				<package name="com.mybatis.pojo"/>
			</typeAliases>
					
		2.配置动态参数
			<!-- 加载配置文件 -->
			<properties resource="jdbc.properties"/>
			
			<dataSource type="POOLED">
				<property name="driver" value="${jdbc.driver}"/>
				<property name="url" value="${jdbc.url}"/>
				<property name="username" value="${jdbc.username}"/>
				<property name="password" value="${jdbc.password}"/>
			</dataSource>
					
			jdbc.properties：
				jdbc.driver=com.mysql.jdbc.Driver
				jdbc.url=jdbc:mysql://localhost:3306/db3
				jdbc.username=root
				jdbc.password=123
					
		3.配合关联的映射文件
			<mappers>
				<!-- <mapper resource="com/mybatis/dao/UserMapper.xml"/> -->
				<package name="com.mybatis.dao"/>
			</mappers>
			
			注意：如果想要 使用package标签，要求映射文件的名字必须和接口的名字相同
					
	MyBatis映射配置文件的相关配置？
		1.配置字段名和属性名的映射关系
			<resultMap type="user" id="map">
				<!-- 配置主键 -->
				<id column="id" property="uid"/>
				<!-- 配置非主键 -->
				<result column="username" property="uname"/>
				<result column="password" property="psw"/>
			</resultMap>
			<select id="findById" parameterType="int" resultMap="map">
				select * from user where id = #{id}
			</select>
			
		2.动态SQL
			<if>
			<foreach>
			<where>
			
			a.if动态sql的使用？
				MovieDao：
					public List<Movie> findByCondition(Movie movie);
					
				MoiveMapper：
					<select id="findByCondition" parameterType="movie" resultType="movie">
						select * from movie
						<where>
							<if test="name != null">
								and name = #{name}
							</if>
							<if test="actor != null">
								and actor = #{actor}
							</if>
							<if test="country != null">
								and country = #{country}
							</if>
						</where>
					</select>
					
				MoiveTest：
					//获取UserDao对象
					MovieDao movieDao = sqlSession.getMapper(MovieDao.class);
					
					//按照条件进行查询操作
					Movie movie = new Movie();
					movie.setName("一路向东");
					movie.setActor("老党");
					movie.setCountry("中国");
					List<Movie> movies = movieDao.findByCondition(movie);
					for (Movie m : movies) {
						System.out.println(m);
					}
					
					//释放资源
					sqlSession.close();
					
					
					
					
					1.MyBatis
	1.动态SQL
		<if>
		<where>
		<foreach>
		
		foreach动态sql：
			UserDao：
				public List<User> findByIds(int[] ids);
				
			UserMapper：
				<select id="findByIds" resultType="user" parameterType="int[]">
					select * from user
					<where>
						<foreach collection="array" open="id in (" close=")" item="id" separator=",">
							#{id}
						</foreach>
					</where>
				</select>
				
			UserTest：
				//获取UserDao对象
				UserDao userDao = sqlSession.getMapper(UserDao.class);
				
				//根据id们查询
				int[] arr = {2,3};
				List<User> users = userDao.findByIds(arr);
				for (User user : users) {
					System.out.println(user);
				}
				
				//释放资源
				sqlSession.close();
				
	2.多表查询
		表与表之间的关系？
			一对一
			一对多(多对一)
				举例子：
					电脑表和用户表
						一个用户可以有多台电脑
						一个电脑属于一个用户
					老公表和老婆表
						一个老公可以有多个老婆
						一个老婆属于一个老公
			多对多
				举例子：
					学生表和老师表
						一个学生可以有多个老师
						一个老师可以有多个老师
						
		MyBatis针对多表查询的分类？
			一对一查询：
				在表与表之间的关系为一对多的时候，当我们查询多的一方的时候，顺带查询一的一方，
				这种情况就称为一对一查询
				
			举例子：老公表和老婆表
				方式一：
					WifeDao：
						public List<Wife> findAll();
						
					WifeMapper：
						<resultMap type="wife" id="wifeHusbandMap">
							<id column="id" property="id"/>
							<result column="name" property="name"/>
							<result column="hid" property="hid"/>
							<association property="husband" column="hid" javaType="husband">
								<id column="hid" property="id"/>
								<result column="hname" property="name"/>
							</association>
						</resultMap>
						<select id="findAll" resultMap="wifeHusbandMap">
							<!-- select * from wife w left join husband h on w.hid = h.id -->
							select w.*, h.id hid, h.name hname from wife w left join husband h on w.hid = h.id;
						</select>
						
					WifeTest：
						//获取WifeDao对象
						WifeDao wifeDao = sqlSession.getMapper(WifeDao.class);
						
						//查询所有老婆
						List<Wife> wifes = wifeDao.findAll();
						for (Wife wife : wifes) {
							System.out.println(wife);
						}
						
						//释放资源
						sqlSession.close();
						
					Wife：
						public class Wife {
							private int id;
							private String name;
							private int hid;
							
							private Husband husband;
						}
						
					Husband：
						public class Husband {
							private int id;
							private String name;
						}
				
				方式二：
					WifeDao：
						public List<Wife> findAll();
						
					WifeMapper：
						<resultMap type="wife" id="wifeHusbandMap">
							<id column="id" property="id"/>
							<result column="name" property="name"/>
							<result column="hid" property="hid"/>
							<association property="husband" column="hid" javaType="husband" select="com.mybatis.dao.HusbandDao.findById"/>
						</resultMap>
						<select id="findAll" resultMap="wifeHusbandMap">
							select * from wife
						</select>
						
					WifeTest：
						//获取WifeDao对象
						WifeDao wifeDao = sqlSession.getMapper(WifeDao.class);
						
						//查询所有老婆
						List<Wife> wifes = wifeDao.findAll();
						for (Wife wife : wifes) {
							System.out.println(wife);
						}
						
						//释放资源
						sqlSession.close();
					
					HusbandDao：
						public Husband findById(int id);
					
					HusbandMapper：
						<select id="findById" parameterType="int" resultType="husband">
							select * from husband where id = #{id}
						</select>
						
					Wife：
						public class Wife {
							private int id;
							private String name;
							private int hid;
							
							private Husband husband;
						}
						
					Husband：
						public class Husband {
							private int id;
							private String name;
						}
				
			一对多查询？
				a.在表与表之间的关系为一对多的时候，当我们查询一的一方的时候，顺带查询多的一方，
				这种情况就称为一对多查询
				
					举例子：老公表和老婆表
					
					方式一：
						HusbandDao：	
							public List<Husband> findAll();
							
						HusbandMapper：	
							<resultMap type="husband" id="husbandWifeMap">
								<id column="id" property="id"/>
								<result column="name" property="name"/>
								
								<collection property="wifes" column="id" ofType="wife">
									<id column="wid" property="id"/>
									<result column="wname" property="name"/>
									<result column="hid" property="hid"/>
								</collection>
							</resultMap>
							<select id="findAll" resultMap="husbandWifeMap">
								select h.*, w.id wid, w.name wname, w.hid from husband h left join wife w on h.id = w.hid
							</select>
							
						Husband：
							public class Husband {
								private int id;
								private String name;
								
								private List<Wife> wifes;
							}
							
						Wife：
							public class Wife {
								private int id;
								private String name;
								private int hid;
								
								private Husband husband;
							}
							
						HusbandTest：
							//获取HusbandDao对象
							HusbandDao husbandDao = sqlSession.getMapper(HusbandDao.class);
							
							//查询所有老公
							List<Husband> husbands = husbandDao.findAll();
							for (Husband husband : husbands) {
								System.out.println(husband);
							}
							
							//释放资源
							sqlSession.close();
					
					方式二：
						HusbandDao：	
							public List<Husband> findAll();
							
						HusbandMapper：
							<resultMap type="husband" id="husbandWifeMap">
								<id column="id" property="id"/>
								<result column="name" property="name"/>
								
								<collection property="wifes" column="id" ofType="wife" select="com.mybatis.dao.WifeDao.findByHid"/>
							</resultMap>
							<select id="findAll" resultMap="husbandWifeMap">
								select * from husband
							</select>
							
						WifeDao：
							public List<Wife> findByHid();
							
						WifeMapper：
							<select id="findByHid" parameterType="int" resultType="wife">
								select * from wife where hid = #{hid}
							</select>
							
						Husband：
							public class Husband {
								private int id;
								private String name;
								
								private List<Wife> wifes;
							}
							
						Wife：
							public class Wife {
								private int id;
								private String name;
								private int hid;
								
								private Husband husband;
							}
							
						HusbandTest：
							//获取HusbandDao对象
							HusbandDao husbandDao = sqlSession.getMapper(HusbandDao.class);
							
							//查询所有老公
							List<Husband> husbands = husbandDao.findAll();
							for (Husband husband : husbands) {
								System.out.println(husband);
							}
							
							//释放资源
							sqlSession.close();
						
					
				
				
				b.在表与表之间的关系为多对多的时候，当我们查询其中一方的时候，顺带查询另外一方的时候，
				这种情况也称为一对多查询
			
					举例子：学生表和老师表
					
					方式一：
						StudentDao:
							public List<Student> findAll();
							
						StudentMapper：
							<resultMap type="student" id="studentTeacherMap">
								<id column="id" property="id"/>
								<result column="name" property="name"/>
								<collection property="teachers" column="id" ofType="teacher">
									<id column="tid" property="id"/>
									<result column="tname" property="name"/>
								</collection>
							</resultMap>
							<select id="findAll" resultMap="studentTeacherMap">
								select s.*, t.id tid, t.name tname from student s left join s_t st on s.id = st.sid
																 left join teacher t on st.tid = t.id
							</select>
							
						Student：
							public class Student {
								private int id;
								private String name;
								
								private List<Teacher> teachers;
							}
							
						Teacher：
							public class Teacher {
								private int id;
								private String name;
							}
							
						StudentTest：
							//获取StudentDao对象
							StudentDao studentDao = sqlSession.getMapper(StudentDao.class);
							
							//查询所有
							List<Student> students = studentDao.findAll();
							for (Student student : students) {
								System.out.println(student);
							}
							
							//释放资源
							sqlSession.close();
					
					方式二：
						StudentDao:
							public List<Student> findAll();
							
						StudentMapper：
							<resultMap type="student" id="studentTeacherMap">
								<id column="id" property="id"/>
								<result column="name" property="name"/>
								<collection property="teachers" column="id" ofType="teacher" select="com.mybatis.dao.TeacherDao.findBySid"/>
							</resultMap>
							<select id="findAll" resultMap="studentTeacherMap">
								select * from student
							</select>
							
						TeacherDao：
							public List<Teacher> findBySid(int sid);
							
						TeacherMapper：
							<select id="findBySid" resultType="teacher" parameterType="int">
								select * from teacher t, s_t st where t.id = st.tid and st.sid = #{sid}
							</select>
							
						Student：
							public class Student {
								private int id;
								private String name;
								
								private List<Teacher> teachers;
							}
							
						Teacher：
							public class Teacher {
								private int id;
								private String name;
							}
							
						StudentTest：
							//获取StudentDao对象
							StudentDao studentDao = sqlSession.getMapper(StudentDao.class);
							
							//查询所有
							List<Student> students = studentDao.findAll();
							for (Student student : students) {
								System.out.println(student);
							}
							
							//释放资源
							sqlSession.close();
			
	
	3.数据加载方式
		加载方式分类？
			1.立即加载
			2.延迟加载
			
		立即加载？
			在我们进行多表查询的时候，如果查询A表的时候，不管有没有用到B表中的数据，都会顺带着查询B表
			
			注意：Mybatis默认加载方式就是立即加载
		
		延迟加载？
			在我们进行多表查询的时候，如果查询A表的时候，如果没有使用B表中的数据，就只会查询A表不会查询B表
			
			注意：如果想要将默认的立即加载改成延迟加载，我们要进行配置
			
			如何配置延迟加载？
				<!-- 配置延迟加载 -->
				<settings>
					<setting name="lazyLoadingEnabled" value="true"/>
					<setting name="aggressiveLazyLoading" value="false"/>
				</settings>
		
	4.MyBatis的缓存
		缓存分类？
			1.一级缓存(SqlSession级别缓存)
			2.二级缓存(SqlSessionFactory级别缓存)
			
		缓存的作用？	
			减少程序和数据库之间的交互次数，从而提高了效率
		
		一级缓存？
			注意：MyBatis默认是开启了一级缓存
			
			验证一级缓存的存在？
				//根据id查询一条记录
				Teacher teacher1 = teacherDao.findById(1);
				System.out.println(teacher1);
				
				Teacher teacher2 = teacherDao.findById(1);
				System.out.println(teacher2);
				
			如何清空一级缓存？
				1.sqlSession.commit();
				2.sqlSession.close();
				3.增删改
				4. flushCache="true"
		
		二级缓存？
			注意：MyBatis默认是没有开启二级缓存的，想要开启，需要配置
			
			怎么配置二级缓存？
				1.在核心配置文件中配置：
					<setting name="cacheEnabled" value="true"/>
				2.在映射文件中配置：
					<cache/>
				3.在映射文件的标签中添加：
					useCache="true"
					
			验证二级缓存的存在？
				//获取SqlSession对象
				SqlSession sqlSession1 = sqlSessionFactory.openSession();
				
				//获取TeacherDao对象
				TeacherDao teacherDao1 = sqlSession1.getMapper(TeacherDao.class);
				
				//根据id查询一条记录
				Teacher teacher1 = teacherDao1.findById(1);
				System.out.println(teacher1);
				
				sqlSession1.close();
				
				//获取SqlSession对象
				SqlSession sqlSession2 = sqlSessionFactory.openSession();
				
				//获取TeacherDao对象
				TeacherDao teacherDao2 = sqlSession2.getMapper(TeacherDao.class);
				
				//根据id查询一条记录
				Teacher teacher2 = teacherDao2.findById(1);
				System.out.println(teacher2);
				
		思考三个问题？
			1.为什么类要实现序列化接口
				因为二级缓存存储的位置是本地磁盘，而不是内存中，一级缓存才会存储到内存中
			
			2.为什么加载二级缓存，两个对象地址值也是不一样的
				因为反序列化回来的数据是不变的，但是对象依然会重新创建
			
			3.为什么要写sqlSession1.close()
				这就涉及到了一级缓存和二级缓存之间的执行流程
				
				执行流程：
					1.当我们想要查询数据的时候，会先去二级缓存中查找有没有数据，有就拿过来直接用，如果没有
					就去一级缓存中查找
					
					2.如果去一级缓存中查找数据，有就拿过来直接用，如果没有就会去数据库查找数据
					
					3.如果去数据库中查找到了数据，会将数据存储到一级缓存中，不会存储到二级缓存中
					
					4.当执行了sqlSession1.close()，就会清空一级缓存，并且将一级缓存中的数据存储到了二级缓存中
				
		
		
		
		
			
			
			Web核心

1.服务器
	什么是服务器？
		我们平时所说的服务器，就是一个安装了服务器软件的计算机
		
	什么是服务器软件？
		它就一款软件，我们可以下载，可以安装，可以卸载，可以各种操作
		
		作用？
			1.它能够接收用户传递过来的请求参数，可以对这些数据进行各种操作，给用户响应数据
			2.它上面可以部署web项目，用户可以通过浏览器去访问web项目和项目中的各种资源
	
	常见的web服务器软件都有哪些？
		1.weblogic：WebLogic是美国Oracle公司出品的一个application server
					支持所有的JavaEE技术，所以也称为JavaEE容器
		2.websphere：WebSphere 是 IBM 的软件平台
					 支持所有的JavaEE技术，所以也称为JavaEE容器
		3.jboss：JBOSS公司出品的服务器
			      不支持JavaEE技术，不能称为容器
		*4.tomcat：
			Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，
			由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，
			最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 
			规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 
			爱好者的喜爱并得到了部分软件开发商的认可，成为比较流行的Web 应用服务器。
		
		5.apache：
			Apache(音译为阿帕奇)是世界使用排名第一的Web服务器软件。
			它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，
			是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，
			将Perl/Python等解释器编译到服务器中。
			
2.tomcat
	tomcat软件的使用？
		1.下载：https://tomcat.apache.org/
		2.安装：解压
		3.操作：
			a.开启tomcat服务器
				在tomcat软件的bin目录中，有一个startup.bat，双击即可
				通过浏览器访问路径：localhost:8080
				
				点击startup.bat出现闪退现象？
					1.环境变量的问题
						变量变量的配置：
							a. path="D:\develop\jdk1.8\jdk1.8.0_241\bin"
							b. JAVA_HOME="D:\develop\jdk1.8\jdk1.8.0_241"
							   path="%JAVA_HOME%\bin"
							   
						因为没有写JAVA_HOME的配置所以才闪退
						
					2.端口号被占用
						a.换端口号
						b.找到被占用的端口的软件，强制关闭
			
			b.关闭tomcat服务器
				1.正常关闭
					a.shutdown.bat
					b.Ctrl + C
				2.非正常关闭
					X
		4.卸载：删除

3.web项目
	web项目的分类？
		1.静态web项目
			什么是静态web项目？
				项目中的资源都是静态资源
					html,css,js,jpg,txt.......
					
			静态web项目的目录结构？
				app 
					--html
						--demo1.html 
					--css
						--style.css 
					--js 
						--aaa.js
				
		2.动态web项目
			什么是动态web项目？
				项目中的资源可以有静态的，也可以有动态的
					jsp/servlet
					
			动态的web项目的目录结构？
				app	
					--html
						--demo1.html 
					--css
						--style.css 
					--js 
						--aaa.js
					--WEB-INF
						--web.xml web项目的核心配置文件
						=-classes 里面装的都是编译完生成的.class文件
						--lib 里面装的都是第三方jar包
					
	web项目的部署？
		什么是部署？
			部署就是将web项目交给服务器来管理的意思
	
		方式一：
			1.将web项目放入到tomcat中的webapps中
			2.开启tomcat服务器
			3.打开浏览器，在地址栏上输入localhost:8080/项目的名字/资源的名字
		
		方式二：
			1.将web项目放到任意位置
			2.在tomcat中的conf中的server.xml核心配置文件中配置
				<Context docBase="" path=""/>
				
				Context标签：代表一个web项目
				docBase属性：web项目的真实路径
				path属性：web项目访问的虚拟路径
				
			3.开启tomcat服务器
			4.打开浏览器，在地址栏上输入localhost:8080/项目的虚拟路径名/资源的名字
		
		方式三：
			1.将web项目放到任意位置
			2.在tomat中conf中catalina中localhost中创建一个xml配置文件
				aaa.xml
			3.在配置文件中写：
				<Context docBase=""/>
			4.开启tomcat服务器
			5.打开浏览器，在地址栏上输入localhost:8080/配置文件名/资源的名字
			
			注意：
				1.当配置文件的名字或者项目的名字为ROOT的时候，在访问项目时候，是不需要写项目的名字或者虚拟路径名
				2.当资源文件的名字叫做inde.html的时候，在访问项目资源的时候，是不需要写资源的名字的
				3.当tomcat的端口号改成80的时候，访问路径上是不需要写端口80的
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			1.Servlet
	什么是Servlet？
		Servlet是可以执行在服务器端的小程序
		
		能够通过浏览器访问到的类就是Servlet
		
		注意：不是所有的类都是Servlet，普通类是无法被浏览器访问到的，只有servlet类才可以被浏览器访问
		
		什么类才能被称为Servlet类？
			看一个类是否实现了Servlet接口，如果实现了Servlet接口，该类就是Servlet类
			
	servlet的入门小案例？
		1.自定义一个类
		2.实现Servlet接口，重写所有的抽象方法
		3.在service()方法中写点内容
		4.在web.xml中对servlet进行配置
			<servlet>
				<servlet-name>aaa</servlet-name>
				<servlet-class>com.servlet.ServletDemo01</servlet-class>
			</servlet>
			<servlet-mapping>
				<servlet-name>aaa</servlet-name>
				<url-pattern>/yuema</url-pattern>
			</servlet-mapping>
		5.开启服务器
		6.打开浏览器，访问servlet类，访问地址：localhost:8080/day51/yuema
		
	servlet的生命周期方法？
		init()
		service()
		destroy() 
		
		当我们第一次访问servlet的时候，会执行init()和service()
		当我们第二次或者之后N多次访问servlet的时候，只会重复执行service()
		当我们正常的关闭服务器的时候，会执行destroy()
		
		如何让Servlet在服务器开启的时候就会创建出来呢？
			<servlet>
				<servlet-name>bbb</servlet-name>
				<servlet-class>com.servlet.ServletDemo02</servlet-class>
				<load-on-startup>1</load-on-startup>
			 </servlet>
			 <servlet-mapping>
				<servlet-name>bbb</servlet-name>
				<url-pattern>/servletDemo02</url-pattern>
			 </servlet-mapping>
			 
			 注意：<load-on-startup>中数字默认值为-1，表示第一次访问才会创建Servlet对象，如果是正数，就是当服务器
			 开启的时候就会创建servlet对象，正数的大小用来决定多个servlet对象的创建顺序的
		
	servlet获取参数的配置？
		<servlet>
			<servlet-name>servletDemo04</servlet-name>
			<servlet-class>com.servlet.ServletDemo04</servlet-class>
			<init-param>
				<param-name>name</param-name>
				<param-value>tom</param-value>
			</init-param>
			<load-on-startup>1</load-on-startup>
		</servlet>
		<servlet-mapping>
			<servlet-name>servletDemo04</servlet-name>
			<url-pattern>/servletDemo04</url-pattern>
		</servlet-mapping>
		
	servlet的注解配置？
		//@WebServlet(urlPatterns={"/servletDemo05"})
		//@WebServlet(urlPatterns="/servletDemo05")
		//@WebServlet(value="/servletDemo05")
		@WebServlet("/servletDemo05")
		
	servlet的体系结构？
		javax.servlet.Servlet 顶层接口
			-- javax.servlet.GenericServlet 通用的抽象类
				-- javax.servlet.http.HttpServlet 通用的针对http协议的类
				
				-- javax.servlet.ftp.FtpServlet
				-- javax.servlet.Ppp.PppServlet
				
		它们的体系结构使用了适配器设计模式
		
	Servlet实现方式有哪些？
		方式一：实现Servlet接口
			class ServletDemo implement Servlet {
			
			}
		
		方式二：继承GenericServlet抽象类
			class ServletDemo extends GenericServlet {
			
			}
		
		
		方式三：继承HttpServlet实现类
			class ServletDemo extends HttpServlet {
			
			}
			
			注意：要重写doGet()和doPost()
			
	Servlet的urlpattern的配置？
		1./XXX
			@WebServlet("/aaa")
			@WebServlet("/servletDemo08")
		
		2./XXX/OOO
			@WebServlet("/aaa/bbb")
			@WebServlet("/aaa/bbb/ccc")
			@WebServlet("/aaa/bbb/*")
			
		3.*.do
			@WebServlet("*.do")
			@WebServlet("*.xxx")
			
		注意：
			1./*.do 
				错误写法，/和*.do不能放在一起写
			2./*/aaa
				*不是通配符
			3./
		
		
		1.http协议
	什么是http协议？
		超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。
		它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。
		请求和响应消息的头以ASCII形式给出；
		而消息内容则具有一个类似MIME的格式。
		
		超文本：超级文本
		传输协议：规定客户端和服务器端进行数据交互的传输数据的格式
	
	http协议的特点？
		1.http协议是建立在tcp协议基础之上的高级协议
		2.http协议默认端口号80
		3.http是一个基于请求和响应模式的协议，也就是说一次请求对应一次响应
		4.http协议是一个无状态的协议，多次请求和响应之间不会有任何影响
		
	http协议的版本？
		http/1.0：每一次请求和响应都要建立连接
		http/1.1：在一次连接中，可以进行多次请求和响应
		
	http协议的请求消息格式？
		1.请求行
			格式：请求方式 请求URI 协议/版本号
			
			a.请求方式
				请求方式一共7种
				但是我们只说2种
				
				get请求：
					1.请求参数能够在地址栏上展示出来，请求参数是在请求行中，没在请求体中
					2.相对不安全
					3.请求参数大小有限
				
				post请求：
					1.请求参数不在地址栏上展示，请求参数是在请求体中，没在请求行中
					2.相对安全
					3.请求参数没有限制
			
			b.请求URI
				URI：统一资源标识符
				
					格式：项目的虚拟目录 + 资源文件的虚拟目录
						/day52			  /servletDemo01
						/day52			  /demo01.html
								
					共和国
						
				URL：统一资源定位符
					
					格式：协议 + IP + 端口 + URI
						  http://localhost:8080/day52/servletDemo01
						  
					中华人民共和国
						  
				URI和URL哪个更加精确呢？
					URI范围更大
					URL更加精确
			
			c.协议/版本号 
				http/1.0：每一次请求和响应都要建立连接
				http/1.1：在一次连接中，可以进行多次请求和响应
		
		2.请求头
			什么是消息头？
				消息头分为请求消息头和响应消息头
				消息头其实就是浏览器和服务器之间说的悄悄话
			
			什么是请求头？
				浏览器对服务器说的悄悄话
			
			请求头的格式？
				请求头名字：请求头值,请求头值...
				
			常见的请求头有哪些？
				Accept：浏览器可接受的MIME类型，浏览器告诉服务器它所有接收的MIME类都有哪些
					什么MIME类型？
						MIME类型类似于我们Java中的数据类型
						服务器和浏览器之前传输数据(各种超文本数据)的数据类型
						
					MIME类型格式：大的类型/小的类型
								  image/jpg
								  image/png
								  image/gif
								  text/txt
								  text/html
								  
				Cookie：这是最重要的请求头信息之一			  
				Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。
						就是指当前页面是从哪个页面跳转过来的
					作用？
						1.做统计
						2.防盗链
				User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。
		
		3.请求空行
			就是单纯的空行，为了区分请求头和请求体的
		
		4.请求体(请求正文)
			get请求方式：
				虽然请求参数没有在请求体中，所以请求体中没有内容，
				但是呢，请求体也算是存在的，但是也可以说没有请求体
				
			post请求方式：
				有请求体的，里面放着请求参数
				
				格式：名字=值&名字=值&名字=值...
		
2.request
	什么是request？
		request对象就是请求对象，是由tomcat服务器内部创建好的，我们可以直接使用即可
		
	request的体系结构？
		javax.servlet.ServletRequest 接口
			--javax.servlet.http.HttpServletRequest 接口
				--org.apache.catalina.connector.RequestFacade@20b628cf
	
	request对象的常用方法？
		1.获取请求消息数据
			a.获取请求行
				String getMethod() 获取请求方式
				String getContextPath() 获取项目的虚拟路径
				String getServletPath() 获取servlet的虚拟路径
				String getRequestURI() 获取uri
				StringBuffer getRequestURL() 获取url
				String getQueryString() 获取请求行中的请求参数的（如果有中文，会被编码，所以一般需要再次解码，一般通过URLDecoder.decode("string")来解码）
				String getRemoteAddr() 获取IP
				String getProtocol() 获取协议和版本号
			
			b.获取请求头
				String getHeader(String name) 根据请求头名获取请求头值
				Enumeration<String> getHeaderNames() 获取所有的请求消息头名
					Enumeration：
						boolean hasMoreElements();
						E nextElement();
				Enumeration<String> getHeaders(String name)：根据请求头名得到请求头值(一个头对应多个值)
					key:value1
					key:value2
					key:value3
				int getIntHeader(String name)：根据请求头名获取请求头值，头值只能是数字
			
			c.获取请求体
				ServletInputStream getInputStream()
				BufferedReader getReader()

				注意：只有post请求才有请求体
		
		2.其他的重要的功能
			a.获取请求参数通用方法
				String getParameter(String name) 根据表单项的name属性值获取value属性值
				Enumeration<String> getParameterNames() 获取所有的请求参数的名字
				String[] getParameterValues(String name) 根据表单项的name属性值获取value属性值(针对多选框)
				Map<String,String[]> getParameterMap() 获取所有的请求参数的名字和值
				
				获取请求参数中文乱码的问题？
					get请求方式：
						tomcat8之前：中文会乱码
						tomcat8之后：中文不会乱码
					
					post请求方式：
						中文会乱码
						
					怎么产生中文乱码的？
						两边编码不一致
						
						tomcat服务器的默认编码是ISO-8859-1
						
					怎么解决中文乱码？
						request.setCharacterEncoding("utf-8");
						
				BeanUtils工具类的使用？
					1.导入jar包
						3个jar包
					2.调用方法
						BeanUtils.populate(user, map);
						
						第一个参数：要封装的对象
						第二个参数：map集合，里面装了所有的请求参数数据
								    request.getParameterMap()
					
				
		
1.request
	request对象的常用方法？
		1.获取请求消息数据
			a.获取请求行
			b.获取请求头
			c.获取请求体
		2.其他的重要的功能
			a.获取请求参数通用方法
			b.转发相关方法
				Request：
					public RequestDispatcher getRequestDispatcher(String path)
					
				RequestDispatcher：
					public void forward(ServletRequest request,ServletResponse response)
					
				请求转发的作用？
					可以实现从一个servlet跳转到另外一个资源
					
				转发的特点？
					1.只能实现内部跳转
					2.只能有一次请求和一次响应
					3.地址不会发生改变
				例子？
					1.防盗链
					2.登录
			c.数据共享
				web核心中有4大域对象
				
				域对象：不是一般的对象，每一个域对象都有自己所管辖的范围，一个区域，
						凡是域对象，都具备3个方法：setAttribute(String key, Object value)
												   getAttribute(String key)
												   removeAttribute(String key)
				
				
				request就是4大域对象之一，它所管辖的范围是一次请求和一次响应之间的范围
				
2.路径
	路径的分类？
		1.绝对路径
		2.相对路径
		
	绝对路径？
		以前：
			以盘符开始的路径
			C:\users\aaa\aaa.txt
			
		现在：
			1.以http:开始的路径
				协议 + ip + 端口 + 项目的虚拟路径 + 资源的虚拟路径
				http://localhost:8080/day53/servletDemo01
				
				在程序中需要写路径的地方有哪些？
					<link rel="stylesheet" href="http://localhost:8080/day53/css/style.css">
					<script src="http://localhost:8080/day53/js/aaa.js"></script>
					<img src="http://localhost:8080/day53/img/1.jpg">
					<a href="http://localhost:8080/day53/demo01.html"></a>
					<form action="http://localhost:8080/day53/servletDemo01"></form>
					
			2.以/开始的路径
				/项目的虚拟路径 + 资源的虚拟路径
				/day53/servletDemo01
	
				在程序中需要写路径的地方有哪些？
					<link rel="stylesheet" href="/day53/css/style.css">
					<script src="/day53/js/aaa.js"></script>
					<img src="/day53/img/1.jpg">
					<a href="/day53/demo01.html"></a>
					<form action="/day53/servletDemo01"></form>

	相对路径？
		以前，现在：
			./：相对于当前目录
				注意：./可以省略不写
				
			../：相对于上一级目录

			在程序中需要写路径的地方有哪些？
				<link rel="stylesheet" href="./css/style.css">
				<script src="./js/aaa.js"></script>
				<img src="./img/1.jpg">
				<a href="./demo02.html"></a>
				<form action="./servletDemo01"></form>
				
				访问demo04.html：
					http://localhost:8080/day53/demo04.html
				
				访问style.css：
					http://localhost:8080/day53/css/style.css
				
				访问1.jpg:
					http://localhost:8080/day53/img/1.jpg
					
				访问demo02.html
					http://localhost:8080/day53/demo02.html
					
				访问aaa.js：
					http://localhost:8080/day53/js/aaa.js
				
				访问servlet：
					http://localhost:8080/day53/servletDemo01
				
3.http协议
	响应消息格式？
		1.响应行
			格式：协议/版本号状态码
			
			状态码：这次请求和响应的具体的情况
			
				1.消息
					1XX
					
					这一类型的状态码，代表请求已被接受，需要继续处理。
					这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。
					由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，
					服务器禁止向此类客户端发送 1xx 响应。
					
				2.成功
					2XX
					
					这一类型的状态码，代表请求已成功被服务器接收、理解、并接受
					
					200
					
				3.重定向
					3XX
					
					这类状态码代表需要客户端采取进一步的操作才能完成请求。
					通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明
					
					302：重定向
					
					304：表示缓存
						当我们第一次访问某个资源的时候，响应回赖状态码为200
						当我们第二次访问某个资源的时候，响应回来的状态为304
						当我们清空缓存之后，再次访问该资源的时候，响应回来的状态码为200
						当我们访问的资源的内容发生改变的时候，响应回来的状态码为200
					
				4.请求错误
					4XX
					
					这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理
					
					404：请求失败，请求所希望得到的资源未被在服务器上发现
						大部分就是url写错了
					
					405：doGet()和doPost()没有重写
				
				5.服务器错误
					5XX
					
					这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生
					
					500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。
						一般来说，这个问题都会在服务器端的源代码出现错误时出现。
			
		2.响应头
			什么是响应消息头？
				是服务器对浏览器说的悄悄话
				
			格式：key:value
			
			常见的响应头？
				Content-Type：服务器告诉浏览器，我这边响应回去的数据的MIME类型是什么
					MIME类型：文件的数据类型
						格式：大类型/小类型
		
				Location：服务器告诉浏览器，你接下来应该去哪里，一般是在重定向的时候使用该响应头
		
		3.响应空行
			为了区分响应头和响应体
		
		4.响应体(响应正文)
			我们通过浏览器访问服务器中的资源，就会响应回来一些数据，这些数据就会存在于响应体中，响应到浏览器
			之后会被浏览器解析，进行展示
		
4.response
	什么是response对象？
		响应对象，是由服务器创建好传递到doGet()或者doPost()中的，我们可以拿过来直接使用

	常用的方法？
		1.设置响应状态码
			public void setStatus(int sc) 设置状态码
		
		2.设置响应头
			void setHeader(String name,String value) 设置响应头
			
			重定向？			
				想要实现重定向，要满足两个条件
					1.响应状态码为302
					2.要有响应头location
					
				实现方式？
					方式一：
						//设置状态码为302
						response.setStatus(302);
						
						//设置响应头location
						response.setHeader("location", "/day53/servletDemo09");
					
					方式二：
						void sendRedirect(String location)

						response.sendRedirect("/day53/servletDemo09");
						
				面试题？
					forward(转发)和redirect(重定向)的区别？
						1.重定向地址栏会变，转发地址栏不会变
						2.重定向有两次请求和响应，转发只有一次请求和响应
						3.请求转发只能是内部跳转，重定向可以实现外部跳转
						4.请求转发路径会自动添加项目的虚拟路径，重定向不会
						
		3.设置响应体
			PrintWriter getWriter()
			ServletOutputStream getOutputStream()

			注意：如果响应体中的数据有中文，会出现中文乱码
			
			怎么解决中文乱码？
				原始方式：
					//设置响应输出流编码为utf-8
					response.setCharacterEncoding("utf-8");
					//设置响应头，服务器告诉浏览器响应回来的数据的MIME类型和你要用什么编码方式解析
					response.setHeader("content-type", "text/html;charset=utf-8");
					
				优化：
					//设置响应头，服务器告诉浏览器响应回来的数据的MIME类型和你要用什么编码方式解析
					response.setHeader("content-type", "text/html;charset=utf-8");
					
				最终写法：
					//设置响应头，服务器告诉浏览器响应回来的数据的MIME类型和你要用什么编码方式解析
					response.setContentType("text/html;charset=utf-8");
				
5.ServletContext
	什么是ServletContext？
		它代表当前的项目，tomcat部署一个项目，并且开启服务器，就会产生一个ServletContext对象

	ServletContext的生命周期？
		什么时候创建的？
			开启tomcat服务器的时候，ServletContext对象就会被创建
			
		什么时候销毁的？
			关闭tomcat服务器的时候，ServletContext对象就销毁
			
	ServletContext对象的获取？
		方式一：
			ServletContext servletContext = request.getServletContext();
			
		方式二：
			ServletContext servletContext2 = this.getServletContext();
			
		注意：ServletContext对象是单例的，一个项目中有且只能有一个ServletContext对象
		
	常见的方法？
		1.获取资源文件MIME类型
			String getMimeType(String file)
		
		2.数据共享
			ServletContext对象是一个域对象，它所管辖的范围是整个项目的范围，当服务器开启，ServletContext对象被
			创建，当服务器关闭，ServletContext对象销毁，在这个期间都是属于ServletContext域对象范围
			
			setAttribute(String key, Object value)
			getAttribute(String key)
			removeAttribute(String key)
		
		3.获取资源的真实路径
		4.获取web.xml核心配置文件中的全局参数















1.ServletContext
	常见的方法？
		1.获取资源文件MIME类型
		2.数据共享
		3.获取资源的真实路径
			String getRealPath(String path)
			
			加载配置文件？
				1.类加载器方式
					加载的是classpath路径下的资源非常的方便
				2.ServletContext方式
					加载的是项目路径下的资源非常的方便
				
				推荐使用方式1
		
		4.获取web.xml核心配置文件中的全局参数
			String getInitParameter(String name)
			
			<!-- 配置全局参数 -->
			<context-param>
				<param-name>name</param-name>
				<param-value>tom</param-value>
			</context-param>
			
2.jsp
	什么jsp？
		JSP（全称JavaServer Pages）是由Sun Microsystems公司主导创建的一种动态网页技术标准。
		JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成HTML、
		XML或其他格式文档的Web网页，然后返回给请求者
		
		jsp的一个动态资源
		jsp是一个可以写java代码的html，jsp = java + html
	
	jsp的本质？
		jsp其实就是一个servlet
		
		注意：想要把jsp学好，只需要能够看懂jsp所翻译成的servlet即可
	
	jsp的脚本？
		1.<%内容%>
			这里面写的内容都是存在于servlet中的service()中的
		
		2.<%!内容%>
			这里面写的内容都是存在于servlet中的成员位置的
		
		3.<%=内容%>
			这里面写的内容可以写出到浏览器上面
			
	jsp的指令？
		格式：<%@指令名称 属性名=属性值 属性名=属性值 ...%>
		
		三大指令：
			1.page
				针对jsp页面进行属性参数的设置
				
				contentType属性：和servlet中content-type功能是一样的
				pageEncoding属性：jsp翻译成servlet使用的编码
				import属性：导包
				isErrorPage属性：如果设置为true，则在servlet里面可以使用exception对象
				errorPage属性：如果jsp页面有错误就会转发到errorPage属性所指定的页面
				isELIgnored属性：设置是否可以在该jsp页面是否el表达式
				
			2.include
				包含其他页面的
			
				静态包含：<%@include file=""%>
				
				动态包含：<jsp:include page="demo04.jsp"/>
				
				推荐使用静态包含，因为不占内存
			
			3.taglib
				使用jstl标签库的是才需要这个指令
				
				<%@ taglib prefix="" uri="" %>
				
	jsp的注释？
		1. <!--内容-->
		
		2. <%--内容--%>
		
		推荐使用第二个，因为省内存
		
	jsp的九大内置对象？
		内置对象：不是我们自己创建的，是jsp底层自己创建，我们可以直接使用
		
		内置对象名称				对象的真实数据类型					对象的作用			
		request						HttpServletRequest			四大域对象，数据共享，获取请求消息数据
		pageContext				       PageContext				四大域对象，数据共享，jsp页面的范围
		session						   HttpSession				四大域对象，数据共享，后面重点学习
		application					  ServletContext			四大域对象，数据共享
		response					HttpServletResponse			响应对象，设置响应行，响应头，响应体
		config						  ServletConfig				配置参数
		out								JspWriter				和PrintWriter，向页面写内容
		page							  Object				jsp翻译成servlet的那个对象
		exception						 Throwable				异常对象，写异常信息
		
3.EL表达式
	什么是el表达式？
		EL（Expression Language） 是为了使JSP写起来更加简单。
		表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 
		中简化表达式的方法，让Jsp的代码更加简化。
	
	el表达式的格式？
		${表达式}
		
	常见的表达式？
		1.运算符
			a.算术运算符
				+,-,*,/,%...
				
				${1 + 2}<br>
				${1 * 2}<br>
				${1 / 2}<br>
				${1 % 2}<br>
			
			b.比较运算符
				>, <, ==, >=, <=
				
				${1 > 2 }<br>
				${1 < 2 }<br>
				${2 == 2 }<br>
			
			c.逻辑运算符
				&&(and),||(or),!(not)
				
				${true && true }<br>
				${true and false }<br>
				${false || true }<br>
				${false or false }<br>
				${!false}<br>
				${not false}<br>
			
			d.空运算符
				empty：判断字符串，数组和集合是否为null或者空的
				not empty：判断字符串，数组和集合是否不为空
				
				<%
					String str = "abc";
				
					request.setAttribute("str", str);
					
					ArrayList al = new ArrayList();
					
					request.setAttribute("al", al);
				%>
				
				${empty str }<br>
				${empty al }<br>
				${not empty al }
		
		2.获取值
			注意：el表达式可以从域中获取数据
			
			4大域对象：
				pageContext -> pageScope
				request		-> requestScope
				session		-> requestScope
				application	-> applicationScope
				
				pageScope,requestScope,requestScope,applicationScope是EL表达式的内置对象，可以在el表达式中直接使用
				
			a.${域名称.键名}
				<%
					/* String str = "约吗";
					request.setAttribute("str", str); */
					
					request.setAttribute("str", "约吗");
					pageContext.setAttribute("str", "在吗");
					application.setAttribute("str", "滚犊子");
					session.setAttribute("str", "好啊");
					
					ArrayList<String> al = new ArrayList<>();
					
					al.add("tom");
					al.add("jerry");
					
					session.setAttribute("list", al);
				%>

				${requestScope.str }<br>
				${pageScope.str }<br>
				${applicationScope.str }<br>
				${sessionScope.str }<br>
				${sessionScope.list }
			
			b.${键名}
				注意：按照域的大小顺序，从域中获取数据的
				
				pageContext < request < session < application
				
				<%
					//request.setAttribute("name","jerry");
					//session.setAttribute("name","rose");
					//application.setAttribute("name","jack");
					pageContext.setAttribute("name","tom");
				%>
				
				${name }
		
		3.获取对象中的数据
			a.获取普通对象中的数据
				格式：${键名.属性名}
				
				<%
					User user = new User("tom", 18);
				
					request.setAttribute("user", user);
				%>
				
				${user.name }<br>
				${user.age }<br>
				${user.instance}
				
			b.获取集合容器中的数据
				1.单列集合
					格式：${键名[索引]}
					
					<%
						ArrayList<String> al = new ArrayList<>();
						al.add("aaa");
						al.add("bbb");
						al.add("ccc");
						
						request.setAttribute("list", al);
					%>
					
					${list[0] }<br>
					${list[1] }<br>
					${list[2] }<br>
				
				2.双列集合
					格式：
						1.${键名.键名}
						2.${键名['键名']}
					
					<%
						HashMap<String, String> hm = new HashMap<>();
					
						hm.put("name", "tom");
						hm.put("age", "18");
						
						request.setAttribute("map", hm);
					%>
					
					${map.name }<br>
					${map.age }<br>
					${map['name'] }<br>
					${map['age'] }<br>
		
4.JSTL标签库
	什么是jstl？
		JSTL（Java server pages standarded tag library，即JSP标准标签库）是由
		JCP（Java community Proces）所制定的标准规范，它主要提供给Java Web开发人员一个标准通用的标签库，并由Apache的Jakarta小组来维护。
		开发人员可以利用这些标签取代JSP页面上的Java代码，从而提高程序的可读性，降低程序的维护难度。
		
	jstl标签库的使用？
		1.导入jar包
			2个jar包
		2.引入taglib指令
			<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
		3.写标签
			
	jstl常见的标签？
		1.c:if
			<c:if test="true">
				约
			</c:if>
			<c:if test="false">
				不约
			</c:if>
			
			-------------------
			<%
				int i = 2;
			
				request.setAttribute("i", i);
			%>
			
			<c:if test="${i == 1}">
				约
			</c:if>
			<c:if test="${i != 1}">
				不约
			</c:if>
		
		2.c:foreach
			<c:forEach begin="" end="" items="" step="" var="" varStatus=""></c:forEach>
			
			begin：从几开始
			end：到几结束
			item：容器的名字
			step：步长
			var：遍历出来的元素的名字
			varStatus：
				index：索引
				count：第几个
				
			案例一：在页面显示1-10的数字
				<c:forEach begin="1" end="10" step="1" var="i">
					${i }<br>
				</c:forEach>
				
			案例二：遍历数组容器
				<%
					int[] arr = {12,13,14};
				
					request.setAttribute("arr", arr);
				%>
				
				<c:forEach items="${arr }" var="i" varStatus="s">
					${i }...${s.index }...${s.count }<br>
				</c:forEach>
				
			案例三：遍历集合
				a.单列集合
					<%
						ArrayList<String> al = new ArrayList<>();
					
						al.add("aaa");
						al.add("bbb");
						al.add("ccc");
						
						request.setAttribute("list",al);
					%>
					
					<c:forEach items="${list }" var="str">
						${str }<br>
					</c:forEach>
				
				b.双列集合
					<%
						HashMap<String, String> hm = new HashMap<>();
						
	O					hm.put("name", "tom");
						hm.put("age", "18");
						
						request.setAttribute("map", hm);
					%>
					
					<c:forEach items="${map }" var="entry">
						${entry.key }...${entry.value }<br>
					</c:forEach>

5.MVC
	设计思想
	
	M：Model 存储数据
		JavaBean
	V: View 视图展示
		Jsp
	C: Controller 控制
		Servlet
	
	软件设计架构？
		1.jsp + bean
			这种设计，后期维护性，阅读性特别差
		
		2.jsp + servlet + bean

6.三层架构
	设计思想
	
	哪三层？
		web：表示层
		service：业务逻辑层
		dao：数据访问层
		
作业？
	使用三层架构实现查询所有数据的功能
		

		
			
			
		
		1.会话技术
	什么是会话？
		一次会话，就是一次聊天，在这次聊天中可能只说了一句话，也可能说了很多句话
		
	会话技术有哪些？
		cookie：客户端的会话技术
		session：服务器端的会话技术
		
	会话的作用？
		可以实现数据的共享
		
	Cookie会话技术？
		客户端的会话技术
		
		cookie的入门小案例？
			ServletDemo01：
				方式一：
					//创建Cookie
					Cookie cookie = new Cookie("name","tom");
					//添加Cookie
					response.addCookie(cookie);
				
				方式二：
					response.setHeader("set-cookie", "name=jerry");
				
			ServletDemo02：
				//获取Cookie
				Cookie[] cookies = request.getCookies();

				for (Cookie cookie : cookies) {
					System.out.println(cookie.getName() + "..." + cookie.getValue());
				}
				
		思考4个小问题？
			1.cookie可不可以写多个
				是可以写多个cookie
				
				如果cookie的name值相同会怎么样？
					会被覆盖
			
			2.cookie的value值可不可以为中文
				方式一：不会出现中文乱码问题
				
				方式二：会出现中文乱码
					怎么解决？
						自己设置url编码和url解码
				
			3.cookie的生命周期
				cookie什么时候销毁的？
					默认当浏览器被关闭cookie销毁
					
					可不可以延长cookie销毁时间？
						可以设置cookie.setMaxAge(60);来延长cookie的生存时长
						
						当我们设置了这个方法的时候，cookie就不会存在于浏览器的内存中了，而是存储在了本地磁盘
						
						setMaxAge默认值为负数，也就是说当浏览器关闭，cookie就被销毁
						如果setMaxAge的值为0的话，cookie写到浏览器马上销毁
			
			4.cookie的携带范围
				默认访问当前项目下的所有资源都会携带cookie请求头的
				
				设置携带范围？
					//cookie.setPath("/day55");//默认值，当前项目下的资源都会携带
					//cookie.setPath("/day55/servletDemo02");//只有访问servletDemo02这个资源才会携带cookie
					cookie.setPath("/");//访问当前服务器所部署的所有的项目中的所有资源，都会携带cookie
	
	Session会话技术？
		服务器端会话技术
		
		session是一个域对象，范围是一次会话的范围
		
		session的入门小案例？
			ServletDemo08：
				//获取session对象
				HttpSession session = request.getSession();
				
				//向域中存数据
				session.setAttribute("name", "tom");
				
			ServletDemo09：
				//获取session对象
				HttpSession session = request.getSession();
				
				//从域中获取数据
				Object value = session.getAttribute("name");
				System.out.println(value);
				
		思考3个小问题？
			1.如果浏览器关闭，服务器没有关闭，会怎么样？
				浏览器关闭意味着浏览器端存储的JSESSIONID就消失了，服务器没有关闭，服务器端的session是存在的，
				当我们重新打开一个浏览器去访问服务器，数据是获取不到的
				
				如果期望浏览器关闭，下次打开还可以获取服务器端的数据？
					//设置cookie
					Cookie cookie = new Cookie("JSESSIONID", session.getId());
					//设置cookie生存时长
					cookie.setMaxAge(120);
					//添加cookie
					response.addCookie(cookie);
				
			2.如果浏览器不关闭，服务器关闭，会怎么样？
				非正常关闭服务器？
					session会销毁，当服务器重新开启之后，就会浏览器还存着JSESSIONID，但是数据依然获取不到
				
				正常关闭服务器？
					session会钝化，当服务器重新开启之后，session会活化(激活)，浏览器还存着JSESSIONID，服务器有
					匹配的session，所以数据可以获取到
					
					钝化：session从内存中存储到了本地磁盘中
					活化：session从本地磁盘还原到内存中
			
			3.session什么时候销毁？
				a.服务器关闭
				b.session自杀
					session.invalidate();
				c.在web.xml中配置session的生存时长
					<session-config>
						<session-timeout>30</session-timeout>
					</session-config>
	
2.Filter
	什么是filter？
		过滤器，web三大组件之一
		
	过滤器的作用？
		1.将资源的共性抽取到过滤器中，减少代码的属性，提高了复用性
			request.setCharacterEncoding("utf-8");
		2.实现登录校验
		3.过滤敏感词汇
		
	过滤器的入门小案例？
		1.创建一个类
		2.实现Filter接口，重写方法
		3.进行配置
			<!-- 配置过滤器 -->
			<filter>
				<filter-name>aaa</filter-name>
				<filter-class>com.filter.FilterDemo01</filter-class>
			</filter>
			<filter-mapping>
				<filter-name>aaa</filter-name>
				<url-pattern>/servletDemo12</url-pattern>
			</filter-mapping>
		4.打开浏览器测试
		
	过滤器的生命周期方法？
		init()：当服务器开启，该方法执行
		doFilter()
		destroy()：当服务器关闭，该方法执行
		
	过滤器的注解配置？
		@WebFilter("/servletDemo12")
		
	过滤器的urlpattern配置？
		1./XXX
			/servletDemo
		2./XXX/*
			/user/*
			/goods/*
		3.*.XXX
			*.jsp
		4./*
			访问任何资源都会过滤
			
	过滤器链？
		什么是过滤器链？
			有多个过滤器
			
		过滤器链的执行顺序？
			配置文件方式：根据配置的先后顺序
			注解方式：根据过滤器的名字的字符串的字段顺序
	1.Listener
	什么是Listener？
		监听器，web三大组件之一
		
	监听器的入门小案例？
		1.创建一个类
		2.实现监听器接口，重写方法
		3.进行配置
		
	常见监听器？
		1.ServletContextListener
			监听ServletContext对象的创建和销毁的
			
			public class MyServletContextListener implements ServletContextListener {
				@Override
				public void contextInitialized(ServletContextEvent sce) {
					System.out.println("servletContext创建啦...");
					
					ServletContext servletContext = sce.getServletContext();
					String value = servletContext.getInitParameter("name");
					System.out.println(value);
				}

				@Override
				public void contextDestroyed(ServletContextEvent sce) {
					System.out.println("servletContext对象销毁啦...");
				}
			}
			
		2.ServletRequestListener
			监听request对象的创建和销毁的
			
			public class MyServletRequestListener implements ServletRequestListener {
				@Override
				public void requestDestroyed(ServletRequestEvent sre) {
					System.out.println("request对象被销毁...");
					
					ServletRequest request = sre.getServletRequest();
				}

				@Override
				public void requestInitialized(ServletRequestEvent sre) {
					System.out.println("request对象被创建...");
				}

			}
		
		3.HttpSessionListener
			监听session对象的创建和销毁的
			
			public class MyHttpSessionListener implements HttpSessionListener {
				@Override
				public void sessionCreated(HttpSessionEvent se) {
					System.out.println("session被创建...");
					
				}

				@Override
				public void sessionDestroyed(HttpSessionEvent se) {
					System.out.println("session被销毁...");
				}
			}
			
	监听器的注解配置？
		@WebListener
		
2.Jquery
	什么是jquery？
		jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（框架）
		于2006年1月由John Resig发布。
		jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。
		它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式
		，优化HTML文档操作、事件处理、动画设计和Ajax交互。
	
	jquery入门小案例？
		1.导入js文件
		2.写jquery代码
		3.进行测试
		
	jquery和js对象的相互转换？
		1.js对象 -> jquery对象
			格式：$(js对象)
		
			window.onload = function() {
				//获取js对象
				var div = document.getElementById("div");
				alert(div.innerHTML);
				
				//转化成jquery对象
				var $div = $(div);
				alert($div.html());
			}
		
		2.jquery对象 -> js对象
			格式：
				jquery对象.get(索引)
				jquery对象[索引]
		
			window.onload = function() {
				//获取jquery对象,$(选择器)
				var $div = $("div");
				alert($div.html());
				
				//转化成js对象
				//var div = $div.get(0);
				var div = $div[0];
				alert(div.innerHTML);
			}
	
	jquery中的入口函数？
		js的入口函数：
			window.onload = function() {
				alert("约吗");
			}
			
			注意：如果写了多个入口函数，下面的会把上面的覆盖掉
		
		jquery的入口函数：
			$(function() {
				alert("约吗");
			})
			
			注意：如果写了多个入口函数，都会执行
	
	jquery的样式设置？
		$(function() {
			var $div = $("#aaa");
			$div.css("border", "1px solid yellow");
			$div.css("color", "green");
			$div.css("font-size", "100px");
		})
	
	jquery的事件绑定？
		$(function() {
			var bt = $("#bt");
			bt.click(function() {
				alert("你好贱");
			})
		})
		
	jquery的选择器？
		id选择器：
			$(function() {
				var div = $("#bbb");
				div.css("color","red");
			})
		
		元素选择器：
			$(function() {
				var div = $("span");
				div.css("color","red");
			})
		
		类选择器：
			$(function() {
				var div = $(".aaa");
				div.css("color","red");
			})
			
		通配符选择器：
			$(function() {
				$("*").css("backgroundColor","red");
			})
		
		组合选择器：
			$(function() {
				$("#aaa, .bbb, input").css("color","red");
			})
			
		包含选择器：
			$(function() {
				$("b p").css("color", "red");
			})
		
		子元素选择器：
			$(function() {
				$("b > p").css("color", "red");
			})
	
		基本过滤选择器：
			:first 找第一个
			:last 找最后一个
			:even 索引值为偶数的元素，从 0 开始计数
			:odd 索引值为奇数的元素，从 0 开始计数

		属性选择器：
			$(function() {
				$("div[class]").css("color","red");
			})
			
			$(function() {
				$("div[class='bbb']").css("color","red");
			})
			
		表单选择器：
			:checked 有选中的被选中元素(复选框、单选框等，不包括select中的option)
				$(function() {
					var inputs = $("input:checked");
					//把jquery对象当成元素为js对象的数组
					alert(inputs.length);
					/* alert(inputs[0]);
					alert(inputs[1]); */
					alert(inputs.get(0));
					alert(inputs.get(1));
					
				})
			:selected 所有选中的option元素
				$(function() {
					var options = $("option:selected");
					alert(options.length);
				})
			
	jquery对dom的操作？
		1.文本操作
			html() 获取文本
			html(val) 设置文本
			注意：识别纯文本和标签
			
			text() 获取文本
			text(val) 设置文本
			注意：识别纯文本
			
			val() 获取value值
			val(val) 设置value值
	
		2.属性操作
			通用：
				attr(name) 添加元素
				removeAttr(name) 删除元素
				
				prop(name) 添加元素
				removeProp(name) 删除元素
				
				注意：prop只能操作固有属性(该标签本身就具备的属性)
				
			class属性：
				addClass(name)
				removeClass(name)
				
		3.节点操作
			对象A.append(对象B) 将对象B添加到对象A的里面的后面
			对象A.appendTo(对象B) 将对象A添加到对象B的里面的后面
			对象A.prepend(对象B) 将对象B添加到对象A的里面的前面
			对象A.prependTo(对象B) 将对象A添加到对象B的里面的前面
			对象A.after(对象B) 将对象B添加到对象A的外面的后面
			对象A.insertAfter(对象B) 将对象A添加到对象B的外面的后面
			对象A.before(对象B) 将对象B添加到对象A的外面的前面
			对象A.insertBefore(对象B) 将对象A添加到对象B的外面的前面
	
	jquery的遍历？
		方式一：
			$(function() {
				var divs = $("div");
				for(var i = 0; i < divs.length; i++) {
					alert(divs[i].innerHTML);
					//alert($(divs[i]).html());
				}
			})
			
		方式二：
			$(function() {
				var divs = $("div");
				$.each(divs, function() {//this是遍历出来js对象
					//alert(this.innerHTML);
					alert($(this).html());
				})
			})
			
			--------------------------
			
			$(function() {
				var divs = $("div");
				$.each(divs, function(index) {//index是索引
					alert(index + "..." + this.innerHTML);
				})
			})
			
			--------------------------
			
			$(function() {
				var divs = $("div");
				$.each(divs, function(index, obj) {//index是索引，obj是遍历出来js对象，this是遍历出来js对象
					alert(index + "..." + this.innerHTML + "..." + obj.innerHTML);
				})
			})
		
		方式三：
			$(function() {
				var divs = $("div");
				divs.each(function() {
					//alert(this.innerHTML);
					alert($(this).html());
				})
			})
			
			--------------------------
			
			$(function() {
				var divs = $("div");
				divs.each(function(index) {
					alert(index + "..." + this.innerHTML);
				})
			})
			
			--------------------------
			
			$(function() {
				var divs = $("div");
				divs.each(function(index, obj) {
					alert(index + "..." + this.innerHTML + "..." + obj.innerHTML);
				})
			})
		
		方式四：
			$(function() {
				var divs = $("div");
				for(var i of divs) {
					alert(i.innerHTML);
				}
			})
			
			注意：只支持高版本(3版本以上)
	
3.ajax
	什么是ajax？
		Ajax即Asynchronous Javascript And XML（异步JavaScript和XML）在 2005年被Jesse James 
		Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: HTML 或 XHTML, CSS, JavaScript, 
		DOM, XML, XSLT, 以及最重要的XMLHttpRequest。
		使用Ajax技术网页应用能够快速地将增量更新呈现在用户界面上，
		而不需要重载（刷新）整个页面，这使得程序能够更快地回应用户的操作
	
	ajax的作用？
		异步交互
		无刷新(局部刷新)
		
		异步：在同一时刻，一方在执行，另一方也会同时执行
		
		同步：在同一时刻，一方在执行，另一方只能等待
		
	ajax的使用？
		方式一：js原生代码
			get请求方式：
				function getRequest() {
					var xmlhttp;
					if (window.XMLHttpRequest) {
						xmlhttp = new XMLHttpRequest();
					} else {
						// code for IE6, IE5
						xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
					}
					return xmlhttp;
				}
				
				function send() {
					//发送ajax
					
					//获取xmlhttp请求对象
					var xmlhttp = getRequest();
					
					//接收响应
					xmlhttp.onreadystatechange = function() {
						//alert(this.readyState);
					   if (this.readyState == 4 && this.status == 200) {
							alert(this.responseText);
					   }
					};
					
					//发送请求
					xmlhttp.open("GET", "/day56/ajaxServlet?username=tom", true);
					xmlhttp.send();
				}
				
			post请求方式：
				function getRequest() {
					var xmlhttp;
					if (window.XMLHttpRequest) {
						xmlhttp = new XMLHttpRequest();
					} else {
						// code for IE6, IE5
						xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
					}
					return xmlhttp;
				}
				
				function send() {
					//发送ajax
					
					//获取xmlhttp请求对象
					var xmlhttp = getRequest();
					
					//接收响应
					xmlhttp.onreadystatechange = function() {
						//alert(this.readyState);
					   if (this.readyState == 4 && this.status == 200) {
							alert(this.responseText);
					   }
					};
					
					//发送请求
					xmlhttp.open("post", "/day56/ajaxServlet", true);
					xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
					xmlhttp.send("username=tom");
				}
				
		方式二：jquery，复杂版(功能多一些)
		方式三：jquery，简化版(功能少一些)
		
		
		
	
1.ajax
	ajax的使用？
		方式一：js原生代码
			get请求方式：
				function getRequest() {
					var xmlhttp;
					if (window.XMLHttpRequest) {
						xmlhttp = new XMLHttpRequest();
					} else {
						// code for IE6, IE5
						xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
					}
					return xmlhttp;
				}
				
				function send() {
					//发送ajax
					
					//获取xmlhttp请求对象
					var xmlhttp = getRequest();
					
					//接收响应
					xmlhttp.onreadystatechange = function() {
						//alert(this.readyState);
					   if (this.readyState == 4 && this.status == 200) {
							alert(this.responseText);
					   }
					};
					
					//发送请求
					xmlhttp.open("GET", "/day56/ajaxServlet?username=tom", true);
					xmlhttp.send();
				}
				
			post请求方式：
				function getRequest() {
					var xmlhttp;
					if (window.XMLHttpRequest) {
						xmlhttp = new XMLHttpRequest();
					} else {
						// code for IE6, IE5
						xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
					}
					return xmlhttp;
				}
				
				function send() {
					//发送ajax
					
					//获取xmlhttp请求对象
					var xmlhttp = getRequest();
					
					//接收响应
					xmlhttp.onreadystatechange = function() {
						//alert(this.readyState);
					   if (this.readyState == 4 && this.status == 200) {
							alert(this.responseText);
					   }
					};
					
					//发送请求
					xmlhttp.open("post", "/day56/ajaxServlet", true);
					xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
					xmlhttp.send("username=tom");
				}
				
		方式二：jquery，复杂版(功能多一些)
			get请求：
				$.ajax({
					type: "get",
					url: "/day57/ajaxServlet",
					data: "username=tom",
					success: function(data){
						alert(data);
					}
				});
				
			post请求：
				$.ajax({
					type: "post",
					url: "/day57/ajaxServlet",
					data: "username=tom",
					success: function(data){
						alert(data);
					}
				});
		
		方式三：jquery，简化版(功能少一些)
			get请求：
				$.get("/day57/ajaxServlet", "username=tom", function(data){
					alert(data);
				});
				
			post请求：
				$.post("/day57/ajaxServlet", "username=tom", function(data){
					alert(data);
				});
				
2.json
	什么是json？
		JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。
		它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。
		简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 
		易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。
		
		json就是js中的一种对象，和数组一样
	
	json的定义格式？
		var json = {key:value, key:value, ......};
		
		注意：key为字符串，所以可以加引号，也可以不加引号
			  value可以为任意类型的数据，如果是字符串的数据，需要加引号
		
	json数据的获取？
		json对象.键名
		json对象['键名']
		
	json的遍历？
		使用for...in循环
		
		for(var key in json) {
			alert(key + "..." + json[key]);
		}
		
	json格式字符串和对象之间的相互转换？
		json解析工具？
			fastjson
			jackson
	
		1.json格式的字符串 -> 对象
			//json格式的字符串
			String json = "{\"name\":\"tom\",\"age\":18}";
			
			//使用jackson
			ObjectMapper om = new ObjectMapper();
			User user = om.readValue(json, User.class);
			
			System.out.println(user);
		
		2.对象 -> json格式的字符串
			a.user对象
				//创建User对象
				User user = new User("tom",18);
				
				//使用jackson
				ObjectMapper om = new ObjectMapper();
				String json = om.writeValueAsString(user);
				
				System.out.println(json);//{"name":"tom","age":18}
			
			b.List<User>
				//创建List容器
				List<User> users = new ArrayList<>();
				
				//存储数据
				users.add(new User("tom",18));
				users.add(new User("jerry",19));
				
				//转换成json格式字符串
				ObjectMapper om = new ObjectMapper();
				String json = om.writeValueAsString(users);
				
				System.out.println(json);//[{"name":"tom","age":18},{"name":"jerry","age":19}]
			
			c.Map<String, String>
				//创建Map容器
				Map<String, String> map = new HashMap<>();
				
				//存储数据
				map.put("name", "tom");
				map.put("age", "18");
				
				//转换成json格式字符串
				ObjectMapper om = new ObjectMapper();
				String json = om.writeValueAsString(map);
				
				System.out.println(json);//{"name":"tom","age":"18"}
		
3.蜗牛商城
	a.技术选型
		前端：
			html
			css
			js
			bootstrap
			jquery
			ajax
		
		后端：
			servlet
			filter
			listener
			jdbc
			druid
			c3p0
			jdbctemplate
			mybatis
		
	b.项目环境搭建
		1.数据库环境搭建
			建库
			建表
			插入数据
			
		2.开发环境搭建
			创建项目
			创建包
			导入相关jar
			导入相关配置文件
			导入相关工具类
			